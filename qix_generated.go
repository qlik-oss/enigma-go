// Code generated by QIX generator (./schema/generate.go) for Qlik Associative Engine version 12.401.0 . DO NOT EDIT.

package enigma

import (
	"context"
	"encoding/json"
)

type AlfaNumString struct {
	// Calculated value.
	String string `json:"qString,omitempty"`
	// Is set to true if the value is a numeric.
	IsNum bool `json:"qIsNum,omitempty"`
}

type AlternateStateData struct {
	// Name of the alternate state.
	// Default is current selections: $
	StateName string `json:"qStateName,omitempty"`
	// List of the selections.
	FieldItems []*BookmarkFieldItem `json:"qFieldItems,omitempty"`
}

type AppEntry struct {
	// Identifier of the app.
	ID string `json:"qID,omitempty"`
	// Title of the app.
	Title string `json:"qTitle,omitempty"`
	// Path of the app.
	Path string `json:"qPath,omitempty"`
	// Last reload time of the app.
	LastReloadTime string `json:"qLastReloadTime,omitempty"`
	// Is set to true if the app is read-only.
	ReadOnly bool `json:"qReadOnly,omitempty"`
	// Meta data.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// App thumbnail.
	Thumbnail *StaticContentUrl `json:"qThumbnail,omitempty"`
	FileSize  int               `json:"qFileSize,omitempty"`
	// If true the app has section access configured.
	HasSectionAccess bool `json:"qHasSectionAccess,omitempty"`
}

// Lists the app objects. Is the layout for AppObjectListDef.
// An app object is a generic object created at app level.
type AppObjectList struct {
	// Information about the list of dimensions.
	Items []*NxContainerEntry `json:"qItems,omitempty"`
}

// Defines the list of objects in an app.
// An app object is a generic object created at app level.
type AppObjectListDef struct {
	// Type of the app list.
	Type string `json:"qType,omitempty"`
	// Data that you want to include in the app list definition.
	// You need to enter the paths to the information you want to retrieve.
	Data json.RawMessage `json:"qData,omitempty"`
}

type AppScript struct {
	// Script text.
	Script string `json:"qScript,omitempty"`
	// Information about publishing and permissions.
	// This parameter is optional.
	Meta *NxMeta `json:"qMeta,omitempty"`
}

type ArrayOfNxValuePoint []*NxPivotValuePoint

type AssociationScore struct {
	// Pair of fields.
	// _< FieldName1>_ / < FieldName2>
	// Where:
	// < FieldName1 > is a field in the table 1 (defined in qTable1 )
	// < FieldName2 > is a field in the table 2 (defined in qTable2 )
	// If the field is a synthetic key, the name of the field is preceded by [Synthetic key]: .
	FieldPairName string `json:"qFieldPairName,omitempty"`
	// Flag used to interpret calculated scores.
	// One of the following values or sum of values that apply:
	//
	// • 0: The cardinal ratio cannot be zero but the symbol score and the row score can be zero.
	//
	// • -1: The fields do not have the same type.
	//
	// • -2: The number of rows of the field FieldName1 is zero.
	//
	// • -4: The number of distinct values of the field FieldName1 is zero.
	//
	// • -8: The number of rows of the field FieldName2 is zero.
	//
	// • -16: The number of distinct values of the field FieldName2 is zero.
	//
	// Example:
	// The number of rows of the field FieldName1 is zero, and the number of distinct values of the field FieldName2 is zero, then qScoreSummary is -18.
	ScoreSummary int `json:"qScoreSummary,omitempty"`
	// Association information about the field FieldName1 defined in qFieldPairName .
	Field1Scores *FieldScores `json:"qField1Scores,omitempty"`
	// Association information about the field FieldName2 defined in qFieldPairName .
	Field2Scores *FieldScores `json:"qField2Scores,omitempty"`
}

type BNFDef struct {
	// Array of token references that all together build up the definition of the current token.
	// Generally, if the array is not empty, the definition is a BNF rule (_qIsBnfRule_ is set to true). However, some BNF  rules do have an empty array (_qIsBnfRule_ is set to true, but qBnf is empty).
	Bnf []int `json:"qBnf,omitempty"`
	// Number of the current token definition.
	Nbr int `json:"qNbr,omitempty"`
	// Number of the parent rule definition.
	PNbr int `json:"qPNbr,omitempty"`
	// Reference identifier to a function described in the documentation. The identifier is stored in the definition of the token containing the function name.
	// Is not used in Qlik Sense.
	HelpId int `json:"qHelpId,omitempty"`
	// Token name.
	// One of:
	//
	// • A rule name
	//
	// • An identifier
	//
	// • A literal value
	Name string `json:"qName,omitempty"`
	// Literal string of the token.
	// Examples: 'Round' and '('.
	Str string `json:"qStr,omitempty"`
	// If set to true, a list of related rule tokens is assigned to qBnf .
	// This parameter is optional. The default value is false.
	IsBnfRule bool `json:"qIsBnfRule,omitempty"`
	// If set to true, the definition specifies a script statement.
	// This parameter is optional. The default value is false.
	ScriptStatement bool `json:"qScriptStatement,omitempty"`
	// If set to true, the definition specifies a control statement.
	// This parameter is optional. The default value is false.
	ControlStatement bool `json:"qControlStatement,omitempty"`
	// If set to true, the definition specifies a literal token.
	// This parameter is optional. The default value is false.
	BnfLiteral bool `json:"qBnfLiteral,omitempty"`
	// If set to true, the definition is related to a Qlik Sense function. It cannot be an aggregation function.
	// This parameter is optional. The default value is false.
	QvFunc bool `json:"qQvFunc,omitempty"`
	// If set to true, the definition is related to an aggregation function.
	// This parameter is optional. The default value is false.
	AggrFunc bool `json:"qAggrFunc,omitempty"`
	// Group of the function.
	//
	// One of:
	//
	// • ALL or FUNC_GROUP_ALL
	//
	// • U or FUNC_GROUP_UNKNOWN
	//
	// • NONE or FUNC_GROUP_NONE
	//
	// • AGGR or FUNC_GROUP_AGGR
	//
	// • NUM or FUNC_GROUP_NUMERIC
	//
	// • RNG or FUNC_GROUP_RANGE
	//
	// • EXP or FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC
	//
	// • TRIG or FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC
	//
	// • FIN or FUNC_GROUP_FINANCIAL
	//
	// • MATH or FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE
	//
	// • COUNT or FUNC_GROUP_COUNTER
	//
	// • STR or FUNC_GROUP_STRING
	//
	// • MAPP or FUNC_GROUP_MAPPING
	//
	// • RCRD or FUNC_GROUP_INTER_RECORD
	//
	// • CND or FUNC_GROUP_CONDITIONAL
	//
	// • LOG or FUNC_GROUP_LOGICAL
	//
	// • NULL or FUNC_GROUP_NULL
	//
	// • SYS or FUNC_GROUP_SYSTEM
	//
	// • FILE or FUNC_GROUP_FILE
	//
	// • TBL or FUNC_GROUP_TABLE
	//
	// • DATE or FUNC_GROUP_DATE_AND_TIME
	//
	// • NUMI or FUNC_GROUP_NUMBER_INTERPRET
	//
	// • FRMT or FUNC_GROUP_FORMATTING
	//
	// • CLR or FUNC_GROUP_COLOR
	//
	// • RNK or FUNC_GROUP_RANKING
	//
	// • GEO or FUNC_GROUP_GEO
	//
	// • EXT or FUNC_GROUP_EXTERNAL
	//
	// • PROB or FUNC_GROUP_PROBABILITY
	//
	// • ARRAY or FUNC_GROUP_ARRAY
	//
	// • LEG or FUNC_GROUP_LEGACY
	FG FunctionGroup `json:"qFG,omitempty"`
	// If set to true, the definition is related to a field.
	// This parameter is optional. The default value is false.
	FieldFlag bool `json:"qFieldFlag,omitempty"`
	// Type of the data.
	//
	// One of:
	//
	// • N or NOT_META
	//
	// • D or META_DOC_NAME
	//
	// • R or META_RET_TYPE
	//
	// • V or META_DEFAULT_VALUE
	MT BNFDefMetaType `json:"qMT,omitempty"`
	// Indicates whether a script statement, a chart or a script function is deprecated (not recommended for use).
	// If set to true, the script statement or the function is not recommended for use in Qlik Sense.
	// This parameter is optional. The default value is false.
	Depr bool `json:"qDepr,omitempty"`
	// List of groups the function belongs to.
	FGList []FunctionGroup `json:"qFGList,omitempty"`
}

type BNFDefMetaType string

func (t BNFDefMetaType) String() string {
	return string(t)
}

func (t BNFDefMetaType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type BNFType string

func (t BNFType) String() string {
	return string(t)
}

func (t BNFType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type BookmarkFieldItem struct {
	// Name and type of the field.
	Def *FieldDefEx `json:"qDef,omitempty"`
	// Indicates if the field is locked.
	// Default is false.
	Locked bool `json:"qLocked,omitempty"`
	// Information on the selections criteria.
	SelectInfo *SelectInfo   `json:"qSelectInfo,omitempty"`
	Values     []*FieldValue `json:"qValues,omitempty"`
	// List of excluded values.
	// Either the list of selected values or the list of excluded values is displayed.
	ExcludedValues []*FieldValue `json:"qExcludedValues,omitempty"`
	// If set to true, selections within a list object are made in AND mode; If you have a list object that lists all customers, by selecting Customer 1 and Customer 2 while in and-mode, all records that are associated with Customer 1 and Customer 2 are selected.
	// The default value is false; selections within a list object are made in OR mode. If you have a list object that lists all customers, by selecting Customer 1 and Customer 2 while in or-mode, all records that are associated with either Customer 1 or Customer 2 are selected.
	// This parameter is not returned if set to false.
	AndMode bool `json:"qAndMode,omitempty"`
	// If set to true, the field has always one selection (not 0 and not more than 1). If another value is selected, the previous one is unselected.
	// The default value is false. This parameter is not returned if set to false.
	OneAndOnlyOne bool `json:"qOneAndOnlyOne,omitempty"`
}

// Defines the range of the bookmark fields that are returned.
type BookmarkFieldPage struct {
	// The start value of the range.
	StartIndex int `json:"qStartIndex,omitempty"`
	// The end value of the range.
	EndIndex int `json:"qEndIndex,omitempty"`
}

// Lists the bookmarks. Is the layout for BookmarkListDef.
type BookmarkList struct {
	// Information about the list of bookmarks.
	Items []*NxContainerEntry `json:"qItems,omitempty"`
}

// Defines the list of bookmarks.
type BookmarkListDef struct {
	// Type of the list.
	Type string `json:"qType,omitempty"`
	// Data
	Data json.RawMessage `json:"qData,omitempty"`
}

type BookmarkVariableItem struct {
	// Name of the variable.
	Name string `json:"qName,omitempty"`
	// Value of the variable.
	Value *FieldValue `json:"qValue,omitempty"`
}

type CalendarStrings struct {
	// List of short day names.
	DayNames []string `json:"qDayNames,omitempty"`
	// List of short month names.
	MonthNames []string `json:"qMonthNames,omitempty"`
	// List of long day names.
	LongDayNames []string `json:"qLongDayNames,omitempty"`
	// List of long month names.
	LongMonthNames []string `json:"qLongMonthNames,omitempty"`
}

type CharEncodingType string

func (t CharEncodingType) String() string {
	return string(t)
}

func (t CharEncodingType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type CharRange struct {
	// Position of the first search occurrence.
	CharPos int `json:"qCharPos,omitempty"`
	// Number of occurrences found.
	CharCount int `json:"qCharCount,omitempty"`
}

// Lists the children of a generic object. Is the layout for ChildListDef.
// ChildList is used by the GetLayout Method to list the children of a generic object.
type ChildList struct {
	// Information about the items in the app object.
	Items []*NxContainerEntry `json:"qItems,omitempty"`
}

// Defines the list of children of a generic object.
// What is defined in ChildListDef has an impact on what the GetLayout method returns. See Example for more information.
type ChildListDef struct {
	// Data that you want to include in the child list definition.
	// You need to enter the paths to the information you want to retrieve.
	Data json.RawMessage `json:"qData,omitempty"`
}

type CodePage struct {
	// Number of the code page.
	Number int `json:"qNumber,omitempty"`
	// Name of the code page.
	Name string `json:"qName,omitempty"`
	// Description of the code page.
	Description string `json:"qDescription,omitempty"`
}

type Connection struct {
	// Identifier of the connection.
	// Is generated by the engine and is unique.
	Id string `json:"qId,omitempty"`
	// Name of the connection.
	// This parameter is mandatory and must be set when creating or modifying a connection.
	Name string `json:"qName,omitempty"`
	// One of:
	//
	// • ODBC CONNECT TO [<provider name>]
	//
	// • OLEDB CONNECT TO [<provider name>]
	//
	// • CUSTOM CONNECT TO [<provider name>]
	//
	// • "<local absolute or relative path, UNC path>"
	//
	// • "<URL>"
	//
	// Connection string.
	// This parameter is mandatory and must be set when creating or modifying a connection.
	ConnectionString string `json:"qConnectionString,omitempty"`
	// One of:
	//
	// • ODBC
	//
	// • OLEDB
	//
	// • <Name of the custom connection file>
	//
	// • folder
	//
	// • internet
	//
	// Type of the connection.
	// This parameter is mandatory and must be set when creating or modifying a connection.
	// For ODBC, OLEDB and custom connections, the engine checks that the connection type matches the connection string.
	// The type is not case sensitive.
	Type string `json:"qType,omitempty"`
	// Name of the user who creates the connection.
	// This parameter is optional; it is only used for OLEDB, ODBC and CUSTOM connections.
	// A call to GetConnection Method does not return the user name.
	UserName string `json:"qUserName,omitempty"`
	// Password of the user who creates the connection.
	// This parameter is optional; it is only used for OLEDB, ODBC and CUSTOM connections.
	// A call to GetConnection Method does not return the password.
	Password string `json:"qPassword,omitempty"`
	// Is generated by the engine.
	// Creation date of the connection or last modification date of the connection.
	ModifiedDate string `json:"qModifiedDate,omitempty"`
	// Information about the connection.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Select which user credentials to use to connect to the source.
	//
	// • LOG_ON_SERVICE_USER: Disables
	//
	// • LOG_ON_CURRENT_USER: Enables
	//
	// One of:
	//
	// • LOG_ON_SERVICE_USER
	//
	// • LOG_ON_CURRENT_USER
	LogOn LogOnType `json:"qLogOn,omitempty"`
}

type ContentLibraryList struct {
	// Information about the content library.
	Items []*ContentLibraryListItem `json:"qItems,omitempty"`
}

type ContentLibraryListItem struct {
	// Name of the library.
	Name string `json:"qName,omitempty"`
	// Is set to true if the library is specific to the app (not a global content library).
	AppSpecific bool `json:"qAppSpecific,omitempty"`
	// Information about publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
}

type CustomConnector struct {
	// Name of the custom connector file.
	Provider string `json:"qProvider,omitempty"`
	// Name of the parent folder that contains the custom connector file.
	Parent string `json:"qParent,omitempty"`
	// Name of the custom connector as displayed in the Qlik interface.
	DisplayName string `json:"qDisplayName,omitempty"`
	// Mode of the machine (64 or 32 bits).
	//
	// One of:
	//
	// • CONNECT_DEFAULT
	//
	// • CONNECT_64
	//
	// • CONNECT_32
	MachineMode          GenericConnectMachine `json:"qMachineMode,omitempty"`
	SupportFileStreaming bool                  `json:"qSupportFileStreaming,omitempty"`
}

type DataField struct {
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// Is set to true if the field is a primary key.
	IsKey bool `json:"qIsKey,omitempty"`
	// Is shown for fixed records.
	// _qOriginalFieldName_ and qName are identical if no field names are used in the file.
	// _qOriginalFieldName_ differs from qName if embedded file names are used in the file.
	OriginalFieldName string `json:"qOriginalFieldName,omitempty"`
}

type DataRecord struct {
	// List of values inside the table.
	// The first values (in result/qPreview/0/qValues ) correspond to the field names in the table.
	// The following values (from result/qPreview/1/qValues ) are the values of the fields in the table.
	Values []string `json:"qValues,omitempty"`
}

type DataTable struct {
	// Name of the table.
	Name string `json:"qName,omitempty"`
	// Type of the table.
	// For example: Table or View.
	Type string `json:"qType,omitempty"`
}

type DataTableEx struct {
	// Name of the table.
	Name string `json:"qName,omitempty"`
	// List of the fields in the table.
	Fields []*DataField `json:"qFields,omitempty"`
	// List of format specification items, within brackets.
	// Examples of specification items:
	//
	// • file type
	//
	// • embedded labels, no labels
	//
	// • table is <table name>
	FormatSpec string `json:"qFormatSpec,omitempty"`
}

type Database struct {
	// Name of the database.
	Name string `json:"qName,omitempty"`
	// Is set to true if the database is set by default.
	IsDefault bool `json:"qIsDefault,omitempty"`
}

type DatabaseInfo struct {
	// Name of the product accessed by the provider.
	DBMSName string `json:"qDBMSName,omitempty"`
	// If set to true, it means that the data source contains some databases.
	DBUsage bool `json:"qDBUsage,omitempty"`
	// If set to true, it means that the data source contains some owners.
	OwnerUsage bool `json:"qOwnerUsage,omitempty"`
	// Character string used after the database name.
	// Example with separator " . ":
	// FROM LinkedTablesData.dbo.Months
	// Where:
	//
	// • LinkedTablesData is the database name
	//
	// • dbo is the owner name
	//
	// • Months is the table name
	DBSeparator string `json:"qDBSeparator,omitempty"`
	// Character string used after the owner name.
	// Example with separator " . ":
	// FROM LinkedTablesData.dbo.Months
	// Where:
	//
	// • LinkedTablesData is the database name
	//
	// • dbo is the owner name
	//
	// • Months is the table name
	OwnerSeparator string `json:"qOwnerSeparator,omitempty"`
	// If set to true, it means that the database is displayed first, before the owners and tables.
	DBFirst bool `json:"qDBFirst,omitempty"`
	// Prefix used with field, database or owner names that contain special characters or keywords.
	QuotePreffix string `json:"qQuotePreffix,omitempty"`
	// Suffix used with field, database or owner names that contain special characters or keywords.
	QuoteSuffix string `json:"qQuoteSuffix,omitempty"`
	// List of the special characters.
	SpecialChars string `json:"qSpecialChars,omitempty"`
	// Name of the default database.
	DefaultDatabase string `json:"qDefaultDatabase,omitempty"`
	// List of the script keywords.
	Keywords []string `json:"qKeywords,omitempty"`
}

type DatabaseOwner struct {
	// Name of the owner.
	Name string `json:"qName,omitempty"`
}

type DelimiterInfo struct {
	// Name of the delimiter.
	// Example:
	// "Tab_DELIMITER"
	Name string `json:"qName,omitempty"`
	// Representation of the delimiter value that is used in the script.
	// Example:
	// "'\t'"
	ScriptCode string `json:"qScriptCode,omitempty"`
	// Delimiter character number used by the engine to determine how to separate the values.
	Number int `json:"qNumber,omitempty"`
	// Is set to true if multiple spaces are used to separate the values.
	IsMultiple bool `json:"qIsMultiple,omitempty"`
}

type DerivedFieldsInTableData struct {
	// Name of the derived definition.
	DefinitionName string `json:"qDefinitionName,omitempty"`
	// List of tags.
	Tags []string `json:"qTags,omitempty"`
	// Is set to true is the derived field is in use.
	Active bool `json:"qActive,omitempty"`
}

// Lists the dimensions. Is the layout for DimensionListDef.
type DimensionList struct {
	// Information about the list of dimensions.
	Items []*NxContainerEntry `json:"qItems,omitempty"`
}

// Defines the lists of dimensions.
type DimensionListDef struct {
	// Type of the list.
	Type string `json:"qType,omitempty"`
	// Data
	Data json.RawMessage `json:"qData,omitempty"`
}

// Parameters for a reload.
type DoReloadExParams struct {
	// 0: for default mode.
	// 1: for ABEND; the reload of the script ends if an error occurs.
	// 2: for ignore; the reload of the script continues even if an error is detected in the script.
	Mode int `json:"qMode,omitempty"`
	// Set to true for partial reload.
	// The default value is false.
	Partial bool `json:"qPartial,omitempty"`
	// Set to true to debug reload.
	// The default value is false.
	Debug bool `json:"qDebug,omitempty"`
	// Optional reload ID.
	// ID will be automatically generated if not set.
	ReloadId string `json:"qReloadId,omitempty"`
}

// The result and path to script log for a reload.
type DoReloadExResult struct {
	// The reload is successful if True.
	Success bool `json:"qSuccess,omitempty"`
	// Path to the script log file.
	ScriptLogFile string `json:"qScriptLogFile,omitempty"`
}

type DocListEntry struct {
	// Name of the app.
	DocName string `json:"qDocName,omitempty"`
	// Not used.
	ConnectedUsers int `json:"qConnectedUsers,omitempty"`
	// Last modified time stamp of the app.
	// This property is used only with Qlik Sense Desktop.
	// It is set to 0 for Qlik Sense Enterprise.
	FileTime Float64 `json:"qFileTime,omitempty"`
	// Size of remote app.
	// This property is used only with Qlik Sense Desktop.
	// It is set to 0 for Qlik Sense Enterprise.
	FileSize Float64 `json:"qFileSize,omitempty"`
	// Identifier of the app.
	//
	// • In Qlik Sense Desktop, the identifier is the path and name of the app.
	//
	// • In Qlik Sense Enterprise, the identifier is the app's GUID.
	DocId string `json:"qDocId,omitempty"`
	// Meta data related to the app.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Last reload time of the app.
	LastReloadTime string `json:"qLastReloadTime,omitempty"`
	// If set to true, the app is read-only.
	ReadOnly bool `json:"qReadOnly,omitempty"`
	// Title of the app.
	Title string `json:"qTitle,omitempty"`
	// Thumbnail of the app.
	Thumbnail *StaticContentUrl `json:"qThumbnail,omitempty"`
	// If true the app has section access configured.
	HasSectionAccess bool `json:"qHasSectionAccess,omitempty"`
}

type DriveInfo struct {
	// Value of the drive.
	// Examples:
	// C:\\\, E:\\\
	Drive string `json:"qDrive,omitempty"`
	// Type of the drive.
	// _Fixed_ means physical drive.
	Type string `json:"qType,omitempty"`
	// Name of the drive.
	Name string `json:"qName,omitempty"`
	// Information about the drive type.
	//
	// One of:
	//
	// • REMOVABLE
	//
	// • FIXED
	//
	// • NETWORK
	//
	// • CD_ROM
	//
	// • RAM
	//
	// • UNKNOWN_TYPE
	TypeIdentifier DriveType `json:"qTypeIdentifier,omitempty"`
	UnnamedDrive   bool      `json:"qUnnamedDrive,omitempty"`
}

type DriveType string

func (t DriveType) String() string {
	return string(t)
}

func (t DriveType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type EditorBreakpoint struct {
	// Name of the breakpoint.
	BufferName string `json:"qbufferName,omitempty"`
	// Line number in the script where the breakpoint is set.
	LineIx int `json:"qlineIx,omitempty"`
	// If set to true then the breakpoint is enabled (in use).
	Enabled bool `json:"qEnabled,omitempty"`
}

// Renders the embedded snapshot in an object.
// The following is returned:
//
// • Any dynamic properties defined in the bookmark
//
// • Any properties defined in qEmbeddedSnapshot
//
// Properties:
//
// "qEmbeddedSnapshot": {}
type EmbeddedSnapshot struct {
}

// Defines the embedded snapshot in a generic object.
//
// Properties:
//
// "EmbeddedSnapshotDef": {}
type EmbeddedSnapshotDef struct {
}

type ErrorData struct {
	// Detailed information about the error message.
	ErrorString string `json:"qErrorString,omitempty"`
	// Line termination characters.
	LineEnd string `json:"qLineEnd,omitempty"`
	// Script statement where the error occurs.
	Line string `json:"qLine,omitempty"`
	// Type of the error messages.
	//
	// One of:
	//
	// • EDC_ERROR
	//
	// • EDC_WARNING
	//
	// • EDC_CIRCULAR_REFERENCE
	ErrorDataCode ErrorDataCode    `json:"qErrorDataCode,omitempty"`
	Message       *ProgressMessage `json:"qMessage,omitempty"`
}

type ErrorDataCode string

func (t ErrorDataCode) String() string {
	return string(t)
}

func (t ErrorDataCode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Obsolete, use qrs API's to fetch extensions.
type ExtensionList struct {
	Items []string `json:"qItems,omitempty"`
}

// Obsolete, use qrs API's to fetch extensions.
type ExtensionListDef struct {
}

type FieldAttrType string

func (t FieldAttrType) String() string {
	return string(t)
}

func (t FieldAttrType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Sets the formatting of a field.
// The properties of qFieldAttributes and the formatting mechanism are described below.
//
// Formatting mechanism:
//
// The formatting mechanism depends on the type set in qType, as shown below:
// In case of inconsistencies between the type and the format pattern, the format pattern takes precedence over the type.
//
// Type is DATE, TIME, TIMESTAMP or INTERVAL:
//
// The following applies:
//
// • If a format pattern is defined in qFmt , the formatting is as defined in qFmt .
//
// • If qFmt is empty, the formatting is defined by the number interpretation variables included at the top of the script ( TimeFormat , DateFormat , TimeStampFormat ).
//
// • The properties qDec , qThou , qnDec , qUseThou are not used.
//
// Type is INTEGER:
//
// The following applies:
//
// • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the formatting mechanism uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
//
// • If no format pattern is defined in qFmt , no formatting is applied. The properties qDec , qThou , qnDec , qUseThou and the number interpretation variables defined in the script are not used .
//
// Type is REAL:
//
// The following applies:
//
// • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
//
// • If no format pattern is defined in qFmt , and if the value is almost an integer value (for example, 14,000012), the value is formatted as an integer. The properties qDec , qThou , qnDec , qUseThou are not used.
//
// • If no format pattern is defined in qFmt , and if qnDec is defined and not 0, the property qDec is used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
//
// • If no format pattern is defined in qFmt , and if qnDec is 0, the number of decimals is 14 and the property qDec is used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
//
// Type is FIX:
//
// The following applies:
//
// • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of the script ( DecimalSep and ThousandSep ).
//
// • If no format pattern is defined in qFmt , the properties qDec and qnDec are used. If qDec is not defined, the variable DecimalSep defined at the top of the script is used.
//
// Type is MONEY:
//
// The following applies:
//
// • If a format pattern is defined in qFmt , the engine looks at the values set in qDec and qThou . If these properties are not defined, the engine uses the number interpretation variables included at the top of any script ( MoneyDecimalSep and MoneyThousandSep ).
//
// • If no format pattern is defined in qFmt , the engine uses the number interpretation variables included at the top of the script ( MoneyDecimalSep and MoneyThousandSep ).
//
// Type is ASCII:
//
// No formatting, qFmt is ignored.
type FieldAttributes struct {
	// Type of the field.
	// Default is U.
	//
	// One of:
	//
	// • U or UNKNOWN
	//
	// • A or ASCII
	//
	// • I or INTEGER
	//
	// • R or REAL
	//
	// • F or FIX
	//
	// • M or MONEY
	//
	// • D or DATE
	//
	// • T or TIME
	//
	// • TS or TIMESTAMP
	//
	// • IV or INTERVAL
	Type FieldAttrType `json:"qType,omitempty"`
	// Number of decimals.
	// Default is 10.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	NDec *int `json:"qnDec,omitempty"`
	// Defines whether or not a thousands separator must be used.
	// Default is 0.
	UseThou int `json:"qUseThou,omitempty"`
	// Defines the format pattern that applies to qText .
	// Is used in connection to the type of the field (parameter qType ).
	// For more information, see Formatting mechanism.
	// Example: YYYY-MM-DD for a date.
	Fmt string `json:"qFmt,omitempty"`
	// Defines the decimal separator.
	// Example:
	//
	// .:
	Dec string `json:"qDec,omitempty"`
	// Defines the thousand separator (if any).
	// Is used if qUseThou is set to 1.
	// Example:
	//
	// ,:
	Thou string `json:"qThou,omitempty"`
}

type FieldDefEx struct {
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// Type of data entity.
	//
	// One of:
	//
	// • NOT_PRESENT
	//
	// • PRESENT
	//
	// • IS_CYCLIC_GROUP
	//
	// • IS_DRILL_GROUP
	//
	// • IS_VAR
	//
	// • IS_EXPR
	//
	// • IS_IMPLICIT
	//
	// • IS_DETAIL
	Type FieldType `json:"qType,omitempty"`
}

type FieldDescription struct {
	// Internal number of the field.
	InternalNumber int `json:"qInternalNumber,omitempty"`
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// List of table names.
	SrcTables []string `json:"qSrcTables,omitempty"`
	// If set to true, it means that the field is a system field.
	// The default value is false.
	IsSystem bool `json:"qIsSystem,omitempty"`
	// If set to true, it means that the field is hidden.
	// The default value is false.
	IsHidden bool `json:"qIsHidden,omitempty"`
	// If set to true, it means that the field is a semantic.
	// The default value is false.
	IsSemantic bool `json:"qIsSemantic,omitempty"`
	// If set to true, only distinct field values are shown.
	// The default value is false.
	DistinctOnly bool `json:"qDistinctOnly,omitempty"`
	// Number of distinct field values.
	Cardinal int `json:"qCardinal,omitempty"`
	// Total number of field values.
	TotalCount             int  `json:"qTotalCount,omitempty"`
	PossibleCount_OBSOLETE int  `json:"qPossibleCount_OBSOLETE,omitempty"`
	HasInfo_OBSOLETE       bool `json:"qHasInfo_OBSOLETE,omitempty"`
	// If set to true, it means that the field is locked.
	// The default value is false.
	IsLocked bool `json:"qIsLocked,omitempty"`
	// If set to true, it means that the field has one and only one selection (not 0 and not more than 1).
	// If this property is set to true, the field cannot be cleared anymore and no more selections can be performed in that field.
	// The default value is false.
	AlwaysOneSelected bool `json:"qAlwaysOneSelected,omitempty"`
	// If set to true a logical AND (instead of a logical OR) is used when making selections in a field.
	// The default value is false.
	AndMode bool `json:"qAndMode,omitempty"`
	// Is set to true if the value is a numeric.
	// The default value is false.
	IsNumeric bool `json:"qIsNumeric,omitempty"`
	// Field comment.
	Comment string `json:"qComment,omitempty"`
	// Gives information on a field. For example, it can return the type of the field.
	// Examples: key, text, ASCII.
	Tags []string `json:"qTags,omitempty"`
	// If set to true, it means that the field is a field on the fly.
	// The default value is false.
	IsDefinitionOnly bool `json:"qIsDefinitionOnly,omitempty"`
	// Static RAM memory used in bytes.
	ByteSize int `json:"qByteSize,omitempty"`
}

type FieldInTableData struct {
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// Is shown for fixed records.
	// _qOriginalFieldName_ and qName are identical if no field names are used in the file.
	// _qOriginalFieldName_ differs from qName if embedded file names are used in the file.
	OriginalFields []string `json:"qOriginalFields,omitempty"`
	Present        bool     `json:"qPresent,omitempty"`
	// This property is set to true if the field contains some Null values.
	HasNull bool `json:"qHasNull,omitempty"`
	HasWild bool `json:"qHasWild,omitempty"`
	// This property is set to true if the field contains some duplicate values.
	HasDuplicates bool `json:"qHasDuplicates,omitempty"`
	// This property is set to true if the field contains a synthetic key.
	IsSynthetic bool `json:"qIsSynthetic,omitempty"`
	// Number of records that have values (for example, not NULL) in the field as compared to the total number of records in the table.
	InformationDensity Float64 `json:"qInformationDensity,omitempty"`
	// Number of values that are non Null.
	NNonNulls int `json:"qnNonNulls,omitempty"`
	// Number of rows in the field.
	NRows int `json:"qnRows,omitempty"`
	// Number of distinct values in the field (in the current table) as compared to the total number of distinct values of this field (in all tables).
	SubsetRatio Float64 `json:"qSubsetRatio,omitempty"`
	// Number of distinct values in the field.
	NTotalDistinctValues   int `json:"qnTotalDistinctValues,omitempty"`
	NPresentDistinctValues int `json:"qnPresentDistinctValues,omitempty"`
	// Tells if the field is a key field.
	//
	// One of:
	//
	// • NOT_KEY
	//
	// • ANY_KEY
	//
	// • PRIMARY_KEY
	//
	// • PERFECT_KEY
	KeyType KeyType `json:"qKeyType,omitempty"`
	// Comment related to the field.
	Comment string `json:"qComment,omitempty"`
	// List of tags related to the field.
	Tags []string `json:"qTags,omitempty"`
	// List of the derived fields.
	DerivedFields   []*DerivedFieldsInTableData `json:"qDerivedFields,omitempty"`
	IsFieldOnTheFly bool                        `json:"qIsFieldOnTheFly,omitempty"`
	ReadableName    string                      `json:"qReadableName,omitempty"`
}

// Lists the fields present in the data model viewer. Is the layout for FieldListDef.
type FieldList struct {
	// Array of items.
	Items []*NxFieldDescription `json:"qItems,omitempty"`
}

// Defines the fields to show.
type FieldListDef struct {
	// Shows the system tables if set to true.
	// Default is false.
	ShowSystem bool `json:"qShowSystem,omitempty"`
	// Shows the hidden fields if set to true.
	// Default is false.
	ShowHidden bool `json:"qShowHidden,omitempty"`
	// Show the semantic fields if set to true.
	// Default is false.
	ShowSemantic bool `json:"qShowSemantic,omitempty"`
	// Shows the tables and fields present in the data model viewer if set to true.
	// Default is false.
	ShowSrcTables bool `json:"qShowSrcTables,omitempty"`
	// Shows the fields defined on the fly if set to true.
	// Default is false.
	ShowDefinitionOnly bool `json:"qShowDefinitionOnly,omitempty"`
	// Shows the fields and derived fields if set to true.
	// Default is false.
	ShowDerivedFields bool `json:"qShowDerivedFields,omitempty"`
	// Shows the Direct Discovery measure fields if set to true.
	// Default is false.
	ShowImplicit bool `json:"qShowImplicit,omitempty"`
}

type FieldOrColumn struct {
	// Name of the field or column to be matched.
	FieldName string `json:"qFieldName,omitempty"`
	// Name of the table to be matched on. This parameter is optional. If TableName is set, FieldName represent the Table column with that name. If TableName is not set, FieldName represents the the field with that name.
	TableName string `json:"qTableName,omitempty"`
}

type FieldScores struct {
	// Field name.
	// One of the field names defined in qFieldPairName.
	FieldName    string `json:"qFieldName,omitempty"`
	ReadableName string `json:"qReadableName,omitempty"`
	// Cardinality of a column/field divided by the number of rows in the table.
	// If the cardinal ratio is 1, it means that the column is a candidate/primary key.
	CardinalRatio Float64 `json:"qCardinalRatio,omitempty"`
	// Number of distinct matches between the two fields defined in qFieldPairName divided by the number of distinct values in the field qFieldName .
	// If 0, it means that there are no common values between the two fields defined in qFieldPairName .
	SymbolScore Float64 `json:"qSymbolScore,omitempty"`
	// Number of matches between the two fields defined in qFieldPairName divided by the number of values in the field qFieldName .
	// If 0, it means that there are no common values between the two fields defined in qFieldPairName .
	RowScore Float64 `json:"qRowScore,omitempty"`
}

type FieldType string

func (t FieldType) String() string {
	return string(t)
}

func (t FieldType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type FieldValue struct {
	// Text related to the field value.
	// This parameter is optional.
	Text string `json:"qText,omitempty"`
	// Is set to true if the value is a numeric.
	// This parameter is optional. Default is false.
	IsNumeric bool `json:"qIsNumeric,omitempty"`
	// Numeric value of the field.
	// This parameter is displayed if qIsNumeric is set to true.
	// This parameter is optional.
	Number Float64 `json:"qNumber,omitempty"`
}

// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
type FileDataFormat struct {
	// Type of the file.
	//
	// One of:
	//
	// • CSV or FILE_TYPE_CSV
	//
	// • FIX or FILE_TYPE_FIX
	//
	// • DIF or FILE_TYPE_DIF
	//
	// • EXCEL_BIFF or FILE_TYPE_EXCEL_BIFF
	//
	// • EXCEL_OOXML or FILE_TYPE_EXCEL_OOXML
	//
	// • HTML or FILE_TYPE_HTML
	//
	// • QVD or FILE_TYPE_QVD
	//
	// • XML or FILE_TYPE_XML
	//
	// • QVX or FILE_TYPE_QVX
	//
	// • JSON or FILE_TYPE_JSON
	//
	// • KML or FILE_TYPE_KML
	Type FileType `json:"qType,omitempty"`
	// One of:
	//
	// • Embedded labels (field names are present in the file)
	//
	// • No labels
	//
	// • Explicit labels (for DIFfiles)
	Label string `json:"qLabel,omitempty"`
	// One of:
	//
	// • None (no quotes)
	//
	// • MSQ (Modern Style Quoting)
	//
	// • Standard (quotes " " or ' ' can be used, but only if they are the first and last non blank characters of a field value)
	//
	// This property is used for delimited files.
	Quote string `json:"qQuote,omitempty"`
	// String that marks the beginning of the comment line.
	// Example: “
	//
	// ” or “//”:
	//
	// The engine ignores the commented lines during the data load.
	// This property is only used for delimited files.
	Comment string `json:"qComment,omitempty"`
	// Information about the delimiter.
	// This property is used for delimited files.
	Delimiter *DelimiterInfo `json:"qDelimiter,omitempty"`
	// Character set used in the file.
	CodePage int `json:"qCodePage,omitempty"`
	// Size of the header.
	// Example: If the header size is 2, the first two rows in the file are considered as header and not as data. The header can contain the field names.
	HeaderSize int `json:"qHeaderSize,omitempty"`
	// Record length.
	// Each record (row of data) contains a number of columns with a fixed field size.
	// This property is used for fixed record data files.
	RecordSize int `json:"qRecordSize,omitempty"`
	// Number of spaces that one tab character represents in the table file.
	// This property is used for fixed record data files.
	TabSize int `json:"qTabSize,omitempty"`
	// Is set to true, the end-of-file character is not taken into account during reload.
	// This property is used for delimited files and fixed record data files.
	IgnoreEOF bool `json:"qIgnoreEOF,omitempty"`
	// Positions of the field breaks in the table.
	// This property is used for fixed record data files.
	FixedWidthDelimiters string `json:"qFixedWidthDelimiters,omitempty"`
}

type FileType string

func (t FileType) String() string {
	return string(t)
}

func (t FileType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type FilterInfo struct {
	// One of:
	//
	// • NONE or FILTER_TYPE_NONE
	//
	// • RAW or FILTER_TYPE_RAW
	Type           FilterType `json:"qType,omitempty"`
	WherePredicate string     `json:"qWherePredicate,omitempty"`
}

type FilterType string

func (t FilterType) String() string {
	return string(t)
}

func (t FilterType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type FolderItem struct {
	// Name of the folder item.
	Name string `json:"qName,omitempty"`
	// Type of the folder item.
	//
	// One of:
	//
	// • FOLDER or FOLDER_ITEM_FOLDER
	//
	// • FILE or FOLDER_ITEM_FILE
	//
	// • OTHER or FOLDER_ITEM_OTHER
	Type FolderItemType `json:"qType,omitempty"`
}

type FolderItemType string

func (t FolderItemType) String() string {
	return string(t)
}

func (t FolderItemType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type Function struct {
	// Name of the script function.
	Name string `json:"qName,omitempty"`
	// Group of the script function.
	//
	// One of:
	//
	// • ALL or FUNC_GROUP_ALL
	//
	// • U or FUNC_GROUP_UNKNOWN
	//
	// • NONE or FUNC_GROUP_NONE
	//
	// • AGGR or FUNC_GROUP_AGGR
	//
	// • NUM or FUNC_GROUP_NUMERIC
	//
	// • RNG or FUNC_GROUP_RANGE
	//
	// • EXP or FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC
	//
	// • TRIG or FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC
	//
	// • FIN or FUNC_GROUP_FINANCIAL
	//
	// • MATH or FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE
	//
	// • COUNT or FUNC_GROUP_COUNTER
	//
	// • STR or FUNC_GROUP_STRING
	//
	// • MAPP or FUNC_GROUP_MAPPING
	//
	// • RCRD or FUNC_GROUP_INTER_RECORD
	//
	// • CND or FUNC_GROUP_CONDITIONAL
	//
	// • LOG or FUNC_GROUP_LOGICAL
	//
	// • NULL or FUNC_GROUP_NULL
	//
	// • SYS or FUNC_GROUP_SYSTEM
	//
	// • FILE or FUNC_GROUP_FILE
	//
	// • TBL or FUNC_GROUP_TABLE
	//
	// • DATE or FUNC_GROUP_DATE_AND_TIME
	//
	// • NUMI or FUNC_GROUP_NUMBER_INTERPRET
	//
	// • FRMT or FUNC_GROUP_FORMATTING
	//
	// • CLR or FUNC_GROUP_COLOR
	//
	// • RNK or FUNC_GROUP_RANKING
	//
	// • GEO or FUNC_GROUP_GEO
	//
	// • EXT or FUNC_GROUP_EXTERNAL
	//
	// • PROB or FUNC_GROUP_PROBABILITY
	//
	// • ARRAY or FUNC_GROUP_ARRAY
	//
	// • LEG or FUNC_GROUP_LEGACY
	Group FunctionGroup `json:"qGroup,omitempty"`
	// Signature of the script function.
	// Gives general information about the function.
	Signature string `json:"qSignature,omitempty"`
}

type FunctionGroup string

func (t FunctionGroup) String() string {
	return string(t)
}

func (t FunctionGroup) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type GenericBookmarkEntry struct {
	// Information about the properties of the bookmark.
	Properties *GenericBookmarkProperties `json:"qProperties,omitempty"`
	// Information about the bookmark.
	Bookmark *NxBookmark `json:"qBookmark,omitempty"`
}

// Is the layout for GenericBookmarkProperties.
type GenericBookmarkLayout struct {
	// Information about the object.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information on publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Information about the bookmark.
	Bookmark *NxBookmark `json:"qBookmark,omitempty"`
	// Information about the field selections associated with the bookmark.
	FieldInfos []*LayoutFieldInfo `json:"qFieldInfos,omitempty"`
}

type GenericBookmarkProperties struct {
	// Information about the bookmark.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Definition of the dynamic properties.
	MetaDef *NxMetaDef `json:"qMetaDef,omitempty"`
}

type GenericConnectMachine string

func (t GenericConnectMachine) String() string {
	return string(t)
}

func (t GenericConnectMachine) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type GenericDimensionInfo struct {
	// Length of the longest value in the field.
	ApprMaxGlyphCount int `json:"qApprMaxGlyphCount,omitempty"`
	// Number of distinct field values
	Cardinal int `json:"qCardinal,omitempty"`
	// Gives information on a field. For example, it can return the type of the field.
	// Examples: key, text, ASCII
	Tags []string `json:"qTags,omitempty"`
	// If set to true, it means that the field is a semantic.
	IsSemantic bool `json:"qIsSemantic,omitempty"`
	// If set to true a logical AND (instead of a logical OR) is used when making selections in a field.
	// The default value is false.
	AndMode bool `json:"qAndMode,omitempty"`
}

// Is the layout for GenericDimensionProperties.
type GenericDimensionLayout struct {
	// Identifier and type of the dimension.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information about publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Name and label of the dimension, information about grouping.
	Dim *NxLibraryDimension `json:"qDim,omitempty"`
	// Cardinal and tags related to the dimension.
	// Length of the longest value in the field.
	DimInfos []*GenericDimensionInfo `json:"qDimInfos,omitempty"`
}

type GenericDimensionProperties struct {
	// Identifier and type of the dimension.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Definition of the dimension.
	// This parameter is mandatory.
	Dim *NxLibraryDimensionDef `json:"qDim,omitempty"`
	// Definition of the dynamic properties.
	MetaDef *NxMetaDef `json:"qMetaDef,omitempty"`
}

// Is the layout for GenericMeasureProperties.
type GenericMeasureLayout struct {
	// Information about the object.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information about the measure.
	Measure *NxLibraryMeasure `json:"qMeasure,omitempty"`
	// Information on publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
}

type GenericMeasureProperties struct {
	// Information about the measure.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Definition of the measure.
	// This parameter is mandatory.
	Measure *NxLibraryMeasureDef `json:"qMeasure,omitempty"`
	// Definition of the dynamic properties.
	MetaDef *NxMetaDef `json:"qMetaDef,omitempty"`
}

type GenericObjectEntry struct {
	// Information about the generic object properties.
	Property *GenericObjectProperties `json:"qProperty,omitempty"`
	// Information about the children of the generic object.
	Children []*GenericObjectEntry `json:"qChildren,omitempty"`
	// Reference to a bookmark/snapshot that is embedded in the generic object.
	EmbeddedSnapshotRef *GenericBookmarkEntry `json:"qEmbeddedSnapshotRef,omitempty"`
}

// Is the layout for GenericObjectProperties.
type GenericObjectLayout struct {
	// Identifier and type of the generic object.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information about publishing and permissions.
	// This parameter is optional.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Should be set to create an object that is linked to another object. Enter the identifier of the object you want to link to.
	// If you do not want to link your object, set this parameter to an empty string.
	ExtendsId string `json:"qExtendsId,omitempty"`
	// Is set to true if the generic object contains some properties that are not persistent (a soft patch was applied).
	HasSoftPatches bool `json:"qHasSoftPatches,omitempty"`
	// Gives information on the error.
	// This parameter is optional.
	Error *NxLayoutErrors `json:"qError,omitempty"`
	// Information about the selections.
	SelectionInfo *NxSelectionInfo `json:"qSelectionInfo,omitempty"`
	// Name of the alternate state.
	// Default is current selections $ .
	StateName          string              `json:"qStateName,omitempty"`
	AppObjectList      *AppObjectList      `json:"qAppObjectList,omitempty"`
	BookmarkList       *BookmarkList       `json:"qBookmarkList,omitempty"`
	ChildList          *ChildList          `json:"qChildList,omitempty"`
	DimensionList      *DimensionList      `json:"qDimensionList,omitempty"`
	EmbeddedSnapshot   *EmbeddedSnapshot   `json:"qEmbeddedSnapshot,omitempty"`
	ExtensionList      *ExtensionList      `json:"qExtensionList,omitempty"`
	FieldList          *FieldList          `json:"qFieldList,omitempty"`
	HyperCube          *HyperCube          `json:"qHyperCube,omitempty"`
	ListObject         *ListObject         `json:"qListObject,omitempty"`
	MeasureList        *MeasureList        `json:"qMeasureList,omitempty"`
	MediaList          *MediaList          `json:"qMediaList,omitempty"`
	NxLibraryDimension *NxLibraryDimension `json:"qNxLibraryDimension,omitempty"`
	NxLibraryMeasure   *NxLibraryMeasure   `json:"qNxLibraryMeasure,omitempty"`
	SelectionObject    *SelectionObject    `json:"qSelectionObject,omitempty"`
	StaticContentUrl   *StaticContentUrl   `json:"qStaticContentUrl,omitempty"`
	TreeData           *TreeData           `json:"qTreeData,omitempty"`
	UndoInfo           *UndoInfo           `json:"qUndoInfo,omitempty"`
	VariableList       *VariableList       `json:"qVariableList,omitempty"`
}

type GenericObjectProperties struct {
	// Identifier and type of the object.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Should be set to create an object that is linked to another object. Enter the identifier of the linking object (i.e the object you want to link to).
	// If you do not want to link your object, set this parameter to an empty string.
	ExtendsId string `json:"qExtendsId,omitempty"`
	// Definition of the dynamic properties.
	MetaDef *NxMetaDef `json:"qMetaDef,omitempty"`
	// Name of the alternate state.
	// Default is current selections $ .
	StateName             string                 `json:"qStateName,omitempty"`
	AppObjectListDef      *AppObjectListDef      `json:"qAppObjectListDef,omitempty"`
	BookmarkListDef       *BookmarkListDef       `json:"qBookmarkListDef,omitempty"`
	ChildListDef          *ChildListDef          `json:"qChildListDef,omitempty"`
	DimensionListDef      *DimensionListDef      `json:"qDimensionListDef,omitempty"`
	EmbeddedSnapshotDef   *EmbeddedSnapshotDef   `json:"qEmbeddedSnapshotDef,omitempty"`
	ExtensionListDef      *ExtensionListDef      `json:"qExtensionListDef,omitempty"`
	FieldListDef          *FieldListDef          `json:"qFieldListDef,omitempty"`
	HyperCubeDef          *HyperCubeDef          `json:"qHyperCubeDef,omitempty"`
	LayoutExclude         *LayoutExclude         `json:"qLayoutExclude,omitempty"`
	ListObjectDef         *ListObjectDef         `json:"qListObjectDef,omitempty"`
	MeasureListDef        *MeasureListDef        `json:"qMeasureListDef,omitempty"`
	MediaListDef          *MediaListDef          `json:"qMediaListDef,omitempty"`
	NxLibraryDimensionDef *NxLibraryDimensionDef `json:"qNxLibraryDimensionDef,omitempty"`
	NxLibraryMeasureDef   *NxLibraryMeasureDef   `json:"qNxLibraryMeasureDef,omitempty"`
	SelectionObjectDef    *SelectionObjectDef    `json:"qSelectionObjectDef,omitempty"`
	StaticContentUrlDef   *StaticContentUrlDef   `json:"qStaticContentUrlDef,omitempty"`
	StringExpression      *StringExpression      `json:"qStringExpression,omitempty"`
	TreeDataDef           *TreeDataDef           `json:"qTreeDataDef,omitempty"`
	UndoInfoDef           *UndoInfoDef           `json:"qUndoInfoDef,omitempty"`
	ValueExpression       *ValueExpression       `json:"qValueExpression,omitempty"`
	VariableListDef       *VariableListDef       `json:"qVariableListDef,omitempty"`
}

// Is the layout for GenericVariableProperties.
type GenericVariableLayout struct {
	// Identifier and type of the object.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information about publishing and permissions.
	// This parameter is optional.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Some text.
	Text string `json:"qText,omitempty"`
	// A value.
	Num Float64 `json:"qNum,omitempty"`
	// If set to true, it means that the variable was defined via script.
	IsScriptCreated bool `json:"qIsScriptCreated,omitempty"`
}

type GenericVariableProperties struct {
	// Identifier and type of the object.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Meta data.
	MetaDef *NxMetaDef `json:"qMetaDef,omitempty"`
	// Name of the variable.
	// The name must be unique.
	// This parameter is mandatory.
	Name string `json:"qName,omitempty"`
	// Comment related to the variable.
	// This parameter is optional.
	Comment string `json:"qComment,omitempty"`
	// Defines the format of the value.
	// This parameter is optional.
	NumberPresentation *FieldAttributes `json:"qNumberPresentation,omitempty"`
	// Set this property to true to update the variable when applying a bookmark. The variable value will be persisted in the bookmark.
	// The value of a variable can affect the state of the selections.
	// Script variables cannot be persisted in the bookmark.
	// The default value is false.
	IncludeInBookmark bool `json:"qIncludeInBookmark,omitempty"`
	// Definition of the variable.
	Definition string `json:"qDefinition,omitempty"`
}

// Renders the properties of a hypercube. Is the layout for HyperCubeDef.
// For more information about the definition of a hypercube, see Generic object.
// What is returned in HyperCube depends on the type of the hypercube (straight, pivot or stacked table, or tree) and on the method called (GetLayout, GetHyperCubeData, GetHyperCubePivotData, GetHyperCubeStackData, GetHyperCubeTreeData).
type HyperCube struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// Defines the size of the hypercube.
	Size *Size `json:"qSize,omitempty"`
	// This parameter is optional and is displayed in case of error.
	Error *NxValidationError `json:"qError,omitempty"`
	// Information on the dimension.
	DimensionInfo []*NxDimensionInfo `json:"qDimensionInfo,omitempty"`
	// Information on the measure.
	MeasureInfo []*NxMeasureInfo `json:"qMeasureInfo,omitempty"`
	// Sort order of the columns in the hypercube.
	// Column numbers are separated by a comma.
	// Example: [1,0,2] means that the first column to be sorted was the column 1, followed by the column 0 and the column 2.
	EffectiveInterColumnSortOrder []int `json:"qEffectiveInterColumnSortOrder,omitempty"`
	// Aggregate for measures of all values in the field.
	// The result value depends on the qAggrFunc defined in HyperCubeDef.
	GrandTotalRow []*NxCell `json:"qGrandTotalRow,omitempty"`
	// Set of data.
	// Is empty if nothing has been defined in qInitialDataFetch in HyperCubeDef.
	DataPages []*NxDataPage `json:"qDataPages,omitempty"`
	// Set of data for pivot tables.
	// Is empty if nothing has been defined in qInitialDataFetch in HyperCubeDef.
	PivotDataPages []*NxPivotPage `json:"qPivotDataPages,omitempty"`
	// Set of data for stacked tables.
	// Is empty if nothing has been defined in qInitialDataFetch in HyperCubeDef.
	StackedDataPages []*NxStackPage `json:"qStackedDataPages,omitempty"`
	// Information about the mode of the visualization.
	//
	// One of:
	//
	// • S or DATA_MODE_STRAIGHT
	//
	// • P or DATA_MODE_PIVOT
	//
	// • K or DATA_MODE_PIVOT_STACK
	//
	// • T or DATA_MODE_TREE
	Mode NxHypercubeMode `json:"qMode,omitempty"`
	// Number of left dimensions.
	// Default value is -1.
	// The index related to each left dimension depends on the position of the pseudo dimension (if any).
	// For example, a pivot table with:
	//
	// • Four dimensions in the following order: Country, City, Product and Category
	//
	// • One pseudo dimension in position 1
	//
	// • Three left dimensions.
	//
	// implies that:
	//
	// • The index 0 corresponds to the left dimension Country.
	//
	// • The index 1 corresponds to the pseudo dimension.
	//
	// • The index 2 corresponds to the left dimension City.
	//
	// • Product and Category are top dimensions.
	//
	// Another example:
	//
	// • Four dimensions in the following order: Country, City, Product and Category.
	//
	// • One pseudo dimension in position -1.
	//
	// • Three left dimensions.
	//
	// implies that:
	//
	// • The index -1 corresponds to the pseudo dimension; the pseudo dimension is the most to the right.
	//
	// • The index 0 corresponds to the left dimension Country.
	//
	// • The index 1 corresponds to the left dimension City.
	//
	// • The index 2 corresponds to the left dimension Product.
	//
	// • Category is a top dimension.
	NoOfLeftDims int `json:"qNoOfLeftDims,omitempty"`
	// Is used for pivot tables only.
	// If set to true, the formatting of the results is slightly different.
	// This property is optional.
	IndentMode bool `json:"qIndentMode,omitempty"`
	// Is used for pivot tables only.
	// Position of the last expended cell.
	// This property is optional.
	LastExpandedPos *NxCellPosition `json:"qLastExpandedPos,omitempty"`
	// True if other row exists.
	HasOtherValues bool `json:"qHasOtherValues,omitempty"`
	// Title of the hypercube, for example the title of a chart.
	Title string `json:"qTitle,omitempty"`
	// The total number of nodes on each dimension (only applicable when qMode = T ).
	TreeNodesOnDim []int `json:"qTreeNodesOnDim,omitempty"`
	// The message displayed if calculation condition is not fulfilled.
	CalcCondMsg string `json:"qCalcCondMsg,omitempty"`
	// The order of the columns.
	ColumnOrder []int `json:"qColumnOrder,omitempty"`
}

// Defines the properties of a hypercube.
// For more information about the definition of a hypercube, see Generic object.
type HyperCubeDef struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// Array of dimensions.
	Dimensions []*NxDimension `json:"qDimensions,omitempty"`
	// Array of measures.
	Measures []*NxMeasure `json:"qMeasures,omitempty"`
	// Defines the sort order of the columns in the hypercube.
	// Column numbers are separated by a comma.
	// Example: [1,0,2] means that the first column to be sorted should be the column 1, followed by the column 0 and the column 2.
	// The default sort order is the order in which the dimensions and measures have been defined in the hypercube. By default, the pseudo-dimension (if any) is the most to the right in the array.
	// The index of the pseudo-dimension (if any) is -1.
	// Pseudo dimensions only apply for pivot tables with more than one measure.
	// A pseudo dimension groups together the measures defined in a pivot table. You can neither collapse/expand a pseudo dimension nor make any selections in it.
	// Stacked pivot tables can only contain one measure.
	InterColumnSortOrder []int `json:"qInterColumnSortOrder,omitempty"`
	// Removes zero values.
	SuppressZero bool `json:"qSuppressZero,omitempty"`
	// Removes missing values.
	SuppressMissing bool `json:"qSuppressMissing,omitempty"`
	// Initial data set.
	InitialDataFetch []*NxPage `json:"qInitialDataFetch,omitempty"`
	// One of:
	//
	// • N or DATA_REDUCTION_NONE
	//
	// • D1 or DATA_REDUCTION_ONEDIM
	//
	// • S or DATA_REDUCTION_SCATTERED
	//
	// • C or DATA_REDUCTION_CLUSTERED
	//
	// • ST or DATA_REDUCTION_STACKED
	ReductionMode NxDataReductionMode `json:"qReductionMode,omitempty"`
	// Defines the way the data are handled internally by the engine.
	// Default value is DATAMODE_STRAIGHT_ .
	// A pivot table can contain several dimensions and measures whereas a stacked pivot table can contain several dimensions but only one measure.
	//
	// One of:
	//
	// • S or DATA_MODE_STRAIGHT
	//
	// • P or DATA_MODE_PIVOT
	//
	// • K or DATA_MODE_PIVOT_STACK
	//
	// • T or DATA_MODE_TREE
	Mode NxHypercubeMode `json:"qMode,omitempty"`
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	PseudoDimPos *int `json:"qPseudoDimPos,omitempty"`
	// Number of left dimensions.
	// Default value is -1. In that case, all dimensions are left dimensions.
	// Hidden dimensions (e.g. due to unfulfilled calc condition on dimension level) is still counted in this context.
	// The index related to each left dimension depends on the position of the pseudo dimension (if any).
	// For example, a pivot table with:
	//
	// • Four dimensions in the following order: Country, City, Product and Category.
	//
	// • One pseudo dimension in position 1 (the position is defined in qInterColumnSortOrder )
	// _qInterColumnSortOrder_ is (0,-1,1,2,3).
	//
	// • Three left dimensions ( qNoOfLeftDims is set to 3).
	//
	// implies that:
	//
	// • The index 0 corresponds to the left dimension Country.
	//
	// • The index 1 corresponds to the pseudo dimension.
	//
	// • The index 2 corresponds to the left dimension City.
	//
	// • Product and Category are top dimensions.
	//
	// Another example:
	//
	// • Four dimensions in the following order: Country, City, Product and Category.
	//
	// • Three left dimensions ( qNoOfLeftDims is set to 3).
	//
	// • One pseudo dimension.
	//
	// • The property qInterColumnSortOrder is left empty.
	//
	// Implies that:
	//
	// • The index 0 corresponds to the left dimension Country.
	//
	// • The index 1 corresponds to the left dimension City.
	//
	// • The index 2 corresponds to the left dimension Product.
	//
	// • Category is a top dimension.
	//
	// • The pseudo dimension is a top dimension.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	NoOfLeftDims *int `json:"qNoOfLeftDims,omitempty"`
	// If this property is set to true, the cells are always expanded. It implies that it is not possible to collapse any cells.
	// The default value is false.
	AlwaysFullyExpanded bool `json:"qAlwaysFullyExpanded,omitempty"`
	// Maximum number of cells for an initial data fetch (set in qInitialDataFetch ) when in stacked mode ( qMode is K).
	// The default value is 5000.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	MaxStackedCells *int `json:"qMaxStackedCells,omitempty"`
	// If this property is set to true, the missing symbols (if any) are replaced by 0 if the value is a numeric and by an empty string if the value is a string.
	// The default value is false.
	PopulateMissing bool `json:"qPopulateMissing,omitempty"`
	// If set to true, the total (if any) is shown on the first row.
	// The default value is false.
	ShowTotalsAbove bool `json:"qShowTotalsAbove,omitempty"`
	// This property applies for pivot tables and allows to change the layout of the table. An indentation is added to the beginning of each row.
	// The default value is false.
	IndentMode bool `json:"qIndentMode,omitempty"`
	// Specifies a calculation condition, which must be fulfilled for the hypercube to be (re)calculated.
	// As long as the condition is not met, the engine does not perform a new calculation.
	// This property is optional. By default, there is no calculation condition.
	CalcCond *ValueExpr `json:"qCalcCond,omitempty"`
	// To enable the sorting by ascending or descending order in the values of a measure.
	// This property applies to pivot tables and stacked pivot tables.
	// In the case of a pivot table, the measure or pseudo dimension should be defined as a top dimension. The sorting is restricted to the values of the first measure in a pivot table.
	SortbyYValue int `json:"qSortbyYValue,omitempty"`
	// Title of the hypercube, for example the title of a chart.
	Title *StringExpr `json:"qTitle,omitempty"`
	// Specifies a calculation condition object.
	// If CalcCondition.Cond is not fulfilled, the hypercube is not calculated and CalcCondition.Msg is evaluated.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCondition *NxCalcCond `json:"qCalcCondition,omitempty"`
	// The order of the columns.
	ColumnOrder []int `json:"qColumnOrder,omitempty"`
}

type InteractDef struct {
	// Interaction type.
	//
	// One of:
	//
	// • IT_MSGBOX
	//
	// • IT_SCRIPTLINE
	//
	// • IT_BREAK
	//
	// • IT_INPUT
	//
	// • IT_END
	//
	// • IT_PASSWD
	//
	// • IT_USERNAME
	Type InteractType `json:"qType,omitempty"`
	// Title used in the message box dialog.
	// This property is relevant if qType is *IT_MSGBOX*.
	Title string `json:"qTitle,omitempty"`
	// Message used in the message box dialog.
	// This property is relevant if qType is *IT_MSGBOX*.
	Msg string `json:"qMsg,omitempty"`
	// Buttons displayed in the message box dialog.
	// This property is relevant if qType is *IT_MSGBOX*.
	// One of:
	//
	// • 0 means that the qButtons property is not relevant.
	//
	// • 17 means that the message box contains the OK and Cancel buttons or the stop -sign icon.
	Buttons int `json:"qButtons,omitempty"`
	// Next script statement to be executed.
	// This property is used if the type of interaction is *IT_SCRIPTLINE*.
	Line string `json:"qLine,omitempty"`
	// First line number of the previously executed statement.
	// This property is used if the type of interaction is *IT_SCRIPTLINE*.
	OldLineNr int `json:"qOldLineNr,omitempty"`
	// First line number of the next statement to be executed.
	// This property is used if the type of interaction is *IT_SCRIPTLINE*.
	NewLineNr int `json:"qNewLineNr,omitempty"`
	// Path specified by the Include script variable.
	// This property is used if the type of interaction is *IT_SCRIPTLINE*.
	// Example of an Include variable:
	// _$(Include=lib:\\\MyDataFiles\abc.txt);_
	Path string `json:"qPath,omitempty"`
	// This property is set to true if the returned statement is an hidden script statement.
	Hidden bool `json:"qHidden,omitempty"`
	// Not relevant for describing the requested user interaction.
	Result int `json:"qResult,omitempty"`
	// Is not used in Qlik Sense.
	Input string `json:"qInput,omitempty"`
}

type InteractType string

func (t InteractType) String() string {
	return string(t)
}

func (t InteractType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type KeyType string

func (t KeyType) String() string {
	return string(t)
}

func (t KeyType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Contains JSON to be excluded from validation.
type LayoutExclude struct {
}

// Meta data about the selection in a field.
type LayoutFieldInfo struct {
	// The name of the field.
	FieldName string `json:"qFieldName,omitempty"`
	// Number of selected values in the field.
	ValuesCount int `json:"qValuesCount,omitempty"`
	// Number of excluded values in the field.
	ExcludedValuesCount int `json:"qExcludedValuesCount,omitempty"`
}

type LineageInfo struct {
	// A string indicating the origin of the data:
	//
	// • [filename]: the data comes from a local file.
	//
	// • INLINE: the data is entered inline in the load script.
	//
	// • RESIDENT: the data comes from a resident table. The table name is listed.
	//
	// • AUTOGENERATE: the data is generated from the load script (no external table of data source).
	//
	// • Provider: the data comes from a data connection. The connector source name is listed.
	//
	// • [webfile]: the data comes from a web-based file.
	//
	// • STORE: path to QVD or TXT file where data is stored.
	//
	// • EXTENSION: the data comes from a Server Side Extension (SSE).
	Discriminator string `json:"qDiscriminator,omitempty"`
	// The LOAD and SELECT script statements from the data load script.
	Statement string `json:"qStatement,omitempty"`
}

// Renders the properties of a list object. Is the layout for ListObjectDef.
// For more information about the definition of a list object, see Generic object.
// ListObject is used by the GetLayout Method to display the properties of a list object.
type ListObject struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// Defines the size of a list object.
	Size *Size `json:"qSize,omitempty"`
	// This parameter is optional and is displayed in case of error.
	Error *NxValidationError `json:"qError,omitempty"`
	// Information about the dimension.
	DimensionInfo *NxDimensionInfo `json:"qDimensionInfo,omitempty"`
	// Lists the expressions in the list object.
	Expressions []*NxListObjectExpression `json:"qExpressions,omitempty"`
	// Set of data.
	// Is empty if nothing has been defined in qInitialDataFetch in ListObjectDef.
	DataPages []*NxDataPage `json:"qDataPages,omitempty"`
}

// Defines the properties of a list object.
// For more information about the definition of a list object, see Generic object.
type ListObjectDef struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
	// Refers to a dimension stored in the list object.
	Def *NxInlineDimensionDef `json:"qDef,omitempty"`
	// Defines the sorting by state.
	AutoSortByState *NxAutoSortByStateDef `json:"qAutoSortByState,omitempty"`
	// Defines the frequency mode. The frequency mode is used to calculate the frequency of a value in a list object.
	// Default is NXFREQUENCY_NONE_ .
	// This parameter is optional.
	//
	// One of:
	//
	// • N or NX_FREQUENCY_NONE
	//
	// • V or NX_FREQUENCY_VALUE
	//
	// • P or NX_FREQUENCY_PERCENT
	//
	// • R or NX_FREQUENCY_RELATIVE
	FrequencyMode NxFrequencyMode `json:"qFrequencyMode,omitempty"`
	// If set to true, alternative values are allowed in qData .
	// If set to false, no alternative values are displayed in qData . Values are excluded instead.
	// The default value is false.
	// Note that on the contrary, the qStateCounts parameter counts the excluded values as alternative values.
	// This parameter is optional.
	ShowAlternatives bool `json:"qShowAlternatives,omitempty"`
	// Fetches an initial data set.
	InitialDataFetch []*NxPage `json:"qInitialDataFetch,omitempty"`
	// Lists the expressions in the list object.
	// This parameter is optional.
	Expressions []*NxListObjectExpressionDef `json:"qExpressions,omitempty"`
}

type LocaleInfo struct {
	// Decimal separator.
	DecimalSep string `json:"qDecimalSep,omitempty"`
	// Thousand separator.
	ThousandSep string `json:"qThousandSep,omitempty"`
	// List separator.
	ListSep string `json:"qListSep,omitempty"`
	// Money decimal separator.
	MoneyDecimalSep string `json:"qMoneyDecimalSep,omitempty"`
	// Money thousand separator.
	MoneyThousandSep string `json:"qMoneyThousandSep,omitempty"`
	// Current year.
	CurrentYear int `json:"qCurrentYear,omitempty"`
	// Money format.
	// Example:
	//
	// .
	//
	// 0,00 kr;-#.##0,00 kr:
	//
	// :
	MoneyFmt string `json:"qMoneyFmt,omitempty"`
	// Time format.
	// Example: hh:mm:ss
	TimeFmt string `json:"qTimeFmt,omitempty"`
	// Date format.
	// Example: YYYY-MM-DD
	DateFmt string `json:"qDateFmt,omitempty"`
	// Time stamp format.
	// Example: YYYY-MM-DD hh:mm:ss[.fff]
	TimestampFmt string `json:"qTimestampFmt,omitempty"`
	// Information about the calendar.
	CalendarStrings *CalendarStrings `json:"qCalendarStrings,omitempty"`
	// First day of the week, starting from 0.
	// According to ISO 8601, Monday is the first day of the week.
	//
	// • 0 = Monday
	//
	// • 1 = Tuesday
	//
	// • ...
	//
	// • 6 = Sunday
	//
	// If this property has not been set in a script, the returned value comes from the Windows operating system.
	FirstWeekDay int `json:"qFirstWeekDay,omitempty"`
	// Is set to true if broken weeks are allowed in a year.
	// According to ISO 8601, no broken weeks should be allowed.
	// This property is not shown if set to false.
	// If qBrokenWeeks is set to true, qReferenceDay is irrelevant.
	// If this property has not been set in a script, the returned value comes from the Windows operating system.
	BrokenWeeks bool `json:"qBrokenWeeks,omitempty"`
	// Day in the year that is always in week 1.
	// According to ISO 8601, January 4th should always be part of the first week of the year ( qReferenceDay =4).
	// Recommended values are in the range 1 and 7.
	// If this property has not been set in a script, the returned value comes from the Windows operating system.
	// This property is not relevant if there are broken weeks in the year.
	ReferenceDay int `json:"qReferenceDay,omitempty"`
	// First month of the year, starting from 1.
	// According to ISO 8601, January is the first month of the year.
	//
	// • 1 = January
	//
	// • 2 = February
	//
	// • 12 = January
	//
	// If this property has not been set in a script, the returned value comes from the Windows operating system.
	FirstMonthOfYear int `json:"qFirstMonthOfYear,omitempty"`
	// Locale name (following language tagging convention RFC 4646):
	// _< language>-<REGION>_
	// Where:
	//
	// • language is a lowercase ISO  639 language code
	//
	// • REGION specifies an uppercase ISO 3166 country code.
	//
	// If this property has not been set in a script, the returned value comes from the Windows operating system.
	Collation string `json:"qCollation,omitempty"`
	// Number format.
	// Example: 3:k;6:M;9:G;12:T;15:P;18:E;21:Z;24:Y;-3:m;-6:μ;-9:n;-12:p;-15:f;-18:a;-21:z;-24:y
	NumericalAbbreviation string `json:"qNumericalAbbreviation,omitempty"`
}

type LogOnType string

func (t LogOnType) String() string {
	return string(t)
}

func (t LogOnType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Lists the measures. Is the layout for MeasureListDef.
type MeasureList struct {
	// Information about the list of measures.
	Items []*NxContainerEntry `json:"qItems,omitempty"`
}

// Defines the list of measures.
type MeasureListDef struct {
	// Type of the list.
	Type string `json:"qType,omitempty"`
	// Data
	Data json.RawMessage `json:"qData,omitempty"`
}

// Lists the media files. Is the layout for MediaListDef.
// This struct is deprecated.
type MediaList struct {
	// Information about the list of media files.
	// In Qlik Sense Desktop, the media files are retrieved from:
	// _%userprofile%\Documents\Qlik\Sense\Content\Default_
	// In Qlik Sense Enterprise, the media files are retrieved from:
	// <installation_directory>\Qlik\Sense\Repository\Content\Default
	// The default installation directory is ProgramData .
	Items []*MediaListItem `json:"qItems,omitempty"`
}

// Defines the list of media files.
// This struct is deprecated.
//
// Properties:
//
// "qMediaListDef": {}
// _qMediaListDef_ has an empty structure. No properties need to be set.
type MediaListDef struct {
}

// In addition, this structure can return dynamic properties.
type MediaListItem struct {
	// Relative path to the media file. The URL is static.
	// Media files located:
	//
	// • in the /content/default/ folder are outside the qvf file.
	//
	// • in the /media/ folder are embedded in the qvf file.
	UrlDef string `json:"qUrlDef,omitempty"`
	// Relative path to the media file.
	// Media files located:
	//
	// • in the /content/default/ folder are outside the qvf file.
	//
	// • in the /media/ folder are embedded in the qvf file.
	Url string `json:"qUrl,omitempty"`
}

// Qlik Sense Desktop:
//
// In Qlik Sense Desktop, this structure can contain dynamic properties.
//
// Qlik Sense Enterprise:
//
// In Qlik Sense Enterprise, only a few dynamic properties at the app level are persisted.
// The persisted dynamic properties are the following:
//
// • modifiedDate
//
// • published
//
// • publishTime
//
// • privileges
//
// • description
//
// • dynamicColor
type NxAppLayout struct {
	// Title of the app.
	Title string `json:"qTitle,omitempty"`
	// In Qlik Sense Enterprise, this property corresponds to the app identifier (GUID).
	// In Qlik Sense Desktop, this property corresponds to the full path of the app.
	FileName string `json:"qFileName,omitempty"`
	// Date and time of the last reload of the app in ISO format.
	LastReloadTime string `json:"qLastReloadTime,omitempty"`
	// Is set to true if the app has been updated since the last save.
	Modified bool `json:"qModified,omitempty"`
	// Is set to true if a script is defined in the app.
	HasScript bool `json:"qHasScript,omitempty"`
	// Array of alternate states.
	StateNames []string `json:"qStateNames,omitempty"`
	// Information on publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Information about the locale.
	LocaleInfo *LocaleInfo `json:"qLocaleInfo,omitempty"`
	// Is set to true if the app contains data following a script reload.
	HasData bool `json:"qHasData,omitempty"`
	// If set to true, it means that the app is read-only.
	ReadOnly bool `json:"qReadOnly,omitempty"`
	// If set to true, it means that the app was opened without loading its data.
	IsOpenedWithoutData bool `json:"qIsOpenedWithoutData,omitempty"`
	// App thumbnail.
	Thumbnail *StaticContentUrl `json:"qThumbnail,omitempty"`
}

// Qlik Sense Desktop:
//
// In Qlik Sense Desktop, this structure can contain dynamic properties.
//
// Qlik Sense Enterprise:
//
// In Qlik Sense Enterprise, only a few dynamic properties at the app level are persisted.
// The persisted dynamic properties are the following:
//
// • modifiedDate
//
// • published
//
// • publishTime
//
// • privileges
//
// • description
//
// • dynamicColor
type NxAppProperties struct {
	// App title.
	Title string `json:"qTitle,omitempty"`
	// Last reload time of the app.
	LastReloadTime string `json:"qLastReloadTime,omitempty"`
	// Internal property reserved for app migration.
	// Patch version of the app.
	// Do not update.
	MigrationHash string `json:"qMigrationHash,omitempty"`
	// Internal property reserved for app migration.
	// The app is saved in this version of the product.
	// Do not update.
	SavedInProductVersion string `json:"qSavedInProductVersion,omitempty"`
	// App thumbnail.
	Thumbnail *StaticContentUrlDef `json:"qThumbnail,omitempty"`
	// If true the app has section access configured.
	HasSectionAccess bool `json:"qHasSectionAccess,omitempty"`
}

// Layout for NxAttrDimDef.
type NxAttrDimDef struct {
	// Expression or field name.
	Def string `json:"qDef,omitempty"`
	// LibraryId for dimension.
	LibraryId string `json:"qLibraryId,omitempty"`
	// Sorting.
	SortBy *SortCriteria `json:"qSortBy,omitempty"`
	// If set to true, this attribute will not affect the number of rows in the cube.
	Attribute bool `json:"qAttribute,omitempty"`
}

// Layout for NxAttrDimDef.
type NxAttrDimInfo struct {
	// Cardinality of the attribute expression.
	Cardinal int `json:"qCardinal,omitempty"`
	// Number of rows.
	Size *Size `json:"qSize,omitempty"`
	// The title for the attribute dimension.
	FallbackTitle string `json:"qFallbackTitle,omitempty"`
	// The Locked value of the dimension.
	Locked bool `json:"qLocked,omitempty"`
	// Validation error.
	Error *NxValidationError `json:"qError,omitempty"`
	// True if this is a calculated dimension.
	IsCalculated bool `json:"qIsCalculated,omitempty"`
}

type NxAttrExprDef struct {
	// Definition of the attribute expression.
	// Example: "Max(OrderID)"
	Expression string `json:"qExpression,omitempty"`
	// Definition of the attribute expression stored in the library.
	// Example: "MyGenericMeasure"
	LibraryId string `json:"qLibraryId,omitempty"`
	// If set to true, this measure will not affect the number of rows in the cube.
	Attribute bool `json:"qAttribute,omitempty"`
}

// Layout for NxAttrExprDef.
type NxAttrExprInfo struct {
	// Minimum value.
	Min Float64 `json:"qMin,omitempty"`
	// Maximum value.
	Max           Float64 `json:"qMax,omitempty"`
	FallbackTitle string  `json:"qFallbackTitle,omitempty"`
	// String version of the minimum Value.
	MinText string `json:"qMinText,omitempty"`
	// String version of the maximum Value.
	MaxText string `json:"qMaxText,omitempty"`
}

type NxAttributeDimValues struct {
	// List of values.
	Values []*NxSimpleDimValue `json:"qValues,omitempty"`
}

type NxAttributeExpressionValues struct {
	// List of attribute expressions values.
	Values []*NxSimpleValue `json:"qValues,omitempty"`
}

type NxAutoSortByStateDef struct {
	// This parameter applies to list objects.
	// If the number of selected values in the list object is greater than the value set in qDisplayNumberOfRows , the selected lines are promoted at the top of the list object.
	// If qDisplayNumberOfRows is set to a negative value or to 0, the sort by state is disabled.
	DisplayNumberOfRows int `json:"qDisplayNumberOfRows,omitempty"`
}

type NxAxisData struct {
	// List of axis data.
	Axis []*NxAxisTicks `json:"qAxis,omitempty"`
}

type NxAxisTicks struct {
	// Name of the derived definition.
	Name string `json:"qName,omitempty"`
	// List of tags.
	Tags []string `json:"qTags,omitempty"`
	// List of ticks.
	Ticks []*NxTickCell `json:"qTicks,omitempty"`
}

type NxBookmark struct {
	// List of selections for each state.
	StateData []*AlternateStateData `json:"qStateData,omitempty"`
	// Time when the bookmark was created.
	UtcModifyTime Float64 `json:"qUtcModifyTime,omitempty"`
	// List of the variables in the app at the time the bookmark was created.
	VariableItems []*BookmarkVariableItem `json:"qVariableItems,omitempty"`
}

type NxCalcCond struct {
	// Condition for calculating an hypercube, dimension or measure.
	Cond *ValueExpr `json:"qCond,omitempty"`
	// Evaluated if Cond is not fullfilled.
	Msg *StringExpr `json:"qMsg,omitempty"`
}

type NxCardinalities struct {
	// Number of distinct field values.
	Cardinal int `json:"qCardinal,omitempty"`
	// Number of distinct hypercube values.
	HypercubeCardinal int `json:"qHypercubeCardinal,omitempty"`
}

type NxCell struct {
	// Some text.
	// This parameter is optional.
	Text string `json:"qText,omitempty"`
	// A value.
	// This parameter is optional.
	Num Float64 `json:"qNum,omitempty"`
	// Rank number of the value, starting from 0.
	// If the element number is a negative number, it means that the returned value is not an element number.
	// You can get the following negative values:
	//
	// • -1: the cell is a Total cell. It shows a total.
	//
	// • -2: the cell is collapsed. Applies to pivot tables.
	//
	// • -3: the cell belongs to the group Others .
	//
	// • -4: the cell is empty. Applies to pivot tables.
	ElemNumber int `json:"qElemNumber,omitempty"`
	// State of the value.
	// The default state for a measure is L.
	//
	// One of:
	//
	// • L or LOCKED
	//
	// • S or SELECTED
	//
	// • O or OPTION
	//
	// • D or DESELECTED
	//
	// • A or ALTERNATIVE
	//
	// • X or EXCLUDED
	//
	// • XS or EXCL_SELECTED
	//
	// • XL or EXCL_LOCKED
	//
	// • NSTATES
	State StateEnumType `json:"qState,omitempty"`
	// Is set to true , if qText and qNum are empty.
	// This parameter is optional. The default value is false .
	IsEmpty bool `json:"qIsEmpty,omitempty"`
	// Is set to true if a total is displayed in the cell.
	// This parameter is optional. The default value is false .
	// Not applicable to list objects.
	IsTotalCell bool `json:"qIsTotalCell,omitempty"`
	// Is set to true if the cell belongs to the group Others .
	// Dimension values can be set as Others depending on what has been defined in OtherTotalSpecProp .
	// This parameter is optional. The default value is false .
	// Not applicable to list objects.
	IsOtherCell bool `json:"qIsOtherCell,omitempty"`
	// Frequency of the value.
	// This parameter is optional.
	Frequency string `json:"qFrequency,omitempty"`
	// Search hits.
	// The search hits are highlighted.
	// This parameter is optional.
	HighlightRanges *NxHighlightRanges `json:"qHighlightRanges,omitempty"`
	// Attribute expression values.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	// Attribute dimensions values.
	AttrDims *NxAttributeDimValues `json:"qAttrDims,omitempty"`
	// Is set to true if the value is Null.
	IsNull bool `json:"qIsNull,omitempty"`
}

type NxCellPosition struct {
	// Position of the cell on the x-axis.
	X int `json:"qx,omitempty"`
	// Position of the cell on the y-axis.
	Y int `json:"qy,omitempty"`
}

type NxCellRows []*NxCell

type NxContainerEntry struct {
	// Information about the object.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Information on publishing and permissions.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Set of data.
	Data json.RawMessage `json:"qData,omitempty"`
}

type NxContinuousDataOptions struct {
	// Start value.
	Start Float64 `json:"qStart,omitempty"`
	// End value.
	End Float64 `json:"qEnd,omitempty"`
	// Number of bins for binning.
	NbrPoints int `json:"qNbrPoints,omitempty"`
	// Maximum number of ticks.
	MaxNbrTicks int `json:"qMaxNbrTicks,omitempty"`
	// Maximum number of lines.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	MaxNumberLines *int `json:"qMaxNumberLines,omitempty"`
}

type NxContinuousRangeSelectInfo struct {
	// Range information.
	Range *Range `json:"qRange,omitempty"`
	// Dimension index.
	DimIx int `json:"qDimIx,omitempty"`
}

type NxCurrentSelectionItem struct {
	// Number of values in the field.
	Total int `json:"qTotal,omitempty"`
	// This parameter is displayed if its value is true.
	// Is set to true if the field is a numeric.
	// This parameter is optional.
	IsNum bool `json:"qIsNum,omitempty"`
	// Name of the field that is selected.
	Field string `json:"qField,omitempty"`
	// This parameter is displayed if its value is true.
	// Is set to true if the field is locked.
	// This parameter is optional.
	Locked bool `json:"qLocked,omitempty"`
	// This parameter is displayed if its value is true.
	// Property that is set to a field. Is set to true if the field cannot be unselected.
	// This parameter is optional.
	OneAndOnlyOne bool `json:"qOneAndOnlyOne,omitempty"`
	// Text that was used for the search. This parameter is filled when searching for a value and selecting it.
	// This parameter is optional.
	TextSearch string `json:"qTextSearch,omitempty"`
	// Number of values that are selected.
	SelectedCount int `json:"qSelectedCount,omitempty"`
	// Values that are selected.
	Selected string `json:"qSelected,omitempty"`
	// Information about the range of selected values.
	// Is empty if there is no range of selected values.
	RangeInfo []*RangeSelectInfo `json:"qRangeInfo,omitempty"`
	// Sort index of the field. Indexing starts from 0.
	SortIndex int `json:"qSortIndex,omitempty"`
	// Number of values in a particular state.
	StateCounts *NxStateCounts `json:"qStateCounts,omitempty"`
	// Information about the fields that are selected.
	SelectedFieldSelectionInfo []*NxFieldSelectionInfo `json:"qSelectedFieldSelectionInfo,omitempty"`
	// Information about the fields that are not selected.
	NotSelectedFieldSelectionInfo []*NxFieldSelectionInfo `json:"qNotSelectedFieldSelectionInfo,omitempty"`
	// Maximum values to show in the current selections.
	// The default value is 6.
	SelectionThreshold int `json:"qSelectionThreshold,omitempty"`
	// Label that, if defined, is displayed in current selections instead of the actual expression.
	ReadableName string `json:"qReadableName,omitempty"`
	// Optional parameter. Indicates if the selection is to be hidden in the Selections bar.
	// Is set to true if the current selection is hidden.
	IsHidden bool `json:"qIsHidden,omitempty"`
}

type NxDataAreaPage struct {
	// Position from the left.
	// Corresponds to the lowest possible value of the first measure (the measure on the x-axis).
	Left Float64 `json:"qLeft,omitempty"`
	// Position from the top.
	// Corresponds to the highest possible value of the second measure (the measure on the y-axis).
	Top Float64 `json:"qTop,omitempty"`
	// Width of the page.
	// Corresponds to the highest possible value of the first measure (the measure on the x-axis).
	Width Float64 `json:"qWidth,omitempty"`
	// Height of the page.
	// The difference between qTop and qHeight gives the lowest possible value of the second measure (the measure on the y-axis).
	Height Float64 `json:"qHeight,omitempty"`
}

type NxDataPage struct {
	// Array of data.
	Matrix []NxCellRows `json:"qMatrix,omitempty"`
	// Array of tails.
	// Is used for hypercube objects with multiple dimensions. It might happen that due to the window size some elements in a group cannot be displayed in the same page as the other elements of the group. Elements of a group of dimensions can be part of the previous or the next tail.
	// If there is no tail, the array is empty [ ] .
	Tails []*NxGroupTail `json:"qTails,omitempty"`
	// Size and offset of the data in the matrix.
	Area *Rect `json:"qArea,omitempty"`
	// Is set to true, if the data have been reduced.
	// The default value is false.
	IsReduced bool `json:"qIsReduced,omitempty"`
}

type NxDataReductionMode string

func (t NxDataReductionMode) String() string {
	return string(t)
}

func (t NxDataReductionMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxDerivedField struct {
	// Identifier of the derived field.
	// The identifier is unique.
	Id string `json:"qId,omitempty"`
	// Combination of field name, definition and method.
	// Example:
	// _OrderDate.MyDefinition.Year_
	Name string `json:"qName,omitempty"`
	// Method name associated to the derived field.
	Method string `json:"qMethod,omitempty"`
	// Expression of the derived field.
	// Example:
	// If qName is OrderDate.MyDefinition.Year , the expression is as follows:
	// _=${Mydefinition(OrderDate).Year}_
	Expr string `json:"qExpr,omitempty"`
	// List of tags.
	Tags []string `json:"qTags,omitempty"`
}

type NxDerivedFieldDescriptionList struct {
	// Information about the derived fields.
	DerivedFieldLists []*NxDerivedFieldsData `json:"qDerivedFieldLists,omitempty"`
}

type NxDerivedFieldsData struct {
	// Name of the derived definition.
	DerivedDefinitionName string `json:"qDerivedDefinitionName,omitempty"`
	// List of the derived fields.
	FieldDefs []*NxDerivedField `json:"qFieldDefs,omitempty"`
	// List of the derived groups.
	GroupDefs []*NxDerivedGroup `json:"qGroupDefs,omitempty"`
	// List of tags on the derived fields.
	Tags []string `json:"qTags,omitempty"`
}

type NxDerivedGroup struct {
	// Identifier of the group.
	Id string `json:"qId,omitempty"`
	// Name of the derived group.
	Name string `json:"qName,omitempty"`
	// Grouping type.
	// The grouping should be either H or C (Grouping is mandatory for derived definitions).
	// The parameter is mandatory.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// List of the derived fields in the group.
	FieldDefs []string `json:"qFieldDefs,omitempty"`
}

type NxDimCellType string

func (t NxDimCellType) String() string {
	return string(t)
}

func (t NxDimCellType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Either qDef or qLibraryId must be set, but not both.
// If the dimension is set in the hypercube and not in the library, this dimension cannot be shared with other objects.
// A dimension that is set in the library can be used by many objects.
type NxDimension struct {
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
	// Refers to a dimension stored in the hypercube.
	Def *NxInlineDimensionDef `json:"qDef,omitempty"`
	// If set to true, no null values are returned.
	NullSuppression  bool `json:"qNullSuppression,omitempty"`
	IncludeElemValue bool `json:"qIncludeElemValue,omitempty"`
	// Sets the dimension limits. Each dimension of a hypercube is configured separately.
	// Defines if some values (grouped as Others ) should be grouped together in the visualization.
	// For example in a pie chart all values lower than 200 could be grouped together.
	OtherTotalSpec *OtherTotalSpecProp `json:"qOtherTotalSpec,omitempty"`
	ShowTotal      bool                `json:"qShowTotal,omitempty"`
	// If set to true, all dimension values are shown.
	ShowAll bool `json:"qShowAll,omitempty"`
	// This property is used when some dimension limits are set.
	// Label of the Others group. The default label is Others .
	// Example:
	// _"qOtherLabel":"= <label>"_
	// or
	// _"qOtherLabel":{"qExpr":"= <label>"}_
	// Where:
	//
	// • < label > is the label of the Others group.
	OtherLabel *StringExpr `json:"qOtherLabel,omitempty"`
	// If this property is set, the total of the calculated values is returned.
	// The default label is Total .
	// Example:
	// _"qTotalLabel":"= <label>"_
	// or
	// _"qTotalLabel":{"qExpr":"= <label>"}_
	// Where:
	//
	// • < label > is the label of the Total group.
	TotalLabel *StringExpr `json:"qTotalLabel,omitempty"`
	// Specifies a calculation condition, which must be fulfilled for the dimension to be calculated.
	// If the calculation condition is not met, the dimension is excluded from the calculation.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCond *ValueExpr `json:"qCalcCond,omitempty"`
	// List of attribute expressions.
	AttributeExpressions []*NxAttrExprDef `json:"qAttributeExpressions,omitempty"`
	// List of attribute dimensions.
	AttributeDimensions []*NxAttrDimDef `json:"qAttributeDimensions,omitempty"`
	// Specifies a calculation condition object.
	// If CalcCondition.Cond is not fulfilled, the dimension is excluded from the calculation and CalcCondition.Msg is evaluated.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCondition *NxCalcCond `json:"qCalcCondition,omitempty"`
}

type NxDimensionInfo struct {
	// Corresponds to the label of the dimension that is selected.
	// If the label is not defined then the field name is used.
	FallbackTitle string `json:"qFallbackTitle,omitempty"`
	// Length of the longest value in the field.
	ApprMaxGlyphCount int `json:"qApprMaxGlyphCount,omitempty"`
	// Number of distinct field values.
	Cardinal int `json:"qCardinal,omitempty"`
	// Is set to true if the field is locked.
	Locked bool `json:"qLocked,omitempty"`
	// Sort indicator.
	// The default value is no sorting.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or NX_SORT_INDICATE_NONE
	//
	// • A or NX_SORT_INDICATE_ASC
	//
	// • D or NX_SORT_INDICATE_DESC
	SortIndicator NxSortIndicatorType `json:"qSortIndicator,omitempty"`
	// Array of dimension labels.
	// Contains the labels of all dimensions in a hierarchy group (for example the labels of all dimensions in a drill down group).
	GroupFallbackTitles []string `json:"qGroupFallbackTitles,omitempty"`
	// Index of the dimension that is currently in use.
	// _qGroupPos_ is set to 0 if there are no hierarchical groups (drill-down groups) or cycle groups.
	GroupPos int `json:"qGroupPos,omitempty"`
	// Number of values in a particular state.
	StateCounts *NxStateCounts `json:"qStateCounts,omitempty"`
	// Gives information on a field. For example, it can return the type of the field.
	// Examples: key, text, ASCII
	Tags []string `json:"qTags,omitempty"`
	// This parameter is optional.
	// Gives information on the error.
	Error *NxValidationError `json:"qError,omitempty"`
	// Binary format of the field.
	//
	// One of:
	//
	// • D or NX_DIMENSION_TYPE_DISCRETE
	//
	// • N or NX_DIMENSION_TYPE_NUMERIC
	//
	// • T or NX_DIMENSION_TYPE_TIME
	DimensionType NxDimensionType `json:"qDimensionType,omitempty"`
	// If set to true, it inverts the sort criteria in the field.
	ReverseSort bool `json:"qReverseSort,omitempty"`
	// Defines the grouping.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// If set to true, it means that the field is a semantic.
	IsSemantic bool `json:"qIsSemantic,omitempty"`
	// Format of the field.
	// This parameter is optional.
	NumFormat *FieldAttributes `json:"qNumFormat,omitempty"`
	// This parameter is set to true if qNumFormat is set to U (unknown). The engine guesses the type of the field based on the field's definition.
	IsAutoFormat bool `json:"qIsAutoFormat,omitempty"`
	// Array of field names.
	GroupFieldDefs []string `json:"qGroupFieldDefs,omitempty"`
	// Minimum value.
	Min Float64 `json:"qMin,omitempty"`
	// Maximum value.
	Max Float64 `json:"qMax,omitempty"`
	// Is continuous axis used.
	ContinuousAxes bool `json:"qContinuousAxes,omitempty"`
	// Is a cyclic dimension used.
	IsCyclic bool `json:"qIsCyclic,omitempty"`
	// Is derived field is used as a dimension.
	DerivedField bool `json:"qDerivedField,omitempty"`
	// Array of attribute expressions.
	AttrExprInfo []*NxAttrExprInfo `json:"qAttrExprInfo,omitempty"`
	// Array of attribute dimensions.
	AttrDimInfo []*NxAttrDimInfo `json:"qAttrDimInfo,omitempty"`
	// The message displayed if calculation condition is not fulfilled.
	CalcCondMsg string `json:"qCalcCondMsg,omitempty"`
	// True if this is a calculated dimension.
	IsCalculated bool `json:"qIsCalculated,omitempty"`
	// If set to true, it means that the field always has one and only one selected value.
	IsOneAndOnlyOne bool `json:"qIsOneAndOnlyOne,omitempty"`
	// Dimension Cardinalities
	Cardinalities *NxCardinalities `json:"qCardinalities,omitempty"`
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
}

type NxDimensionType string

func (t NxDimensionType) String() string {
	return string(t)
}

func (t NxDimensionType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxEngineVersion struct {
	// Version number of the Qlik engine component.
	ComponentVersion string `json:"qComponentVersion,omitempty"`
}

type NxExportFileType string

func (t NxExportFileType) String() string {
	return string(t)
}

func (t NxExportFileType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxExportState string

func (t NxExportState) String() string {
	return string(t)
}

func (t NxExportState) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// NxDerivedFieldsdata:
//
//   +------------------------+--------------------------------+----------------+
//   |          NAME          |          DESCRIPTION           |      TYPE      |
//   +------------------------+--------------------------------+----------------+
//   | qDerivedDefinitionName | Name of the derived            | String         |
//   |                        | definition.                    |                |
//   | qFieldDefs             | List of the derived fields.    | Array of       |
//   |                        |                                | NxDerivedField |
//   | qGroupDefs             | List of the derived groups.    | Array of       |
//   |                        |                                | NxDerivedGroup |
//   | qTags                  | List of tags on the derived    | Array of       |
//   |                        | fields.                        | String         |
//   +------------------------+--------------------------------+----------------+
type NxFieldDescription struct {
	// If set to true, it means that the field is a semantic.
	IsSemantic bool `json:"qIsSemantic,omitempty"`
	// If set to true, it means that the field is hidden.
	IsHidden bool `json:"qIsHidden,omitempty"`
	// If set to true, it means that the field is a system field.
	IsSystem bool `json:"qIsSystem,omitempty"`
	// If set to true a logical AND (instead of a logical OR) is used when making selections in a field.
	// The default value is false.
	AndMode bool `json:"qAndMode,omitempty"`
	// Name of the field
	Name string `json:"qName,omitempty"`
	// Number of distinct field values
	Cardinal int `json:"qCardinal,omitempty"`
	// Gives information on a field. For example, it can return the type of the field.
	// Examples: key, text, ASCII
	Tags []string `json:"qTags,omitempty"`
	// If set to true, it means that the field is a field on the fly.
	IsDefinitionOnly bool `json:"qIsDefinitionOnly,omitempty"`
	// Lists the derived fields if any.
	DerivedFieldData *NxDerivedFieldDescriptionList `json:"qDerivedFieldData,omitempty"`
	// Is used for Direct Discovery.
	// If set to true, it means that the type of the field is detail.
	IsDetail bool `json:"qIsDetail,omitempty"`
	// Is used for Direct Discovery.
	// If set to true, it means that the type of the field is measure.
	IsImplicit   bool   `json:"qIsImplicit,omitempty"`
	ReadableName string `json:"qReadableName,omitempty"`
}

type NxFieldProperties struct {
	// This parameter is set to true, if the field has one and only one selection (not 0 and not more than 1).
	// If this property is set to true, the field cannot be cleared anymore and no more selections can be performed in that field.
	// The property OneAndOnlyOne can be set to true if one and only value has been selected in the field prior to setting the property.
	OneAndOnlyOne bool `json:"qOneAndOnlyOne,omitempty"`
}

type NxFieldSelectionInfo struct {
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// Selection mode.
	//
	// Properties:
	//
	// One of:
	//
	// • NORMAL for a selection in normal mode.
	//
	// • AND for a selection in AND mode.
	//
	// • NOT for a selection NOT in AND mode.
	// One of:
	//
	// • NORMAL or SELECTION_MODE_NORMAL
	//
	// • AND or SELECTION_MODE_AND
	//
	// • NOT or SELECTION_MODE_NOT
	FieldSelectionMode NxFieldSelectionMode `json:"qFieldSelectionMode,omitempty"`
}

type NxFieldSelectionMode string

func (t NxFieldSelectionMode) String() string {
	return string(t)
}

func (t NxFieldSelectionMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxFrequencyMode string

func (t NxFrequencyMode) String() string {
	return string(t)
}

func (t NxFrequencyMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxGetBookmarkOptions struct {
	// List of object types.
	Types []string `json:"qTypes,omitempty"`
	// Set of data.
	Data json.RawMessage `json:"qData,omitempty"`
}

type NxGetObjectOptions struct {
	// List of object types.
	Types []string `json:"qTypes,omitempty"`
	// Set to true to include session objects.
	// The default value is false.
	IncludeSessionObjects bool `json:"qIncludeSessionObjects,omitempty"`
	// Set of data.
	Data json.RawMessage `json:"qData,omitempty"`
}

type NxGroupTail struct {
	// Number of elements that are part of the previous tail.
	// This number depends on the paging, more particularly it depends on the values defined in qTop and qHeight .
	// Is not shown if the value is 0.
	// This parameter is optional.
	Up int `json:"qUp,omitempty"`
	// Number of elements that are part of the next tail.
	// This number depends on the paging, more particularly it depends on the values defined in qTop and qHeight
	// Is not shown if the value is 0.
	// This parameter is optional.
	Down int `json:"qDown,omitempty"`
}

type NxGrpType string

func (t NxGrpType) String() string {
	return string(t)
}

func (t NxGrpType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxHighlightRanges struct {
	// Ranges of highlighted values.
	Ranges []*CharRange `json:"qRanges,omitempty"`
}

type NxHypercubeMode string

func (t NxHypercubeMode) String() string {
	return string(t)
}

func (t NxHypercubeMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxInfo struct {
	// Identifier of the object.
	// If the chosen identifier is already in use, the engine automatically sets another one.
	// If an identifier is not set, the engine automatically sets one.
	// This parameter is optional.
	Id string `json:"qId,omitempty"`
	// Type of the object.
	// This parameter is mandatory.
	Type string `json:"qType,omitempty"`
}

type NxInlineDimensionDef struct {
	// Used to define a cyclic group or drill-down group.
	// Default value is no grouping.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// Array of field names.
	// When creating a grouped dimension, more than one field name is defined.
	// This parameter is optional.
	FieldDefs []string `json:"qFieldDefs,omitempty"`
	// Array of field labels.
	// This parameter is optional.
	FieldLabels []string `json:"qFieldLabels,omitempty"`
	// Defines the sorting criteria in the field.
	// Default is to sort by alphabetical order, ascending.
	// This parameter is optional.
	SortCriterias []*SortCriteria `json:"qSortCriterias,omitempty"`
	// Defines the format of the value.
	// This parameter is optional.
	NumberPresentations []*FieldAttributes `json:"qNumberPresentations,omitempty"`
	// If set to true, it inverts the sort criteria in the field.
	ReverseSort bool `json:"qReverseSort,omitempty"`
	// Index of the active field in a cyclic dimension.
	// This parameter is optional. The default value is 0.
	// This parameter is used in case of cyclic dimensions ( qGrouping is C).
	ActiveField int `json:"qActiveField,omitempty"`
	// Label expression.
	// This parameter is optional.
	LabelExpression string `json:"qLabelExpression,omitempty"`
}

type NxInlineMeasureDef struct {
	// Name of the measure.
	// An empty string is returned as a default value.
	// This parameter is optional.
	Label string `json:"qLabel,omitempty"`
	// Description of the measure.
	// An empty string is returned as a default value.
	// This parameter is optional.
	Description string `json:"qDescription,omitempty"`
	// Name connected to the measure that is used for search purposes.
	// A measure can have several tags.
	// This parameter is optional.
	Tags []string `json:"qTags,omitempty"`
	// Default value is no grouping.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// Definition of the expression in the measure.
	// Example: Sum (OrderTotal)
	// This parameter is mandatory.
	Def string `json:"qDef,omitempty"`
	// Format of the field.
	// This parameter is optional.
	NumFormat *FieldAttributes `json:"qNumFormat,omitempty"`
	// If set to true, percentage values are returned instead of absolute numbers.
	// Default value is false.
	// This parameter is optional.
	Relative bool `json:"qRelative,omitempty"`
	// If set to true, the sum of rows total should be used rather than real expression total.
	// This parameter is optional and applies to straight tables.
	// Default value is false.
	// If using the Qlik Sense interface, it means that the total mode is set to Expression Total .
	BrutalSum bool `json:"qBrutalSum,omitempty"`
	// Aggregate function.
	// For more information on the aggregate function syntax, see the section Working with Qlik Sense on the online help portal.
	// The default value is 0 (Sum of rows)
	// This parameter is optional.
	AggrFunc string `json:"qAggrFunc,omitempty"`
	// * 0 means no accumulation
	//
	// • 1 means full accumulation (each y-value accumulates all previous y-values of the expression)
	//
	// • ≥ 2 means accumulate as many steps as the qAccumulate value
	// Default value is 0.
	// This parameter is optional.
	Accumulate int `json:"qAccumulate,omitempty"`
	// If set to true, it inverts the sort criteria in the field.
	ReverseSort bool `json:"qReverseSort,omitempty"`
	// Index of the active expression in a cyclic measure. The indexing starts from 0.
	// The default value is 0.
	// This parameter is optional.
	ActiveExpression int `json:"qActiveExpression,omitempty"`
	// Array of expressions. This parameter is used in case of cyclic measures ( qGrouping is C). List of the expressions in the cyclic group.
	Expressions []string `json:"qExpressions,omitempty"`
	// Label expression.
	// This parameter is optional.
	LabelExpression string `json:"qLabelExpression,omitempty"`
}

type NxLayoutErrors struct {
	// Error code.
	ErrorCode int `json:"qErrorCode,omitempty"`
}

type NxLibraryDimension struct {
	// Information about the grouping.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// Array of dimension names.
	FieldDefs []string `json:"qFieldDefs,omitempty"`
	// Array of dimension labels.
	FieldLabels     []string `json:"qFieldLabels,omitempty"`
	LabelExpression string   `json:"qLabelExpression,omitempty"`
}

type NxLibraryDimensionDef struct {
	// Information about the grouping.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// Array of dimension names.
	FieldDefs []string `json:"qFieldDefs,omitempty"`
	// Array of dimension labels.
	FieldLabels     []string `json:"qFieldLabels,omitempty"`
	LabelExpression string   `json:"qLabelExpression,omitempty"`
}

// Information about the library measure. Is the layout for NxLibraryMeasureDef.
type NxLibraryMeasure struct {
	Label string `json:"qLabel,omitempty"`
	Def   string `json:"qDef,omitempty"`
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping         NxGrpType `json:"qGrouping,omitempty"`
	Expressions      []string  `json:"qExpressions,omitempty"`
	ActiveExpression int       `json:"qActiveExpression,omitempty"`
	LabelExpression  string    `json:"qLabelExpression,omitempty"`
}

type NxLibraryMeasureDef struct {
	// Label of the measure.
	Label string `json:"qLabel,omitempty"`
	// Definition of the measure.
	Def string `json:"qDef,omitempty"`
	// Used to define a cyclic group or drill-down group.
	// Default value is no grouping.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// Array of expressions.
	Expressions []string `json:"qExpressions,omitempty"`
	// Index to the active expression in a measure.
	ActiveExpression int `json:"qActiveExpression,omitempty"`
	// Optional expression used for dynamic label.
	LabelExpression string `json:"qLabelExpression,omitempty"`
}

type NxLinkedObjectInfo struct {
	// Identifier of the root object.
	// If the linked object is a child, the root identifier is the identifier of the parent.
	// If the linked object is an app object, the root identifier is the same than the identifier of the linked object since the linked object is a root object.
	RootId string `json:"qRootId,omitempty"`
	// Information about the linked object.
	Info *NxInfo `json:"qInfo,omitempty"`
}

type NxListObjectExpression struct {
	// Value of the expression.
	Expr string `json:"qExpr,omitempty"`
	// Gives information on the error.
	// This parameter is optional.
	Error *NxLayoutErrors `json:"qError,omitempty"`
}

type NxListObjectExpressionDef struct {
	// Value of the expression.
	Expr string `json:"qExpr,omitempty"`
	// Refers to an expression stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
}

type NxLocalizedErrorCode string

func (t NxLocalizedErrorCode) String() string {
	return string(t)
}

func (t NxLocalizedErrorCode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxLocalizedWarningCode string

func (t NxLocalizedWarningCode) String() string {
	return string(t)
}

func (t NxLocalizedWarningCode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxMatchingFieldInfo struct {
	// Name of the field.
	Name string `json:"qName,omitempty"`
	// List of tags.
	Tags []string `json:"qTags,omitempty"`
}

type NxMatchingFieldMode string

func (t NxMatchingFieldMode) String() string {
	return string(t)
}

func (t NxMatchingFieldMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Either qDef or qLibraryId must be set, but not both.
// If the measure is set in the hypercube and not in the library, this measure cannot be shared with other objects.
// A measure that is set in the library can be used by many objects.
//
// expressions are complementary expressions associated to a measure. For example, you can decide to change the background color of a visualization depending on the values of the measure.
// Attribute expressions do not affect the layout of an object. The sorting order is unchanged.
type NxMeasure struct {
	// Refers to a measure stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
	// Refers to a measure stored in the hypercube.
	Def *NxInlineMeasureDef `json:"qDef,omitempty"`
	// Defines the sort criteria.
	// The default value is sort by ascending alphabetic order.
	// This property is optional.
	SortBy *SortCriteria `json:"qSortBy,omitempty"`
	// List of attribute expressions.
	AttributeExpressions []*NxAttrExprDef `json:"qAttributeExpressions,omitempty"`
	// List of attribute dimensions.
	AttributeDimensions []*NxAttrDimDef `json:"qAttributeDimensions,omitempty"`
	// Specifies a calculation condition, which must be fulfilled for the measure to be calculated.
	// If the calculation condition is not met, the measure is excluded from the calculation.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCond *ValueExpr `json:"qCalcCond,omitempty"`
	// Specifies a calculation condition object.
	// If CalcCondition.Cond is not fulfilled, the measure is excluded from the calculation and CalcCondition.Msg is evaluated.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCondition *NxCalcCond `json:"qCalcCondition,omitempty"`
}

// Layout for NxInlineMeasureDef.
type NxMeasureInfo struct {
	// Corresponds to the label of the measure.
	// If the label is not defined then the measure name is used.
	FallbackTitle string `json:"qFallbackTitle,omitempty"`
	// Length of the longest value in the field.
	ApprMaxGlyphCount int `json:"qApprMaxGlyphCount,omitempty"`
	// Number of distinct field values.
	Cardinal int `json:"qCardinal,omitempty"`
	// Sort indicator.
	// The default value is no sorting.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or NX_SORT_INDICATE_NONE
	//
	// • A or NX_SORT_INDICATE_ASC
	//
	// • D or NX_SORT_INDICATE_DESC
	SortIndicator NxSortIndicatorType `json:"qSortIndicator,omitempty"`
	// Format of the field.
	// This parameter is optional.
	NumFormat *FieldAttributes `json:"qNumFormat,omitempty"`
	// Lowest value in the range.
	Min Float64 `json:"qMin,omitempty"`
	// Highest value in the range.
	Max Float64 `json:"qMax,omitempty"`
	// This parameter is optional.
	// Gives information on the error.
	Error *NxValidationError `json:"qError,omitempty"`
	// If set to true, it inverts the sort criteria in the field.
	ReverseSort bool `json:"qReverseSort,omitempty"`
	// This parameter is set to true if qNumFormat is set to U (unknown). The engine guesses the type of the field based on the field's expression.
	IsAutoFormat bool `json:"qIsAutoFormat,omitempty"`
	// List of attribute expressions.
	AttrExprInfo []*NxAttrExprInfo `json:"qAttrExprInfo,omitempty"`
	// List of attribute dimensions.
	AttrDimInfo []*NxAttrDimInfo `json:"qAttrDimInfo,omitempty"`
	// The message displayed if calculation condition is not fulfilled.
	CalcCondMsg string `json:"qCalcCondMsg,omitempty"`
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
}

// Layout for NxMetaDef.
type NxMeta struct {
	// Name.
	// This property is optional.
	Name string `json:"qName,omitempty"`
}

// Used to collect meta data.
//
// Properties:
//
// Semantic type with an empty structure.
type NxMetaDef struct {
}

type NxMultiRangeSelectInfo struct {
	Ranges          []*NxRangeSelectInfo `json:"qRanges,omitempty"`
	ColumnsToSelect []int                `json:"qColumnsToSelect,omitempty"`
}

type NxPage struct {
	// Position from the left.
	// Corresponds to the first column.
	Left int `json:"qLeft,omitempty"`
	// Position from the top.
	// Corresponds to the first row.
	Top int `json:"qTop,omitempty"`
	// Number of columns in the page. The indexing of the columns may vary depending on whether the cells are expanded or not (parameter qAlwaysFullyExpanded in HyperCubeDef ).
	Width int `json:"qWidth,omitempty"`
	// Number of rows or elements in the page. The indexing of the rows may vary depending on whether the cells are expanded or not (parameter qAlwaysFullyExpanded in HyperCubeDef ).
	Height int `json:"qHeight,omitempty"`
}

type NxPageTreeLevel struct {
	// The first dimension that is to be part of the tree, counted from the left. For example, if qLeft is equal to 1, omit nodes from the first dimension in the current sort order.
	Left int `json:"qLeft,omitempty"`
	// Number of dimensions to include in the tree.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	Depth *int `json:"qDepth,omitempty"`
}

// Defines an area of the tree to be fetched.
type NxPageTreeNode struct {
	// The area of the tree to be fetched. If no area is defined on a dimension, all existing nodes are included.
	Area *Rect `json:"qArea,omitempty"`
	// When set to true, generated nodes (based on current selection) will be inserted into the returned tree even when there is no actual value. For example, suppose you are looking for hybrid car sales at all car dealerships. Normally, only dealerships where hybrid cars are sold would be part of the returned tree but with qAllValues set to true, all available dealerships will be included regardless if they sold any hybrid cars or not.
	AllValues bool `json:"qAllValues,omitempty"`
}

type NxPatch struct {
	// Operation to perform.
	//
	// One of:
	//
	// • add or Add
	//
	// • remove or Remove
	//
	// • replace or Replace
	Op NxPatchOperationType `json:"qOp,omitempty"`
	// Path to the property to add, remove or replace.
	Path string `json:"qPath,omitempty"`
	// This parameter is not used in a remove operation.
	// Corresponds to the value of the property to add or to the new value of the property to update.
	// Examples:
	// "false", "2", "\"New title\""
	Value string `json:"qValue,omitempty"`
}

type NxPatchOperationType string

func (t NxPatchOperationType) String() string {
	return string(t)
}

func (t NxPatchOperationType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxPivotDimensionCell struct {
	// Some text.
	Text string `json:"qText,omitempty"`
	// Rank number of the value.
	// If set to -1, it means that the value is not an element number.
	ElemNo int `json:"qElemNo,omitempty"`
	// Value of the cell.
	// Is set to NaN , if the value is not a number.
	Value Float64 `json:"qValue,omitempty"`
	// If set to true, it means that the cell can be expanded.
	// This parameter is not returned if it is set to false.
	CanExpand bool `json:"qCanExpand,omitempty"`
	// If set to true, it means that the cell can be collapsed.
	// This parameter is not returned if it is set to false.
	CanCollapse bool `json:"qCanCollapse,omitempty"`
	// Type of the cell.
	//
	// One of:
	//
	// • V or NX_DIM_CELL_VALUE
	//
	// • E or NX_DIM_CELL_EMPTY
	//
	// • N or NX_DIM_CELL_NORMAL
	//
	// • T or NX_DIM_CELL_TOTAL
	//
	// • O or NX_DIM_CELL_OTHER
	//
	// • A or NX_DIM_CELL_AGGR
	//
	// • P or NX_DIM_CELL_PSEUDO
	//
	// • R or NX_DIM_CELL_ROOT
	//
	// • U or NX_DIM_CELL_NULL
	//
	// • G or NX_DIM_CELL_GENERATED
	Type NxDimCellType `json:"qType,omitempty"`
	// Number of elements that are part of the previous tail.
	// This number depends on the paging, more particularly it depends on the values defined in qTop and qHeight .
	Up int `json:"qUp,omitempty"`
	// Number of elements that are part of the next tail.
	// This number depends on the paging, more particularly it depends on the values defined in qTop and qHeight .
	Down int `json:"qDown,omitempty"`
	// Information about sub nodes (or sub cells).
	// The array is empty [ ] when there is no sub nodes.
	SubNodes []*NxPivotDimensionCell `json:"qSubNodes,omitempty"`
	// Information about attribute expressions.
	// The array is empty [ ] when there is no attribute expressions.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	// Information about attribute dimensions.
	AttrDims *NxAttributeDimValues `json:"qAttrDims,omitempty"`
}

type NxPivotPage struct {
	// Information about the left dimension values of a pivot table.
	Left []*NxPivotDimensionCell `json:"qLeft,omitempty"`
	// Information about the top dimension values of a pivot table. If there is no top dimension in the pivot table, information about the measures are given.
	Top []*NxPivotDimensionCell `json:"qTop,omitempty"`
	// Array of data.
	Data []ArrayOfNxValuePoint `json:"qData,omitempty"`
	// Size and offset of the data in the matrix.
	Area *Rect `json:"qArea,omitempty"`
}

type NxPivotValuePoint struct {
	// Label of the cell.
	// This parameter is optional.
	Label string `json:"qLabel,omitempty"`
	// Some text related to the cell.
	Text string `json:"qText,omitempty"`
	// Value of the cell.
	Num Float64 `json:"qNum,omitempty"`
	// Type of the cell.
	//
	// One of:
	//
	// • V or NX_DIM_CELL_VALUE
	//
	// • E or NX_DIM_CELL_EMPTY
	//
	// • N or NX_DIM_CELL_NORMAL
	//
	// • T or NX_DIM_CELL_TOTAL
	//
	// • O or NX_DIM_CELL_OTHER
	//
	// • A or NX_DIM_CELL_AGGR
	//
	// • P or NX_DIM_CELL_PSEUDO
	//
	// • R or NX_DIM_CELL_ROOT
	//
	// • U or NX_DIM_CELL_NULL
	//
	// • G or NX_DIM_CELL_GENERATED
	Type NxDimCellType `json:"qType,omitempty"`
	// Attribute expressions values.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	AttrDims *NxAttributeDimValues        `json:"qAttrDims,omitempty"`
}

type NxRange struct {
	// Position in the expression of the first character of the field name.
	From int `json:"qFrom,omitempty"`
	// Number of characters in the field name.
	Count int `json:"qCount,omitempty"`
}

type NxRangeSelectInfo struct {
	// Range of values.
	Range *Range `json:"qRange,omitempty"`
	// Number of the measure to select.
	// Numbering starts from 0.
	MeasureIx int `json:"qMeasureIx,omitempty"`
}

type NxSelectionCell struct {
	// Type of cells to select.
	//
	// One of:
	//
	// • D or NX_CELL_DATA
	//
	// • T or NX_CELL_TOP
	//
	// • L or NX_CELL_LEFT
	Type NxSelectionCellType `json:"qType,omitempty"`
	// Column index to select.
	// Indexing starts from 0.
	// If the cell's type is:
	//
	// • D, the index is based on the data matrix.
	//
	// • T, the index is based on the data matrix.
	//
	// • L, the index is based on the left dimensions indexes.
	Col int `json:"qCol,omitempty"`
	// Row index to select.
	// Indexing starts from 0.
	// If the cell's type is:
	//
	// • D, the index is based on the data matrix.
	//
	// • T, the index is based on the top dimensions indexes.
	//
	// • L, the index is based on the data matrix.
	Row int `json:"qRow,omitempty"`
}

type NxSelectionCellType string

func (t NxSelectionCellType) String() string {
	return string(t)
}

func (t NxSelectionCellType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxSelectionInfo struct {
	// Is set to true if the visualization is in selection mode.
	// For more information about the selection mode, see BeginSelections Method.
	InSelections bool `json:"qInSelections,omitempty"`
	// Is set to true if the visualization is in selection mode and if some selections have been made while in selection mode.
	// For more information about the selection mode, see BeginSelections Method.
	MadeSelections bool `json:"qMadeSelections,omitempty"`
}

type NxSimpleDimValue struct {
	// Text related to the attribute expression value.
	// This property is optional. No text is returned if the attribute expression value is a numeric.
	Text string `json:"qText,omitempty"`
	// Element number.
	ElemNo int `json:"qElemNo,omitempty"`
}

type NxSimpleValue struct {
	// Text related to the attribute expression value.
	Text string `json:"qText,omitempty"`
	// Numeric value of the attribute expression.
	// Set to NaN (Not a Number) if the attribute expression value is not numeric.
	Num Float64 `json:"qNum,omitempty"`
}

type NxSortIndicatorType string

func (t NxSortIndicatorType) String() string {
	return string(t)
}

func (t NxSortIndicatorType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type NxStackPage struct {
	// Array of data.
	Data []*NxStackedPivotCell `json:"qData,omitempty"`
	// Size and offset of the data in the matrix.
	Area *Rect `json:"qArea,omitempty"`
}

type NxStackedPivotCell struct {
	// Some text.
	Text string `json:"qText,omitempty"`
	// Rank number of the value.
	// If set to -1, it means that the value is not an element number.
	ElemNo int `json:"qElemNo,omitempty"`
	// Value of the cell.
	// Is set to NaN , if the value is not a number.
	Value Float64 `json:"qValue,omitempty"`
	// If set to true, it means that the cell can be expanded.
	// This parameter is not returned if it is set to false.
	CanExpand bool `json:"qCanExpand,omitempty"`
	// If set to true, it means that the cell can be collapsed.
	// This parameter is not returned if it is set to false.
	CanCollapse bool `json:"qCanCollapse,omitempty"`
	// Type of the cell.
	//
	// One of:
	//
	// • V or NX_DIM_CELL_VALUE
	//
	// • E or NX_DIM_CELL_EMPTY
	//
	// • N or NX_DIM_CELL_NORMAL
	//
	// • T or NX_DIM_CELL_TOTAL
	//
	// • O or NX_DIM_CELL_OTHER
	//
	// • A or NX_DIM_CELL_AGGR
	//
	// • P or NX_DIM_CELL_PSEUDO
	//
	// • R or NX_DIM_CELL_ROOT
	//
	// • U or NX_DIM_CELL_NULL
	//
	// • G or NX_DIM_CELL_GENERATED
	Type NxDimCellType `json:"qType,omitempty"`
	// Total of the positive values in the current group of cells.
	MaxPos Float64 `json:"qMaxPos,omitempty"`
	// Total of the negative values in the current group of cells.
	MinNeg Float64 `json:"qMinNeg,omitempty"`
	// Number of elements that are part of the previous tail.
	Up int `json:"qUp,omitempty"`
	// Number of elements that are part of the next tail.
	Down int `json:"qDown,omitempty"`
	// Row index in the data matrix.
	// The indexing starts from 0.
	Row int `json:"qRow,omitempty"`
	// Information about sub nodes (or sub cells).
	// The array is empty [ ] when there are no sub nodes.
	SubNodes []*NxStackedPivotCell `json:"qSubNodes,omitempty"`
	// Attribute expressions values.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	// Attribute dimensions values.
	AttrDims *NxAttributeDimValues `json:"qAttrDims,omitempty"`
}

type NxStateCounts struct {
	// Number of values in locked state.
	Locked int `json:"qLocked,omitempty"`
	// Number of values in selected state.
	Selected int `json:"qSelected,omitempty"`
	// Number of values in optional state.
	Option int `json:"qOption,omitempty"`
	// Number of values in deselected state.
	Deselected int `json:"qDeselected,omitempty"`
	// Number of values in alternative state.
	Alternative int `json:"qAlternative,omitempty"`
	// Number of values in excluded state.
	Excluded int `json:"qExcluded,omitempty"`
	// Number of values in selected excluded state.
	SelectedExcluded int `json:"qSelectedExcluded,omitempty"`
	// Number of values in locked excluded state.
	LockedExcluded int `json:"qLockedExcluded,omitempty"`
}

// This struct is deprecated (not recommended to use).
type NxStreamListEntry struct {
	// Name of the stream.
	Name string `json:"qName,omitempty"`
	// Identifier of the stream.
	Id string `json:"qId,omitempty"`
}

type NxTickCell struct {
	// Tick's label.
	Text string `json:"qText,omitempty"`
	// Start value.
	Start Float64 `json:"qStart,omitempty"`
	// End value.
	End Float64 `json:"qEnd,omitempty"`
}

// Specifies all the paging filters needed to define the tree to be fetched.
type NxTreeDataOption struct {
	// Maximum number of nodes in the tree. If this limit is exceeded, no nodes are returned. All nodes are counted.
	MaxNbrOfNodes int `json:"qMaxNbrOfNodes,omitempty"`
	// Defines areas of the tree to be fetched. Areas must be defined left to right.
	TreeNodes []*NxPageTreeNode `json:"qTreeNodes,omitempty"`
	// Filters out complete dimensions from the fetched tree.
	TreeLevels *NxPageTreeLevel `json:"qTreeLevels,omitempty"`
}

type NxTreeDimensionDef struct {
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
	// Refers to a dimension.
	Def *NxInlineDimensionDef `json:"qDef,omitempty"`
	// List of measures.
	ValueExprs []*NxMeasure `json:"qValueExprs,omitempty"`
	// If set to true, no null values are returned.
	NullSuppression bool `json:"qNullSuppression,omitempty"`
	// Sets the dimension limits. Each dimension of a hypercube is configured separately.
	// Defines if some values (grouped as Others ) should be grouped together in the visualization.
	// For example in a pie chart all values lower than 200 could be grouped together.
	OtherTotalSpec *OtherTotalSpecProp `json:"qOtherTotalSpec,omitempty"`
	// If set to true, all dimension values are shown.
	ShowAll bool `json:"qShowAll,omitempty"`
	// This property is used when some dimension limits are set.
	// Label of the Others group. The default label is Others .
	// Example:
	// _"qOtherLabel":"= <label>"_
	// or
	// _"qOtherLabel":{"qExpr":"= <label>"}_
	// Where:
	//
	// • < label > is the label of the Others group.
	OtherLabel *StringExpr `json:"qOtherLabel,omitempty"`
	// If this property is set, the total of the calculated values is returned.
	// The default label is Total .
	// Example:
	// _"qTotalLabel":"= <label>"_
	// or
	// _"qTotalLabel":{"qExpr":"= <label>"}_
	// Where:
	//
	// • < label > is the label of the Total group.
	TotalLabel *StringExpr `json:"qTotalLabel,omitempty"`
	// Specifies a calculation condition object.
	// If CalcCondition.Cond is not fulfilled, the dimension is excluded from the calculation and CalcCondition.Msg is evaluated.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCondition *NxCalcCond `json:"qCalcCondition,omitempty"`
	// List of attribute expressions.
	AttributeExpressions []*NxAttrExprDef `json:"qAttributeExpressions,omitempty"`
	// List of attribute dimensions.
	AttributeDimensions []*NxAttrDimDef `json:"qAttributeDimensions,omitempty"`
}

type NxTreeDimensionInfo struct {
	// Corresponds to the label of the dimension that is selected.
	// If the label is not defined then the field name is used.
	FallbackTitle string `json:"qFallbackTitle,omitempty"`
	// Length of the longest value in the field.
	ApprMaxGlyphCount int `json:"qApprMaxGlyphCount,omitempty"`
	// Number of distinct field values.
	Cardinal int `json:"qCardinal,omitempty"`
	// Is set to true if the field is locked.
	Locked bool `json:"qLocked,omitempty"`
	// Sort indicator.
	// The default value is no sorting.
	// This parameter is optional.
	//
	// One of:
	//
	// • N or NX_SORT_INDICATE_NONE
	//
	// • A or NX_SORT_INDICATE_ASC
	//
	// • D or NX_SORT_INDICATE_DESC
	SortIndicator NxSortIndicatorType `json:"qSortIndicator,omitempty"`
	// Array of dimension labels.
	// Contains the labels of all dimensions in a hierarchy group (for example the labels of all dimensions in a drill down group).
	GroupFallbackTitles []string `json:"qGroupFallbackTitles,omitempty"`
	// Index of the dimension that is currently in use.
	// _qGroupPos_ is set to 0 if there are no hierarchical groups (drill-down groups) or cycle groups.
	GroupPos int `json:"qGroupPos,omitempty"`
	// Number of values in a particular state.
	StateCounts *NxStateCounts `json:"qStateCounts,omitempty"`
	// Gives information on a field. For example, it can return the type of the field.
	// Examples: key, text, ASCII
	Tags []string `json:"qTags,omitempty"`
	// This parameter is optional.
	// Gives information on the error.
	Error *NxValidationError `json:"qError,omitempty"`
	// Binary format of the field.
	//
	// One of:
	//
	// • D or NX_DIMENSION_TYPE_DISCRETE
	//
	// • N or NX_DIMENSION_TYPE_NUMERIC
	//
	// • T or NX_DIMENSION_TYPE_TIME
	DimensionType NxDimensionType `json:"qDimensionType,omitempty"`
	// If set to true, it inverts the sort criteria in the field.
	ReverseSort bool `json:"qReverseSort,omitempty"`
	// Defines the grouping.
	//
	// One of:
	//
	// • N or GRP_NX_NONE
	//
	// • H or GRP_NX_HIEARCHY
	//
	// • C or GRP_NX_COLLECTION
	Grouping NxGrpType `json:"qGrouping,omitempty"`
	// If set to true, it means that the field is a semantic.
	IsSemantic bool `json:"qIsSemantic,omitempty"`
	// Format of the field.
	// This parameter is optional.
	NumFormat *FieldAttributes `json:"qNumFormat,omitempty"`
	// This parameter is set to true if qNumFormat is set to U (unknown). The engine guesses the type of the field based on the field's definition.
	IsAutoFormat bool `json:"qIsAutoFormat,omitempty"`
	// Array of field names.
	GroupFieldDefs []string `json:"qGroupFieldDefs,omitempty"`
	// Minimum value.
	Min Float64 `json:"qMin,omitempty"`
	// Maximum value.
	Max Float64 `json:"qMax,omitempty"`
	// Is continuous axis used.
	ContinuousAxes bool `json:"qContinuousAxes,omitempty"`
	// Is a cyclic dimension used.
	IsCyclic bool `json:"qIsCyclic,omitempty"`
	// Is derived field is used as a dimension.
	DerivedField bool `json:"qDerivedField,omitempty"`
	// A List of measures to be calculated on this TreeDimension.
	MeasureInfo []*NxMeasureInfo `json:"qMeasureInfo,omitempty"`
	// List of attribute expressions.
	AttrExprInfo []*NxAttrExprInfo `json:"qAttrExprInfo,omitempty"`
	// List of attribute dimensions.
	AttrDimInfo []*NxAttrDimInfo `json:"qAttrDimInfo,omitempty"`
	// The message displayed if calculation condition is not fulfilled.
	CalcCondMsg string `json:"qCalcCondMsg,omitempty"`
	// True if this is a calculated dimension.
	IsCalculated bool `json:"qIsCalculated,omitempty"`
	// If set to true, it means that the field always has one and only one selected value.
	IsOneAndOnlyOne bool `json:"qIsOneAndOnlyOne,omitempty"`
	// Dimension Cardinalities
	Cardinalities *NxCardinalities `json:"qCardinalities,omitempty"`
	// Refers to a dimension stored in the library.
	LibraryId string `json:"qLibraryId,omitempty"`
}

type NxTreeMultiRangeSelectInfo struct {
	// An array of Ranges.
	Ranges []*NxTreeRangeSelectInfo `json:"qRanges,omitempty"`
}

// Represents a dimension in the tree.
type NxTreeNode struct {
	// The text version of the value, if available.
	Text string `json:"qText,omitempty"`
	// Value of the cell.
	// Is set to NaN , if the value is not a number.
	Value Float64 `json:"qValue,omitempty"`
	// Element number.
	ElemNo int `json:"qElemNo,omitempty"`
	// A generated number applicable to this page only. Used so that children can easily identify who their parents are.
	NodeNr int `json:"qNodeNr,omitempty"`
	// The qNodeNr of this node's parent for the current page.
	ParentNode int `json:"qParentNode,omitempty"`
	// Row index in the data matrix.
	// The indexing starts from 0.
	Row int `json:"qRow,omitempty"`
	// Type of the cell.
	//
	// One of:
	//
	// • V or NX_DIM_CELL_VALUE
	//
	// • E or NX_DIM_CELL_EMPTY
	//
	// • N or NX_DIM_CELL_NORMAL
	//
	// • T or NX_DIM_CELL_TOTAL
	//
	// • O or NX_DIM_CELL_OTHER
	//
	// • A or NX_DIM_CELL_AGGR
	//
	// • P or NX_DIM_CELL_PSEUDO
	//
	// • R or NX_DIM_CELL_ROOT
	//
	// • U or NX_DIM_CELL_NULL
	//
	// • G or NX_DIM_CELL_GENERATED
	Type NxDimCellType `json:"qType,omitempty"`
	// The measures for this node.
	Values []*NxTreeValue `json:"qValues,omitempty"`
	// The children of this node in the tree structure.
	Nodes []*NxTreeNode `json:"qNodes,omitempty"`
	// Attribute expression values.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	// Attribute dimension values.
	AttrDims *NxAttributeDimValues `json:"qAttrDims,omitempty"`
	// Total of the positive values in the current group of cells.
	MaxPos []Float64 `json:"qMaxPos,omitempty"`
	// Total of the negative values in the current group of cells.
	MinNeg []Float64 `json:"qMinNeg,omitempty"`
}

type NxTreeRangeSelectInfo struct {
	// Range of values.
	Range *Range `json:"qRange,omitempty"`
	// Number of the measure to select.
	// Numbering starts from 0.
	MeasureIx int `json:"qMeasureIx,omitempty"`
	// Number of the dimension to select
	// measure from. Numbering starts from 0.
	DimensionIx int `json:"qDimensionIx,omitempty"`
}

// Represents a measure.
type NxTreeValue struct {
	// The text version of the value, if available.
	Text string `json:"qText,omitempty"`
	// Value of the cell.
	// Is set to NaN , if the value is not a number.
	Value Float64 `json:"qValue,omitempty"`
	// Attribute expression values.
	AttrExps *NxAttributeExpressionValues `json:"qAttrExps,omitempty"`
	// Attribute dimension values.
	AttrDims *NxAttributeDimValues `json:"qAttrDims,omitempty"`
}

type NxValidationError struct {
	// Error code.
	// This parameter is always displayed in case of error.
	ErrorCode int `json:"qErrorCode,omitempty"`
	// Context related to the error, from the user app domain.
	// It can be the identifier of an object, a field name, a table name.
	// This parameter is optional.
	Context string `json:"qContext,omitempty"`
	// Internal information from the server.
	// This parameter is optional.
	ExtendedMessage string `json:"qExtendedMessage,omitempty"`
}

type NxVariableListItem struct {
	// Name of the variable.
	Name string `json:"qName,omitempty"`
	// Description of the variable.
	Description string `json:"qDescription,omitempty"`
	// Definition of the variable. It can be a value or an expression.
	Definition string `json:"qDefinition,omitempty"`
	// If set to true, it means that the variable is a system variable.
	// A system variable provides information about the system and is set by the engine. The content cannot be changed by the user.
	// This parameter is optional.
	// The default value is false.
	IsConfig bool `json:"qIsConfig,omitempty"`
	// If set to true, it means that the variable is reserved.
	// The default value is false.
	// This parameter is optional.
	// Examples:
	//
	// • ScriptError is a reserved variable, set by the engine.
	//
	// • DayNames is a reserved variable, set by the user.
	IsReserved bool `json:"qIsReserved,omitempty"`
	// Information about publishing and permissions.
	// This parameter is optional.
	Meta *NxMeta `json:"qMeta,omitempty"`
	// Identifier and type of the object.
	// This parameter is mandatory.
	Info *NxInfo `json:"qInfo,omitempty"`
	// Data.
	Data json.RawMessage `json:"qData,omitempty"`
	// If set to true, it means that the variable was defined via script.
	IsScriptCreated bool `json:"qIsScriptCreated,omitempty"`
}

type NxVariableProperties struct {
	// Name of the variable.
	Name string `json:"qName,omitempty"`
	// Defines the format of the value of a variable.
	NumberPresentation *FieldAttributes `json:"qNumberPresentation,omitempty"`
	// Set this property to true to update the variable when applying a bookmark.
	// The value of a variable can affect the state of the selections.
	// The default value is false.
	IncludeInBookmark bool `json:"qIncludeInBookmark,omitempty"`
	// The value of a variable can be an enumeration.
	// Set this property to true to reflect the predefined values in an enumeration.
	UsePredefListedValues bool `json:"qUsePredefListedValues,omitempty"`
	// List of enumerations.
	// This property is used if qUsePredefListedValues is set to true.
	PreDefinedList []string `json:"qPreDefinedList,omitempty"`
}

type NxViewPort struct {
	// Width of the canvas in pixels.
	Width int `json:"qWidth,omitempty"`
	// Height of the canvas in pixels.
	Height int `json:"qHeight,omitempty"`
	// Zoom level.
	ZoomLevel int `json:"qZoomLevel,omitempty"`
}

type ObjectInterface struct {
	// The native type of the object.
	Type string `json:"qType,omitempty"`
	// The handle used to connect to object.
	Handle int `json:"qHandle,omitempty"`
	// The type of the object.
	GenericType string `json:"qGenericType,omitempty"`
	// Object ID.
	GenericId string `json:"qGenericId,omitempty"`
}

type OdbcDsn struct {
	// Name of the ODBC connection.
	Name string `json:"qName,omitempty"`
	// Description of the ODBC connection.
	Description string `json:"qDescription,omitempty"`
	// Is set to true if the version of ODBC is 32-bit.
	// This parameter is optional. Default is false.
	Bit32 bool `json:"qBit32,omitempty"`
	// Is set to true if the connection is User DSN. The connection works only for a specific user.
	// Default is false.
	// This parameter is optional.
	UserOnly bool `json:"qUserOnly,omitempty"`
}

type OleDbProvider struct {
	// Name of the OLEDB provider.
	Name string `json:"qName,omitempty"`
	// Description of the OLEDB provider.
	Description string `json:"qDescription,omitempty"`
	// Is set to true if the version of the OLEDB provider is 32-bit.
	// Default is false.
	// This parameter is optional.
	Bit32 bool `json:"qBit32,omitempty"`
}

type OtherLimitMode string

func (t OtherLimitMode) String() string {
	return string(t)
}

func (t OtherLimitMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type OtherMode string

func (t OtherMode) String() string {
	return string(t)
}

func (t OtherMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type OtherSortMode string

func (t OtherSortMode) String() string {
	return string(t)
}

func (t OtherSortMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type OtherTotalSpecProp struct {
	// Determines how many dimension values are displayed.
	// The default value is OTHEROFF_ .
	//
	// One of:
	//
	// • OTHER_OFF
	//
	// • OTHER_COUNTED
	//
	// • OTHER_ABS_LIMITED
	//
	// • OTHER_ABS_ACC_TARGET
	//
	// • OTHER_REL_LIMITED
	//
	// • OTHER_REL_ACC_TARGET
	OtherMode OtherMode `json:"qOtherMode,omitempty"`
	// Number of values to display. The number of values can be entered as a calculated formula.
	// This parameter is used when qOtherMode is set to OTHERCOUNTED_ .
	OtherCounted *ValueExpr `json:"qOtherCounted,omitempty"`
	// Value used to limit the dimension values. The limit can be entered as a calculated formula.
	// This parameter is used when qOtherMode is set to:
	//
	// • OTHER_ABS_LIMITED
	//
	// • OTHER_REL_LIMITED
	//
	// • OTHER_ABS_ACC_TARGET
	// OTHER_REL_ACC_TARGET
	OtherLimit *ValueExpr `json:"qOtherLimit,omitempty"`
	// Sets the limit for the Others mode.
	// This parameter is used when qOtherMode is set to:
	//
	// • OTHER_ABS_LIMITED
	//
	// • OTHER_REL_LIMITED
	//
	// • OTHER_ABS_ACC_TARGET
	// OTHER_REL_ACC_TARGET
	//
	// One of:
	//
	// • OTHER_GE_LIMIT
	//
	// • OTHER_LE_LIMIT
	//
	// • OTHER_GT_LIMIT
	//
	// • OTHER_LT_LIMIT
	OtherLimitMode OtherLimitMode `json:"qOtherLimitMode,omitempty"`
	// If set to true, the group Others is not displayed as a dimension value.
	// The default value is false.
	SuppressOther bool `json:"qSuppressOther,omitempty"`
	// This parameter is used when qOtherMode is set to:
	//
	// • OTHER_ABS_LIMITED
	//
	// • OTHER_REL_LIMITED
	//
	// • OTHER_ABS_ACC_TARGET
	// OTHER_REL_ACC_TARGET
	//
	// and when the dimension values include not numeric values.
	// Set this parameter to true to include text values in the returned values.
	// The default value is true.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	ForceBadValueKeeping *bool `json:"qForceBadValueKeeping,omitempty"`
	// Set this parameter to true to allow the calculation of Others even if the engine detects some potential mistakes.
	// For example the country Russia is part of the continent Europe and Asia. If you have an hypercube with two dimensions Country and Continent and one measure Population, the engine can detect that the population of Russia is included in both the continent Asia and Europe.
	// The default value is true.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	ApplyEvenWhenPossiblyWrongResult *bool `json:"qApplyEvenWhenPossiblyWrongResult,omitempty"`
	// This parameter applies to inner dimensions.
	// If this parameter is set to true, the restrictions are calculated on the selected dimension only. All previous dimensions are ignored.
	// The default value is false.
	GlobalOtherGrouping bool `json:"qGlobalOtherGrouping,omitempty"`
	// If set to true, it collapses the inner dimensions (if any) in the group Others .
	// The default value is false.
	OtherCollapseInnerDimensions bool `json:"qOtherCollapseInnerDimensions,omitempty"`
	// Defines the sort order of the dimension values.
	// The default value is OTHERSORT_DESCENDING_ .
	//
	// One of:
	//
	// • OTHER_SORT_DEFAULT
	//
	// • OTHER_SORT_DESCENDING
	//
	// • OTHER_SORT_ASCENDING
	OtherSortMode OtherSortMode `json:"qOtherSortMode,omitempty"`
	// If set to TOTALEXPR_ , the total of the dimension values is returned.
	// The default value is TOTALOFF_ .
	//
	// One of:
	//
	// • TOTAL_OFF
	//
	// • TOTAL_EXPR
	TotalMode TotalMode `json:"qTotalMode,omitempty"`
	// This parameter applies when there are several measures.
	// Name of the measure to use for the calculation of Others for a specific dimension.
	ReferencedExpression *StringExpr `json:"qReferencedExpression,omitempty"`
}

type Point struct {
	// x-coordinate in pixels.
	// The origin is the top left of the screen.
	X int `json:"qx,omitempty"`
	// y-coordinate in pixels.
	// The origin is the top left of the screen.
	Y int `json:"qy,omitempty"`
}

type ProgressData struct {
	// True if the request is started.
	Started bool `json:"qStarted,omitempty"`
	// True if the request is finished.
	Finished bool `json:"qFinished,omitempty"`
	// This property is not used.
	Completed int `json:"qCompleted,omitempty"`
	// This property is not used.
	Total int `json:"qTotal,omitempty"`
	// This property is not used.
	KB int `json:"qKB,omitempty"`
	// Request duration in milliseconds.
	Millisecs int `json:"qMillisecs,omitempty"`
	// True when the engine pauses the script execution and waits for a user interaction.
	UserInteractionWanted bool `json:"qUserInteractionWanted,omitempty"`
	// A progress message is persistent when it informs about the start or end of a statement. For example, it can inform about the total number of lines fetched from a data source or tell that the app was saved. All persistent progress messages between two *GetProgress* calls are summarized in this string. Contrarily to *qPersistentProgressMessages*, the content of the localized message string is displayed (not its message code).
	PersistentProgress string `json:"qPersistentProgress,omitempty"`
	// A progress message is transient when it informs about the progress of an ongoing statement. For example, it can tell how many lines are currently fetched from a data source. All transient progress messages between two *GetProgress* calls are summarized in this string. Contrarily to *qTransientProgressMessage*, the content of the localized message string is displayed (not its message code).
	TransientProgress string `json:"qTransientProgress,omitempty"`
	// Information about the error messages that occur during the script execution.
	ErrorData []*ErrorData `json:"qErrorData,omitempty"`
	// List of persistent progress messages.
	PersistentProgressMessages []*ProgressMessage `json:"qPersistentProgressMessages,omitempty"`
	// Transient progress message.
	TransientProgressMessage *ProgressMessage `json:"qTransientProgressMessage,omitempty"`
}

type ProgressMessage struct {
	// Code number to the corresponding localized message string.
	MessageCode int `json:"qMessageCode,omitempty"`
	// Parameters to be inserted in the localized message string.
	MessageParameters []string `json:"qMessageParameters,omitempty"`
}

type Range struct {
	// Lowest value in the range
	Min Float64 `json:"qMin,omitempty"`
	// Highest value in the range
	Max Float64 `json:"qMax,omitempty"`
	// If set to true, the range includes the lowest value in the range of selections (Equals to ). [bn(50500)]
	// Example:
	// The range is [1,10]. If qMinInclEq is set to true it means that 1 is included in the range of selections.
	MinInclEq bool `json:"qMinInclEq,omitempty"`
	// If set to true, the range includes the highest value in the range of selections (Equals to ). [bn(50500)]
	// Example:
	// The range is [1,10]. If qMinInclEq is set to true it means that 10 is included in the range of selections.
	MaxInclEq bool `json:"qMaxInclEq,omitempty"`
}

type RangeSelectInfo struct {
	// Lowest value in the range.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	RangeLo *Float64 `json:"qRangeLo,omitempty"`
	// Highest value in the range.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	RangeHi *Float64 `json:"qRangeHi,omitempty"`
	// Label of the measure.
	Measure string `json:"qMeasure,omitempty"`
}

type Rect struct {
	// Position from the left.
	// Corresponds to the first column.
	Left int `json:"qLeft,omitempty"`
	// Position from the top.
	// Corresponds to the first row.
	Top int `json:"qTop,omitempty"`
	// Number of columns in the page. The indexing of the columns may vary depending on whether the cells are expanded or not (parameter qAlwaysFullyExpanded in HyperCubeDef ).
	Width int `json:"qWidth,omitempty"`
	// Number of rows or elements in the page. The indexing of the rows may vary depending on whether the cells are expanded or not (parameter qAlwaysFullyExpanded in HyperCubeDef ).
	Height int `json:"qHeight,omitempty"`
}

type SampleResult struct {
	// Name of field or column.
	FieldOrColumn *FieldOrColumn `json:"qFieldOrColumn,omitempty"`
	// Matched values part of the sample.
	Values []*FieldValue `json:"qValues,omitempty"`
}

type ScriptSyntaxError struct {
	// Length of the word where the error is located.
	ErrLen int `json:"qErrLen,omitempty"`
	// Number of the faulty section.
	TabIx int `json:"qTabIx,omitempty"`
	// Line number in the section where the error is located.
	LineInTab int `json:"qLineInTab,omitempty"`
	// Position of the erroneous text from the beginning of the line.
	ColInLine int `json:"qColInLine,omitempty"`
	// Position of the erroneous text from the beginning of the script.
	TextPos int `json:"qTextPos,omitempty"`
	// The default value is false.
	SecondaryFailure bool `json:"qSecondaryFailure,omitempty"`
}

type SearchAssociationResult struct {
	// List of the fields that contains search associations.
	FieldNames []string `json:"qFieldNames,omitempty"`
	// List of the search terms.
	SearchTerms []string `json:"qSearchTerms,omitempty"`
	// Information about the fields containing search hits.
	FieldDictionaries []*SearchFieldDictionary `json:"qFieldDictionaries,omitempty"`
	// List of search results.
	// The maximum number of search results in this list is set by qPage/qCount .
	SearchTermsMatched []SearchMatchCombinations `json:"qSearchTermsMatched,omitempty"`
	// Total number of search results.
	// This number is not limited by qPage/qCount .
	TotalSearchResults int `json:"qTotalSearchResults,omitempty"`
}

type SearchAttribute struct {
	// String corresponding to SearchObjectOptions.qAttributes. It will be qProperty for SearchObjectOptions.
	Key string `json:"qKey,omitempty"`
	// String corresponding to qKey for the current SearchGroupItemMatch. For example, if the match is Make by Price found in the title of a generic object, qValue will be qMetaDef/title.
	Value string `json:"qValue,omitempty"`
}

type SearchCharRange struct {
	// Starting position of the match in the search result, starting from 0.
	CharPos int `json:"qCharPos,omitempty"`
	// Length of the match in the search result.
	CharCount int `json:"qCharCount,omitempty"`
	// Position of the term in the list of search terms, starting from 0.
	Term int `json:"qTerm,omitempty"`
}

type SearchCombinationOptions struct {
	// List of the search fields.
	// If empty, the search is performed in all fields of the app.
	SearchFields []string `json:"qSearchFields,omitempty"`
	// Search context.
	// The default value is LockedFieldsOnly .
	//
	// One of:
	//
	// • Cleared or CONTEXT_CLEARED
	//
	// • LockedFieldsOnly or CONTEXT_LOCKED_FIELDS_ONLY
	//
	// • CurrentSelections or CONTEXT_CURRENT_SELECTIONS
	Context SearchContextType `json:"qContext,omitempty"`
	// Encoding used to compute qRanges of type SearchCharRange.
	// Only affects the computation of the ranges. It does not impact the encoding of the text.
	//
	// One of:
	//
	// • Utf8 or CHAR_ENCODING_UTF8
	//
	// • Utf16 or CHAR_ENCODING_UTF16
	CharEncoding CharEncodingType `json:"qCharEncoding,omitempty"`
	// Optional.
	//
	// • For SearchSuggest method, this array is empty.
	//
	// • For SearchObjects method, this array is empty or contain qProperty .
	//
	// • For SearchResults method, this array is empty, or contains qNum and/or qElemNum . It allows the user to request details in the outputted SearchGroupItemMatch . For more information, see SearchGroupItemMatch.
	Attributes []string `json:"qAttributes,omitempty"`
}

type SearchContextType string

func (t SearchContextType) String() string {
	return string(t)
}

func (t SearchContextType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type SearchFieldDictionary struct {
	// Position of the field in the list of fields, starting from 0.
	// The list of fields is defined in qResults/qFieldNames and contains the search associations.
	Field int `json:"qField,omitempty"`
	// List of the matching values.
	// The maximum number of values in this list is set by qMaxNbrFieldMatches .
	Result []*SearchTermResult `json:"qResult,omitempty"`
}

type SearchFieldMatch struct {
	// Position of the field in the list of fields, starting from 0.
	// The list of fields is defined in qResults/qFieldNames and contains the search associations.
	Field int `json:"qField,omitempty"`
	// Positions of the matching values in the search results.
	// The maximum number of values in this list is defined by qMaxNbrFieldMatches .
	Values []int `json:"qValues,omitempty"`
	// Positions of the search terms, starting from 0.
	Terms []int `json:"qTerms,omitempty"`
	// Number of search hits in the field.
	// The number of values in qValues and the value of qNoOfMatches are equal if qMaxNbrFieldMatches is -1.
	NoOfMatches int `json:"qNoOfMatches,omitempty"`
}

type SearchFieldSelectionMode string

func (t SearchFieldSelectionMode) String() string {
	return string(t)
}

func (t SearchFieldSelectionMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type SearchGroup struct {
	// Identifier of the search group.
	Id int `json:"qId,omitempty"`
	// Type of the search group.
	//
	// One of:
	//
	// • DatasetType or DATASET_GROUP
	//
	// • GenericObjectsType or GENERIC_OBJECTS_GROUP
	GroupType SearchGroupType `json:"qGroupType,omitempty"`
	// Indexes of the search terms that are included in the group. These search terms are related to the list of terms defined in SearchResult.qSearchTerms .
	SearchTermsMatched []int `json:"qSearchTermsMatched,omitempty"`
	// Total number of distinct items in the search group.
	TotalNumberOfItems int `json:"qTotalNumberOfItems,omitempty"`
	// List of items in the search group.
	// The group items are numbered from the value of SearchGroupOptions.qOffset to the value of SearchGroupOptions.qOffset \+ SearchGroupOptions.qCount
	Items []*SearchGroupItem `json:"qItems,omitempty"`
}

type SearchGroupItem struct {
	// Type of the group item.
	//
	// One of:
	//
	// • Field or FIELD
	//
	// • GenericObject or GENERIC_OBJECT
	ItemType SearchGroupItemType `json:"qItemType,omitempty"`
	// Total number of distinct matches in the search group item.
	TotalNumberOfMatches int `json:"qTotalNumberOfMatches,omitempty"`
	// Identifier of the item.
	// It corresponds to:
	//
	// • The name of the field, if the type of the search group is data set.
	//
	// • The id of the generic object if the type of the search group is generic object.
	Identifier string `json:"qIdentifier,omitempty"`
	// List of matches in the search group item.
	// The group item matches are numbered from the value of SearchGroupItemOptions.qOffset to the value of SearchGroupItemOptions.qOffset \+ SearchGroupItemOptions.qCount .
	ItemMatches []*SearchGroupItemMatch `json:"qItemMatches,omitempty"`
	// Indexes of the search terms that are included in the group item. These search terms are related to the list of terms defined in SearchResult.qSearchTerms .
	SearchTermsMatched []int `json:"qSearchTermsMatched,omitempty"`
}

type SearchGroupItemMatch struct {
	// Search match value.
	// Value of the search group item.
	// If the match is found in a field, it corresponds to the value of the field.
	// If the match is found in a generic object property, it corresponds to the property value.
	Text string `json:"qText,omitempty"`
	// Selection mode of a field.
	// Suppressed by default. One and always one field value is selected when set to OneAndOnlyOne.
	FieldSelectionMode []SearchFieldSelectionMode `json:"qFieldSelectionMode,omitempty"`
	// List of ranges.
	// For example, if the search terms are Price and Make, and the search group item value is Make by Price vs Mileage, then there are two ranges: one for Price and one for Make.
	Ranges []*SearchCharRange `json:"qRanges,omitempty"`
	// Provides detail of the match as requested by the user in SearchObjectsOptions.qAttributes or SearchCombinationOptions.qAttributes
	// If the user requests SearchObjects or SearchResults with an empty qAttributes option, the outputted qAttributes is returned empty.
	// For SearchObjects requested with qProperty , the SearchGroupItemMatch.qAttributes return value contains [“qProperty”, "qMetaDef/title”] if the match has been found in the title of the item. For dimension values, the returned qProperty will be “*” .
	// For SearchResults requested with qNum , the SearchGroupItemMatch.qAttributes return value contains ["qNum", N] where N is the numeric value of the element or NaN if the value is not numeric.
	// For SearchResults requested with qElemNum , the SearchGroupItemMatch.qAttributes return value contains ["qElemNum", N] where N is the value index of the element.
	Attributes []*SearchAttribute `json:"qAttributes,omitempty"`
}

type SearchGroupItemOptions struct {
	// Type of the group item. Can be:
	//
	// • GenericObject: the type of the search group item is a generic object. Group items have this type when you are calling SearchObjects .
	//
	// • Field: the type of the search group item is a field. Group items have this type when you are calling SearchResults .
	//
	// One of:
	//
	// • Field or FIELD
	//
	// • GenericObject or GENERIC_OBJECT
	GroupItemType SearchGroupItemType `json:"qGroupItemType,omitempty"`
	// Position starting from 0.
	// The default value is 0.
	Offset int `json:"qOffset,omitempty"`
	// Maximum number of matches per item (in qItemMatches[ ] ).
	// The default value is -1: all values are returned.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	Count *int `json:"qCount,omitempty"`
}

type SearchGroupItemType string

func (t SearchGroupItemType) String() string {
	return string(t)
}

func (t SearchGroupItemType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type SearchGroupOptions struct {
	// Type of the group. Can be:
	//
	// • GenericObjectType: the type of the search group item is a generic object. Groups have this type when you are calling SearchObjects .
	//
	// • DatasetType: type of the search group item is a dataset association. Groups have this type when you are calling SearchResults .
	//
	// One of:
	//
	// • DatasetType or DATASET_GROUP
	//
	// • GenericObjectsType or GENERIC_OBJECTS_GROUP
	GroupType SearchGroupType `json:"qGroupType,omitempty"`
	// Position starting from 0.
	// The default value is 0.
	Offset int `json:"qOffset,omitempty"`
	// Maximum number of items per group (in qItems[ ] ).
	// The default value is -1; all values are returned.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	Count *int `json:"qCount,omitempty"`
}

type SearchGroupType string

func (t SearchGroupType) String() string {
	return string(t)
}

func (t SearchGroupType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type SearchMatchCombination struct {
	// Index of the search result, starting from 0.
	Id int `json:"qId,omitempty"`
	// Information about the search matches.
	FieldMatches []*SearchFieldMatch `json:"qFieldMatches,omitempty"`
}

type SearchMatchCombinations []*SearchMatchCombination

type SearchObjectOptions struct {
	// This array is either empty or contains qProperty .
	Attributes []string `json:"qAttributes,omitempty"`
	// Encoding used to compute qRanges of type SearchCharRange.
	// Only affects the computation of the ranges. It does not impact the encoding of the text.
	//
	// One of:
	//
	// • Utf8 or CHAR_ENCODING_UTF8
	//
	// • Utf16 or CHAR_ENCODING_UTF16
	CharEncoding CharEncodingType `json:"qCharEncoding,omitempty"`
}

type SearchPage struct {
	// Position from the top, starting from 0.
	// If the offset is set to 0, the first search result to be returned is at position 0.
	Offset int `json:"qOffset,omitempty"`
	// Number of search groups to return (in qSearchGroupArray ).
	Count int `json:"qCount,omitempty"`
	// Maximum number of matching values to return per search result.
	// The default value is -1; all values are returned.
	// This property is to be used with the SearchAssociations method.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	MaxNbrFieldMatches *int `json:"qMaxNbrFieldMatches,omitempty"`
	// Options of the search groups.
	// If this property is not set, all values are returned.
	// This property is to be used with the SearchResults method or the SearchObjects method.
	GroupOptions []*SearchGroupOptions `json:"qGroupOptions,omitempty"`
	// Options of the search group items.
	// If this property is not set, all values are returned.
	// This property is to be used with the SearchResults method or the SearchObjects method.
	GroupItemOptions []*SearchGroupItemOptions `json:"qGroupItemOptions,omitempty"`
}

type SearchResult struct {
	// List of the search terms.
	SearchTerms []string `json:"qSearchTerms,omitempty"`
	// Total number of groups.
	TotalNumberOfGroups int `json:"qTotalNumberOfGroups,omitempty"`
	// List of search groups.
	// The groups are numbered from the value of SearchPage.qOffset to the value of SearchPage.qOffset + SearchPage.qCount .
	SearchGroupArray []*SearchGroup `json:"qSearchGroupArray,omitempty"`
}

type SearchSuggestItem struct {
	// Value of the suggestion.
	Value string `json:"qValue,omitempty"`
	// Index of the suggestion value.
	// The indexing starts from 0 and from the left.
	Term int `json:"qTerm,omitempty"`
}

type SearchSuggestionResult struct {
	// List of suggestions.
	Suggestions []*SearchSuggestItem `json:"qSuggestions,omitempty"`
	// List of field names that contain search hits.
	FieldNames []string `json:"qFieldNames,omitempty"`
}

type SearchTermResult struct {
	// Text of the associated value.
	Text string `json:"qText,omitempty"`
	// Element number of the associated value.
	ElemNumber int `json:"qElemNumber,omitempty"`
	// List of ranges.
	// For example, if the user searches the term read and the associative value is Reading , then the corresponding range would be Read in Reading .
	Ranges []*SearchCharRange `json:"qRanges,omitempty"`
}

type SelectInfo struct {
	// Text search string.
	// Everything that matches the text is selected.
	// This parameter is optional.
	TextSearch string `json:"qTextSearch,omitempty"`
	// Lower value of the search range.
	// This parameter is used when performing range selections or text searches in dimensions.
	// Default is Null.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	RangeLo *Float64 `json:"qRangeLo,omitempty"`
	// Highest value of the search range.
	// This parameter is used when performing range selections or text searches in dimensions.
	// Default is Null.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	RangeHi *Float64 `json:"qRangeHi,omitempty"`
	// Gives information about the formatting of the range.
	// This parameter is used when performing range selections or text searches in dimensions.
	NumberFormat *FieldAttributes `json:"qNumberFormat,omitempty"`
	// This parameter is used when performing range selections or text searches in measures.
	// Gives information about the range of selections.
	RangeInfo []*RangeSelectInfo `json:"qRangeInfo,omitempty"`
	// Set to true to ignore locks; in that case, locked fields can be selected.
	// The default value is false.
	SoftLock bool `json:"qSoftLock,omitempty"`
	// List of information about ranges for selections.
	ContinuousRangeInfo []*Range `json:"qContinuousRangeInfo,omitempty"`
	// This parameter is true if the TextSearch is a result of a Select Field operation.
	SelectFieldSearch bool `json:"qSelectFieldSearch,omitempty"`
}

// Indicates which selections are currently applied. It gives the current selections. Is the layout for SelectionObjectDef.
type SelectionObject struct {
	// Number of steps back.
	BackCount int `json:"qBackCount,omitempty"`
	// Number of steps forward.
	ForwardCount int `json:"qForwardCount,omitempty"`
	// Lists the fields that are selected.
	Selections []*NxCurrentSelectionItem `json:"qSelections,omitempty"`
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
}

// To display the current selections.
// Can be added to any generic object but is particularly meaningful when using session objects to monitor an app.
//
// Properties:
//
// "qSelectionObjectDef": {}
type SelectionObjectDef struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
}

type Size struct {
	// Number of pixels on the x axis.
	Cx int `json:"qcx,omitempty"`
	// Number of pixels on the y axis.
	Cy int `json:"qcy,omitempty"`
}

type SortCriteria struct {
	// Sorts the field values according to their logical state (selected, optional, alternative or excluded).
	SortByState int `json:"qSortByState,omitempty"`
	// Sorts the field values by frequency (number of occurrences in the field).
	SortByFrequency int `json:"qSortByFrequency,omitempty"`
	// Sorts the field values by numeric value.
	SortByNumeric int `json:"qSortByNumeric,omitempty"`
	// Sorts the field by alphabetical order.
	SortByAscii int `json:"qSortByAscii,omitempty"`
	// Sorts the field values by the initial load order.
	SortByLoadOrder int `json:"qSortByLoadOrder,omitempty"`
	// Sorts the field by expression.
	SortByExpression int `json:"qSortByExpression,omitempty"`
	// Sort by expression.
	Expression     *ValueExpr `json:"qExpression,omitempty"`
	SortByGreyness int        `json:"qSortByGreyness,omitempty"`
}

type SourceKeyRecord struct {
	// Name of the key field.
	KeyFields []string `json:"qKeyFields,omitempty"`
	// Table the key belongs to.
	Tables []string `json:"qTables,omitempty"`
}

type StateEnumType string

func (t StateEnumType) String() string {
	return string(t)
}

func (t StateEnumType) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

type StaticContentList struct {
	// Information about the list of content files.
	Items []*StaticContentListItem `json:"qItems,omitempty"`
}

// In addition, this structure can return dynamic properties.
type StaticContentListItem struct {
	// Relative path to the content file. The URL is static.
	// In Qlik Sense Enterprise, content files located:
	//
	// • In the /content/ <content library name>/ folder are part of a global content library.
	//
	// • In the /appcontent/ folder are part of the app specific library.
	// The content files are never embedded in the qvf file.
	// In Qlik Sense Desktop, content files located:
	//
	// • In the /content/default/ folder are outside the qvf file.
	//
	// • In the /media/ folder are embedded in the qvf file.
	UrlDef string `json:"qUrlDef,omitempty"`
	// Relative path to the content file. The URL is static.
	// In Qlik Sense Enterprise, content files located:
	//
	// • In the /content/ <content library name>/ folder are part of a global content library.
	//
	// • In the /appcontent/ folder are part of the app specific library.
	// The content files are never embedded in the qvf file.
	// In Qlik Sense Desktop, content files located:
	//
	// • In the /content/default/ folder are outside the qvf file.
	//
	// • In the /media/ folder are embedded in the qvf file.
	Url string `json:"qUrl,omitempty"`
}

// In addition, this structure can return dynamic properties.
type StaticContentUrl struct {
	// Relative path of the thumbnail.
	Url string `json:"qUrl,omitempty"`
}

// In addition, this structure can contain dynamic properties.
type StaticContentUrlDef struct {
	// Relative path of the thumbnail.
	Url string `json:"qUrl,omitempty"`
}

type StringExpr struct {
	// Expression evaluated to string.
	V string `json:"qv,omitempty"`
}

// Properties:
//
// Abbreviated syntax:
// "qStringExpression":"=<expression>"
// Extended object syntax:
// "qStringExpression":{"qExpr":"=<expression>"}
// Where:
//
// • < expression > is a string
//
// The "=" sign in the string expression is not mandatory. Even if the "=" sign is not given, the expression is evaluated.
// A string expression is not evaluated, if the expression is surrounded by simple quotes.
//
// The result of the evaluation of the expression can be of any type, as it is returned as a JSON (quoted) string.
type StringExpression struct {
	Expr string `json:"qExpr,omitempty"`
}

type TableRecord struct {
	// Name of the table.
	Name string `json:"qName,omitempty"`
	// This property is set to true if the table is loose.
	Loose bool `json:"qLoose,omitempty"`
	// Number of rows in the table.
	NoOfRows int `json:"qNoOfRows,omitempty"`
	// Information about the fields in the table.
	Fields []*FieldInTableData `json:"qFields,omitempty"`
	// Information about the position of the table.
	Pos *Point `json:"qPos,omitempty"`
	// Comment related to the table.
	Comment string `json:"qComment,omitempty"`
	// If set to true, Direct Discovery is used.
	// Direct Discovery fields are not loaded into memory and remain in the external database.
	IsDirectDiscovery bool `json:"qIsDirectDiscovery,omitempty"`
	// This property is set to true if the table contains a synthetic key.
	IsSynthetic bool `json:"qIsSynthetic,omitempty"`
}

type TableRow struct {
	// Array of field values.
	Value []*FieldValue `json:"qValue,omitempty"`
}

type TableViewBroomPointSaveInfo struct {
	// Information about the position of the broom point.
	Pos *Point `json:"qPos,omitempty"`
	// Name of the table.
	Table string `json:"qTable,omitempty"`
	// List of fields in the table.
	Fields []string `json:"qFields,omitempty"`
}

type TableViewConnectionPointSaveInfo struct {
	// Information about the position of the connection point.
	Pos *Point `json:"qPos,omitempty"`
	// List of the fields in the table.
	Fields []string `json:"qFields,omitempty"`
}

type TableViewCtlSaveInfo struct {
	// Internal view mode.
	InternalView *TableViewSaveInfo `json:"qInternalView,omitempty"`
	// Source view mode.
	SourceView *TableViewSaveInfo `json:"qSourceView,omitempty"`
}

type TableViewDlgSaveInfo struct {
	// Information about the position of the dialog window.
	// Not used in Qlik Sense.
	Pos *Rect `json:"qPos,omitempty"`
	// Set of data for internal and source view modes.
	CtlInfo *TableViewCtlSaveInfo `json:"qCtlInfo,omitempty"`
	// View mode to display when opening Qlik Sense data model viewer.
	// One of:
	//
	// • 0 for internal view mode.
	//
	// • 1 for source view mode.
	Mode int `json:"qMode,omitempty"`
}

type TableViewSaveInfo struct {
	// List of the tables in the database model viewer.
	Tables []*TableViewTableWinSaveInfo `json:"qTables,omitempty"`
	// List of the broom points in the database model viewer.
	// Not used in Qlik Sense.
	BroomPoints []*TableViewBroomPointSaveInfo `json:"qBroomPoints,omitempty"`
	// List of connection points in the database model viewer.
	// Not used in Qlik Sense.
	ConnectionPoints []*TableViewConnectionPointSaveInfo `json:"qConnectionPoints,omitempty"`
	// Zoom factor in the database model viewer.
	// The default value is 1.0.
	// When set to nil the default value is used, when set to point at a value that value is used (including golang zero values)
	ZoomFactor *Float64 `json:"qZoomFactor,omitempty"`
}

type TableViewTableWinSaveInfo struct {
	// Information about the position of the table.
	Pos *Rect `json:"qPos,omitempty"`
	// Table name.
	Caption string `json:"qCaption,omitempty"`
}

type TextMacro struct {
	// Name of the variable.
	Tag string `json:"qTag,omitempty"`
	// Order in which the variable was referenced during the script execution.
	// The same number sequence is used for both qRefSeqNo and qSetSeqNo .
	RefSeqNo int `json:"qRefSeqNo,omitempty"`
	// Order in which the variable was updated during the script execution.
	// The same number sequence is used for both qRefSeqNo and qSetSeqNo .
	SetSeqNo int `json:"qSetSeqNo,omitempty"`
	// Variable value.
	DisplayString string `json:"qDisplayString,omitempty"`
	// Is set to true if the variable is a system variable.
	IsSystem bool `json:"qIsSystem,omitempty"`
	// Is set to true if the variable is a reserved variable.
	IsReserved bool `json:"qIsReserved,omitempty"`
}

type TotalMode string

func (t TotalMode) String() string {
	return string(t)
}

func (t TotalMode) MarshalText() ([]byte, error) {
	err := validateArg(t)
	return []byte(t), err
}

// Renders the properties of a TreeData object. Is the layout for TreeDataDef.
// For more information about the definition of TreeData, see Generic object.
// To retrieve data from the TreeData object, use the method called GetHyperCubeTreeData.
type TreeData struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// The total number of nodes on each dimension.
	NodesOnDim []int `json:"qNodesOnDim,omitempty"`
	// This parameter is optional and is displayed in case of error.
	Error *NxValidationError `json:"qError,omitempty"`
	// Information on the dimension.
	DimensionInfo []*NxTreeDimensionInfo `json:"qDimensionInfo,omitempty"`
	// Defines the order of the dimenion levels/columns in the TreeData object.
	// Column numbers are separated by a comma.
	// Example: [1,0,2] means that the first level in the tree structure is dimension 1, followed by dimension 0 and dimension 2.
	EffectiveInterColumnSortOrder []int `json:"qEffectiveInterColumnSortOrder,omitempty"`
	// True if other row exists.
	HasOtherValues bool `json:"qHasOtherValues,omitempty"`
	// Title of the TreeData object, for example the title of a chart.
	Title string `json:"qTitle,omitempty"`
	// Position of the last expended cell.
	// This property is optional.
	LastExpandedPos *NxCellPosition `json:"qLastExpandedPos,omitempty"`
	// The message displayed if calculation condition is not fulfilled.
	CalcCondMsg string `json:"qCalcCondMsg,omitempty"`
	// Set of data.
	// Is empty if nothing has been defined in qInitialDataFetch in TreeDataDef.
	TreeDataPages []*NxTreeNode `json:"qTreeDataPages,omitempty"`
}

// Defines the properties of a TreeData object.
// For more information about the definition of a TreeData object, see Generic object.
type TreeDataDef struct {
	// Name of the alternate state.
	// Default is current selections $ .
	StateName string `json:"qStateName,omitempty"`
	// Array of dimensions.
	Dimensions []*NxTreeDimensionDef `json:"qDimensions,omitempty"`
	// Defines the order of the dimension levels/columns in the TreeData object.
	// Column numbers are separated by a comma.
	// Example: [1,0,2] means that the first level in the tree structure is dimension 1, followed by dimension 0 and dimension 2.
	// The default sort order is the order in which the dimensions and measures have been defined in the TreeDataDef.
	InterColumnSortOrder []int `json:"qInterColumnSortOrder,omitempty"`
	// Removes zero values.
	SuppressZero bool `json:"qSuppressZero,omitempty"`
	// Removes missing values.
	SuppressMissing bool `json:"qSuppressMissing,omitempty"`
	// If this property is set to true, the cells are opened expanded. The default value is false.
	OpenFullyExpanded bool `json:"qOpenFullyExpanded,omitempty"`
	// If this property is set to true, the missing symbols (if any) are replaced by 0 if the value is a numeric and by an empty string if the value is a string.
	// The default value is false.
	PopulateMissing bool `json:"qPopulateMissing,omitempty"`
	// Specifies a calculation condition object.
	// If CalcCondition.Cond is not fulfilled, the TreeData is excluded from the calculation and CalcCondition.Msg is evaluated.
	// By default, there is no calculation condition.
	// This property is optional.
	CalcCondition *NxCalcCond `json:"qCalcCondition,omitempty"`
	// Title of the TreeData object, for example the title of a chart.
	Title *StringExpr `json:"qTitle,omitempty"`
	// Initial data set.
	// This property is optional.
	InitialDataFetch []*NxTreeDataOption `json:"qInitialDataFetch,omitempty"`
}

// Displays information about the number of possible undos and redos. Is the layout for UndoInfoDef.
type UndoInfo struct {
	// Number of possible undos.
	UndoCount int `json:"qUndoCount,omitempty"`
	// Number of possible redos.
	RedoCount int `json:"qRedoCount,omitempty"`
}

// Defines if an object should contain information on the number of possible undo and redo.
//
// Properties:
//
// "qUndoInfoDef": {}
// The numbers of undos and redos are empty when an object is created. The number of possible undos is increased every time an action (for example, create a child, set some properties) on the object is performed. The number of possible redos is increased every time an undo action is performed.
type UndoInfoDef struct {
}

type ValueExpr struct {
	// Expression evaluated to dual.
	V string `json:"qv,omitempty"`
}

// Properties:
//
// Abbreviated syntax:
// "qValueExpression":"=<expression>"
// Extended object syntax:
// "qValueExpression":{"qExpr":"=<expression>"}
// Where:
//
// • < expression > is a string.
//
// The "=" sign in the value expression is not mandatory. Even if the "=" sign is not given, the expression is evaluated.
//
// The expression is evaluated as a numeric.
type ValueExpression struct {
	Expr string `json:"qExpr,omitempty"`
}

// Lists the variables in an app. Is the layout for VariableListDef.
type VariableList struct {
	// List of the variables.
	Items []*NxVariableListItem `json:"qItems,omitempty"`
}

// Defines the list of variables in an app.
type VariableListDef struct {
	// Type of variables to include in the list.
	Type string `json:"qType,omitempty"`
	// Shows the reserved variables if set to true.
	ShowReserved bool `json:"qShowReserved,omitempty"`
	// Shows the system variables if set to true.
	ShowConfig bool `json:"qShowConfig,omitempty"`
	// Data
	Data json.RawMessage `json:"qData,omitempty"`
	// Shows the session variables if set to true.
	ShowSession bool `json:"qShowSession,omitempty"`
}

type Doc struct {
	*RemoteObject
}

// Aborts any selection mode in an app. For more information about selection mode, see BeginSelections method.
//
// Parameters:
//
// ◾ accept   -   Set this parameter to true to accept the selections before exiting the selection mode.
//
func (obj *Doc) AbortModal(ctx context.Context, accept bool) error {
	err := obj.rpc(ctx, "AbortModal", nil, accept)
	return err
}

// Adds an alternate state in the app.
// You can create multiple states within a Qlik Sense app and apply these states to specific objects within the app. Objects in a given state are not affected by user selections in the other states.
//
// Parameters:
//
// ◾ stateName   -   Name of the alternate state.
//
func (obj *Doc) AddAlternateState(ctx context.Context, stateName string) error {
	err := obj.rpc(ctx, "AddAlternateState", nil, stateName)
	return err
}

// Adds a field on the fly.
// The expression of a field on the fly is persisted but not its values.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ name   -   Name of the field.
//
// ◾ expr   -   Expression value.
// It is not possible to use all aggregation functions. For example, you cannot add a field on the fly with an expression that uses the Sum or Count aggregation functions.
//
func (obj *Doc) AddFieldFromExpression(ctx context.Context, name string, expr string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "AddFieldFromExpression", result, name, expr)
	return result.Success, err
}

// Applies a bookmark.
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the bookmark.
//
func (obj *Doc) ApplyBookmark(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "ApplyBookmark", result, id)
	return result.Success, err
}

// Loads the last logical operation (if any).
func (obj *Doc) Back(ctx context.Context) error {
	err := obj.rpc(ctx, "Back", nil)
	return err
}

// Returns the number of entries on the back stack.
func (obj *Doc) BackCount(ctx context.Context) (int, error) {
	result := &struct {
		Return int `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "BackCount", result)
	return result.Return, err
}

// Checks if a given expression is valid.
// The expression is correct if the parameters qErrorMsg , qBadFieldNames and qDangerousFieldNames are empty.
//
// Parameters:
//
// ◾ expr     -   Expression to check.
//
// ◾ labels   -   List of labels.
//
func (obj *Doc) CheckExpression(ctx context.Context, expr string, labels []string) (string, []*NxRange, []*NxRange, error) {
	result := &struct {
		ErrorMsg            string     `json:"qErrorMsg"`
		BadFieldNames       []*NxRange `json:"qBadFieldNames"`
		DangerousFieldNames []*NxRange `json:"qDangerousFieldNames"`
	}{}
	err := obj.rpc(ctx, "CheckExpression", result, expr, labels)
	return result.ErrorMsg, result.BadFieldNames, result.DangerousFieldNames, err
}

// Checks if a given expression is valid.
// The expression is correct if the parameters qErrorMsg , qBadFieldNames and qDangerousFieldNames are empty.
//
// Parameters:
//
// ◾ expr     -   Expression to check.
//
// ◾ labels   -   List of labels.
//
func (obj *Doc) CheckExpressionRaw(ctx context.Context, expr string, labels []string) (string, json.RawMessage, json.RawMessage, error) {
	result := &struct {
		ErrorMsg            string          `json:"qErrorMsg"`
		BadFieldNames       json.RawMessage `json:"qBadFieldNames"`
		DangerousFieldNames json.RawMessage `json:"qDangerousFieldNames"`
	}{}
	err := obj.rpc(ctx, "CheckExpression", result, ensureEncodable(expr), ensureEncodable(labels))
	return result.ErrorMsg, result.BadFieldNames, result.DangerousFieldNames, err
}

// Checks if:
//
// • A given expression is valid.
//
// • A number is correct according to the locale.
//
// Parameters:
//
// ◾ expr   -   Expression to check.
//
func (obj *Doc) CheckNumberOrExpression(ctx context.Context, expr string) (string, []*NxRange, error) {
	result := &struct {
		ErrorMsg      string     `json:"qErrorMsg"`
		BadFieldNames []*NxRange `json:"qBadFieldNames"`
	}{}
	err := obj.rpc(ctx, "CheckNumberOrExpression", result, expr)
	return result.ErrorMsg, result.BadFieldNames, err
}

// Checks if:
//
// • A given expression is valid.
//
// • A number is correct according to the locale.
//
// Parameters:
//
// ◾ expr   -   Expression to check.
//
func (obj *Doc) CheckNumberOrExpressionRaw(ctx context.Context, expr string) (string, json.RawMessage, error) {
	result := &struct {
		ErrorMsg      string          `json:"qErrorMsg"`
		BadFieldNames json.RawMessage `json:"qBadFieldNames"`
	}{}
	err := obj.rpc(ctx, "CheckNumberOrExpression", result, ensureEncodable(expr))
	return result.ErrorMsg, result.BadFieldNames, err
}

// Checks the syntax of a script.
//
// Example:
//
// "result": { "qErrors": [ { "qErrLen": 3, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 0, "qTextPos": 0 }, { "qErrLen": 5, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 1, "qTextPos": 4, "qSecondaryFailure": true } ] }
// The first area is the primary error area, the second area is the secondary error area. The second area is optional and is shown only if qSecondaryFailure is set to true. The second area ends when the next statement in the script begins.
//
// The list of syntax errors in the script.
// If there are no errors, the engine returns:
// If there are errors, the engine returns the following properties in the response:
//
//   +-------------------+--------------------------------+---------+
//   |       NAME        |          DESCRIPTION           |  TYPE   |
//   +-------------------+--------------------------------+---------+
//   | qErrLen           | Length of the word where the   | Integer |
//   |                   | error is located.              |         |
//   | qTabIx            | Number of the faulty section.  | Integer |
//   | qLineInTab        | Line number in the section     | Integer |
//   |                   | where the error is located.    |         |
//   | qColInLine        | Position of the erroneous      | Integer |
//   |                   | text from the beginning of the |         |
//   |                   | line.                          |         |
//   | qTextPos          | Position of the erroneous      | Integer |
//   |                   | text from the beginning of the |         |
//   |                   | script.                        |         |
//   | qSecondaryFailure | The default value is false.    | Boolean |
//   +-------------------+--------------------------------+---------+
func (obj *Doc) CheckScriptSyntax(ctx context.Context) ([]*ScriptSyntaxError, error) {
	result := &struct {
		Errors []*ScriptSyntaxError `json:"qErrors"`
	}{}
	err := obj.rpc(ctx, "CheckScriptSyntax", result)
	return result.Errors, err
}

// Checks the syntax of a script.
//
// Example:
//
// "result": { "qErrors": [ { "qErrLen": 3, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 0, "qTextPos": 0 }, { "qErrLen": 5, "qTabIx": 0, "qLineInTab": 0, "qColInLine": 1, "qTextPos": 4, "qSecondaryFailure": true } ] }
// The first area is the primary error area, the second area is the secondary error area. The second area is optional and is shown only if qSecondaryFailure is set to true. The second area ends when the next statement in the script begins.
//
// The list of syntax errors in the script.
// If there are no errors, the engine returns:
// If there are errors, the engine returns the following properties in the response:
//
//   +-------------------+--------------------------------+---------+
//   |       NAME        |          DESCRIPTION           |  TYPE   |
//   +-------------------+--------------------------------+---------+
//   | qErrLen           | Length of the word where the   | Integer |
//   |                   | error is located.              |         |
//   | qTabIx            | Number of the faulty section.  | Integer |
//   | qLineInTab        | Line number in the section     | Integer |
//   |                   | where the error is located.    |         |
//   | qColInLine        | Position of the erroneous      | Integer |
//   |                   | text from the beginning of the |         |
//   |                   | line.                          |         |
//   | qTextPos          | Position of the erroneous      | Integer |
//   |                   | text from the beginning of the |         |
//   |                   | script.                        |         |
//   | qSecondaryFailure | The default value is false.    | Boolean |
//   +-------------------+--------------------------------+---------+
func (obj *Doc) CheckScriptSyntaxRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Errors json.RawMessage `json:"qErrors"`
	}{}
	err := obj.rpc(ctx, "CheckScriptSyntax", result)
	return result.Errors, err
}

// Clear selections in fields for current state. Locked fields are not cleared by default.
//
// Parameters:
//
// ◾ lockedAlso   -   When true, clears the selection for locked fields.
//
// ◾ stateName    -   Alternate state name. When set, applies to alternate state instead of current
//
func (obj *Doc) ClearAll(ctx context.Context, lockedAlso bool, stateName string) error {
	err := obj.rpc(ctx, "ClearAll", nil, lockedAlso, stateName)
	return err
}

// Clears entirely the undo and redo buffer.
func (obj *Doc) ClearUndoBuffer(ctx context.Context) error {
	err := obj.rpc(ctx, "ClearUndoBuffer", nil)
	return err
}

// Clones a bookmark.
// The identifier is set by the engine.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to clone.
//
func (obj *Doc) CloneBookmark(ctx context.Context, id string) (string, error) {
	result := &struct {
		CloneId string `json:"qCloneId"`
	}{}
	err := obj.rpc(ctx, "CloneBookmark", result, id)
	return result.CloneId, err
}

// Clones a dimension.
//
// The identifier is set by the engine.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to clone.
//
func (obj *Doc) CloneDimension(ctx context.Context, id string) (string, error) {
	result := &struct {
		CloneId string `json:"qCloneId"`
	}{}
	err := obj.rpc(ctx, "CloneDimension", result, id)
	return result.CloneId, err
}

// Clones a measure.
//
// The identifier is set by the engine.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to clone.
//
func (obj *Doc) CloneMeasure(ctx context.Context, id string) (string, error) {
	result := &struct {
		CloneId string `json:"qCloneId"`
	}{}
	err := obj.rpc(ctx, "CloneMeasure", result, id)
	return result.CloneId, err
}

// Clones root level objects, such as sheets and stories. The CloneObject method works for both app objects and child objects.
// When you clone an object that contains children, the children are cloned as well.
// If you for example want to clone a visualization, you must provide the qID of the root object, in this case the sheet since CloneObject clones root level objects.
// It is not possible to clone a session object.
//
// The identifier is set by the engine.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to clone. The identifier must be a root object.
//
func (obj *Doc) CloneObject(ctx context.Context, id string) (string, error) {
	result := &struct {
		CloneId string `json:"qCloneId"`
	}{}
	err := obj.rpc(ctx, "CloneObject", result, id)
	return result.CloneId, err
}

// Commits the draft of an object that was previously created by invoking the CreateDraft method.
// Committing a draft replaces the corresponding published object.
//
// Parameters:
//
// ◾ id   -   Identifier of the draft to commit.
//
func (obj *Doc) CommitDraft(ctx context.Context, id string) error {
	err := obj.rpc(ctx, "CommitDraft", nil, id)
	return err
}

// Creates a bookmark.
//
// Parameters:
//
// ◾ prop   -   Properties for the object.
//
func (obj *Doc) CreateBookmark(ctx context.Context, prop *GenericBookmarkProperties) (*GenericBookmark, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateBookmark", result, prop)
	if err != nil {
		return nil, err
	}
	return &GenericBookmark{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a bookmark.
//
// Parameters:
//
// ◾ prop   -   Properties for the object.
//
func (obj *Doc) CreateBookmarkRaw(ctx context.Context, prop interface{}) (*GenericBookmark, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateBookmark", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &GenericBookmark{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a connection.
// A connection indicates from which data source the data should be taken.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Doc) CreateConnection(ctx context.Context, connection *Connection) (string, error) {
	result := &struct {
		ConnectionId string `json:"qConnectionId"`
	}{}
	err := obj.rpc(ctx, "CreateConnection", result, connection)
	return result.ConnectionId, err
}

// Creates a connection.
// A connection indicates from which data source the data should be taken.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Doc) CreateConnectionRaw(ctx context.Context, connection interface{}) (string, error) {
	result := &struct {
		ConnectionId string `json:"qConnectionId"`
	}{}
	err := obj.rpc(ctx, "CreateConnection", result, ensureEncodable(connection))
	return result.ConnectionId, err
}

// Creates a master dimension.
// A master dimension is stored in the library of an app and can be used in many objects. Several generic objects can contain the same dimension.
//
// Parameters:
//
// ◾ prop   -   Information about the properties.
//
func (obj *Doc) CreateDimension(ctx context.Context, prop *GenericDimensionProperties) (*GenericDimension, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateDimension", result, prop)
	if err != nil {
		return nil, err
	}
	return &GenericDimension{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a master dimension.
// A master dimension is stored in the library of an app and can be used in many objects. Several generic objects can contain the same dimension.
//
// Parameters:
//
// ◾ prop   -   Information about the properties.
//
func (obj *Doc) CreateDimensionRaw(ctx context.Context, prop interface{}) (*GenericDimension, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateDimension", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &GenericDimension{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a draft of an object.
// This method can be used to create a draft of a sheet or a story that is published. This is a way to continue working on a sheet or a story that is published.
// Replace the published object by the content of the draft by invoking the CommitDraft method.
//
// The identifier is set by the engine.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to create a draft from.
//
func (obj *Doc) CreateDraft(ctx context.Context, id string) (string, error) {
	result := &struct {
		DraftId string `json:"qDraftId"`
	}{}
	err := obj.rpc(ctx, "CreateDraft", result, id)
	return result.DraftId, err
}

// Creates a master measure.
// A master measure is stored in the library of an app and can be used in many objects. Several generic objects can contain the same measure.
//
// Parameters:
//
// ◾ prop   -   Information about the properties.
//
func (obj *Doc) CreateMeasure(ctx context.Context, prop *GenericMeasureProperties) (*GenericMeasure, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateMeasure", result, prop)
	if err != nil {
		return nil, err
	}
	return &GenericMeasure{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a master measure.
// A master measure is stored in the library of an app and can be used in many objects. Several generic objects can contain the same measure.
//
// Parameters:
//
// ◾ prop   -   Information about the properties.
//
func (obj *Doc) CreateMeasureRaw(ctx context.Context, prop interface{}) (*GenericMeasure, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateMeasure", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &GenericMeasure{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a generic object at app level. For more information on generic objects, see Generic object.
// It is possible to create a generic object that is linked to another object.
// A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
// The linked object has the same properties as the linking object.
// The linking object cannot be a transient object.
//
// Parameters:
//
// ◾ prop   -   Information about the object.
//
func (obj *Doc) CreateObject(ctx context.Context, prop *GenericObjectProperties) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateObject", result, prop)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a generic object at app level. For more information on generic objects, see Generic object.
// It is possible to create a generic object that is linked to another object.
// A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
// The linked object has the same properties as the linking object.
// The linking object cannot be a transient object.
//
// Parameters:
//
// ◾ prop   -   Information about the object.
//
func (obj *Doc) CreateObjectRaw(ctx context.Context, prop interface{}) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateObject", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a transient object. For example, you can use a transient object to create an app overview or a story overview.
// It is possible to create a transient object that is linked to another object.
// A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
// The linked object has the same properties as the linking object.
// The linking object cannot be a transient object.
//
// Parameters:
//
// ◾ prop   -   Information about the object.
//
func (obj *Doc) CreateSessionObject(ctx context.Context, prop *GenericObjectProperties) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionObject", result, prop)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a transient object. For example, you can use a transient object to create an app overview or a story overview.
// It is possible to create a transient object that is linked to another object.
// A linked object is an object that points to a linking object. The linking object is defined in the properties of the linked object (in qExtendsId ).
// The linked object has the same properties as the linking object.
// The linking object cannot be a transient object.
//
// Parameters:
//
// ◾ prop   -   Information about the object.
//
func (obj *Doc) CreateSessionObjectRaw(ctx context.Context, prop interface{}) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionObject", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a transient variable.
// To set some properties to the variable, use the SetProperties method.
//
// Definition:
//
// A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
// When a variable is used in an expression, it is substituted by its value or the variable's definition.
//
// Example:
//
// The variable x contains the text string Sum(Sales) .
// In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
// However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
//
// Parameters:
//
// ◾ prop   -   Name of the variable. Variable names are case sensitive.
//
func (obj *Doc) CreateSessionVariable(ctx context.Context, prop *GenericVariableProperties) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionVariable", result, prop)
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a transient variable.
// To set some properties to the variable, use the SetProperties method.
//
// Definition:
//
// A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
// When a variable is used in an expression, it is substituted by its value or the variable's definition.
//
// Example:
//
// The variable x contains the text string Sum(Sales) .
// In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
// However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
//
// Parameters:
//
// ◾ prop   -   Name of the variable. Variable names are case sensitive.
//
func (obj *Doc) CreateSessionVariableRaw(ctx context.Context, prop interface{}) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionVariable", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a variable.
//
// Parameters:
//
// ◾ name   -   Name of the variable. Variable names are case sensitive.
//
func (obj *Doc) CreateVariable(ctx context.Context, name string) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateVariable", result, name)
	return result.Return, err
}

// Creates a variable.
// To create a variable via a script, you need to use the SetScript method. For more information, see Create a variable.
// To set some properties to the variable, use the SetProperties method.
// In a published app, only transient variables can be created. See CreateSessionVariable method.
//
// Definition:
//
// A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
// When a variable is used in an expression, it is substituted by its value or the variable's definition.
//
// Example:
//
// The variable x contains the text string Sum(Sales) .
// In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
// However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
//
// Parameters:
//
// ◾ prop   -   Name of the variable. Variable names are case sensitive and must be unique.
//
func (obj *Doc) CreateVariableEx(ctx context.Context, prop *GenericVariableProperties) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateVariableEx", result, prop)
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a variable.
// To create a variable via a script, you need to use the SetScript method. For more information, see Create a variable.
// To set some properties to the variable, use the SetProperties method.
// In a published app, only transient variables can be created. See CreateSessionVariable method.
//
// Definition:
//
// A variable in Qlik Sense is a named entity, containing a data value. This value can be static or be the result of a calculation. A variable acquires its value at the same time that the variable is created or after when updating the properties of the variable. Variables can be used in bookmarks and can contain numeric or alphanumeric data. Any change made to the variable is applied everywhere the variable is used.
// When a variable is used in an expression, it is substituted by its value or the variable's definition.
//
// Example:
//
// The variable x contains the text string Sum(Sales) .
// In a chart, you define the expression $(x)/12 . The effect is exactly the same as having the chart expression Sum(Sales)/12 .
// However, if you change the value of the variable x to Sum(Budget) , the data in the chart are immediately recalculated with the expression interpreted as Sum(Budget)/12 .
//
// Parameters:
//
// ◾ prop   -   Name of the variable. Variable names are case sensitive and must be unique.
//
func (obj *Doc) CreateVariableExRaw(ctx context.Context, prop interface{}) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateVariableEx", result, ensureEncodable(prop))
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Deletes a connection.
// In Qlik Sense Enterprise, there is an additional file connection named AttachedFiles . The AttachedFiles connection can only be removed by the administrator of the system.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection to remove.
//
func (obj *Doc) DeleteConnection(ctx context.Context, connectionId string) error {
	err := obj.rpc(ctx, "DeleteConnection", nil, connectionId)
	return err
}

// Removes a bookmark.
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the bookmark.
//
func (obj *Doc) DestroyBookmark(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyBookmark", result, id)
	return result.Success, err
}

// Removes a dimension.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the dimension to remove.
//
func (obj *Doc) DestroyDimension(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyDimension", result, id)
	return result.Success, err
}

// Removes the draft of an object.
// The children of the draft object (if any) are removed as well.
// This method can be used to cancel the work on the draft of an object. For example, if you had created a draft of a sheet that is published, you might not want anymore to replace the published sheet.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id         -   Identifier of the draft object to remove.
//
// ◾ sourceId   -   Identifier of the source object (the object from which a draft was created).
//
func (obj *Doc) DestroyDraft(ctx context.Context, id string, sourceId string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyDraft", result, id, sourceId)
	return result.Success, err
}

// Removes a generic measure.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the measure to remove.
//
func (obj *Doc) DestroyMeasure(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyMeasure", result, id)
	return result.Success, err
}

// Removes an app object.
// The children of the object (if any) are removed as well.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to remove.
//
func (obj *Doc) DestroyObject(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyObject", result, id)
	return result.Success, err
}

// Removes a transient object.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the transient object to remove.
//
func (obj *Doc) DestroySessionObject(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroySessionObject", result, id)
	return result.Success, err
}

// Removes a transient variable.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the variable.
//
func (obj *Doc) DestroySessionVariable(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroySessionVariable", result, id)
	return result.Success, err
}

// Removes a transient variable.
//
//
// •*qSuccess** is set to true if the operation is successful.
//
// Parameters:
//
// ◾ id   -   Identifier of the variable.
//
func (obj *Doc) DestroySessionVariableById(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroySessionVariableById", result, id)
	return result.Success, err
}

// Removes a transient variable.
//
//
// •*qSuccess** is set to true if the operation is successful.
//
// Parameters:
//
// ◾ name   -   Name of the variable.
//
func (obj *Doc) DestroySessionVariableByName(ctx context.Context, name string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroySessionVariableByName", result, name)
	return result.Success, err
}

// Removes a variable.
// Script-defined variables cannot be removed using the DestroyVariableById method or the DestroyVariableByName method. For more information, see Remove a variable.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id   -   Identifier of the variable.
//
func (obj *Doc) DestroyVariableById(ctx context.Context, id string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyVariableById", result, id)
	return result.Success, err
}

// Removes a variable.
// Script-defined variables cannot be removed using the DestroyVariableById method or the DestroyVariableByName method. For more information, see Remove a variable.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ name   -   Name of the variable.
//
func (obj *Doc) DestroyVariableByName(ctx context.Context, name string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyVariableByName", result, name)
	return result.Success, err
}

// Reloads the script that is set in an app.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +----------------------------------------+----------------------------------+
//   |           AUDIT ACTIVITY LOG           |        SYSTEM SERVICE LOG        |
//   +----------------------------------------+----------------------------------+
//   | <MachineName>_AuditActivity_Engine.txt | <MachineName>_Service_Engine.txt |
//   | in Qlik Sense Enterprise               | in Qlik Sense Enterprise         |
//   | <MachineName>_AuditActivity_Engine.log | <MachineName>_Service_Engine.log |
//   | in Qlik Sense Desktop                  | in Qlik Sense Desktop            |
//   +----------------------------------------+----------------------------------+
//
// Where to find the log files:
//
// The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
//
//   +-------------------------------------+----------------------------------------+
//   |        QLIK SENSE ENTERPRISE        |           QLIK SENSE DESKTOP           |
//   +-------------------------------------+----------------------------------------+
//   | %ProgramData%/Qlik/Sense/Log/Engine | %UserProfile%/Documents/Qlik/Sense/Log |
//   +-------------------------------------+----------------------------------------+
//
// Parameters:
//
// ◾ mode      -   Error handling mode
// One of:
//
// • 0: for default mode.
//
// • 1: for ABEND; the reload of the script ends if an error occurs.
//
// • 2: for ignore; the reload of the script continues even if an error is detected in the script.
//
// ◾ partial   -   Set to true for partial reload.
// The default value is false.
//
// ◾ debug     -   Set to true if debug breakpoints are to be honored. The execution of the script will be in debug mode.
// The default value is false.
//
func (obj *Doc) DoReload(ctx context.Context, mode int, partial bool, debug bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "DoReload", result, mode, partial, debug)
	return result.Return, err
}

// Reloads the script that is set in an app and returns the path to the script log file.
// A log file is created per reload.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +--------------------------+--------------------------+
//   |    AUDIT ACTIVITY LOG    |    SYSTEM SERVICE LOG    |
//   +--------------------------+--------------------------+
//   | < MachineName>           | < MachineName> Service   |
//   | AuditActivity Engine.txt | Engine.txt in Qlik       |
//   | in Qlik Sense Enterprise | Sense Enterprise  <      |
//   |  < MachineName>          | MachineName> Service     |
//   | AuditActivity Engine.log | Engine.log in Qlik Sense |
//   | in Qlik Sense Desktop    | Desktop                  |
//   +--------------------------+--------------------------+
//
// Where to find the log files:
//
// The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
//
//   +-------------------------------------+----------------------------------------+
//   |        QLIK SENSE ENTERPRISE        |           QLIK SENSE DESKTOP           |
//   +-------------------------------------+----------------------------------------+
//   | %ProgramData%/Qlik/Sense/Log/Engine | %UserProfile%/Documents/Qlik/Sense/Log |
//   +-------------------------------------+----------------------------------------+
//
// DoReloadExParams:
//
//   +----------+--------------------------------+---------+
//   |   NAME   |          DESCRIPTION           |  TYPE   |
//   +----------+--------------------------------+---------+
//   | qMode    | Error handling mode  One of:   | Integer |
//   |          |    * 0: for default mode.  *   |         |
//   |          | 1: for ABEND; the reload of    |         |
//   |          | the script ends if an error    |         |
//   |          | occurs.  * 2: for ignore; the  |         |
//   |          | reload of the script continues |         |
//   |          | even if an error is detected   |         |
//   |          | in the script.                 |         |
//   | qPartial | Set to true for partial        | Boolean |
//   |          | reload.  The default value is  |         |
//   |          | false.                         |         |
//   | qDebug   | Set to true if debug           | Boolean |
//   |          | breakpoints are to be honored. |         |
//   |          | The execution of the script    |         |
//   |          | will be in debug mode.  The    |         |
//   |          | default value is false.        |         |
//   +----------+--------------------------------+---------+
//
// DoReloadExResult:
//
//   +----------------+--------------------------------+---------+
//   |      NAME      |          DESCRIPTION           |  TYPE   |
//   +----------------+--------------------------------+---------+
//   | qSuccess       | The operation is successful if | Boolean |
//   |                | qSuccess is set to True.       |         |
//   | qScriptLogFile | Path to the script log file.   | String  |
//   +----------------+--------------------------------+---------+
//
// If the data load has successfully finished, no matter how the indexing behaves, true is returned. This happens even if there is a timeout, a memory limit is reached or any other error occurs during the indexing.
func (obj *Doc) DoReloadEx(ctx context.Context, params *DoReloadExParams) (*DoReloadExResult, error) {
	result := &struct {
		Result *DoReloadExResult `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "DoReloadEx", result, params)
	return result.Result, err
}

// Reloads the script that is set in an app and returns the path to the script log file.
// A log file is created per reload.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +--------------------------+--------------------------+
//   |    AUDIT ACTIVITY LOG    |    SYSTEM SERVICE LOG    |
//   +--------------------------+--------------------------+
//   | < MachineName>           | < MachineName> Service   |
//   | AuditActivity Engine.txt | Engine.txt in Qlik       |
//   | in Qlik Sense Enterprise | Sense Enterprise  <      |
//   |  < MachineName>          | MachineName> Service     |
//   | AuditActivity Engine.log | Engine.log in Qlik Sense |
//   | in Qlik Sense Desktop    | Desktop                  |
//   +--------------------------+--------------------------+
//
// Where to find the log files:
//
// The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
//
//   +-------------------------------------+----------------------------------------+
//   |        QLIK SENSE ENTERPRISE        |           QLIK SENSE DESKTOP           |
//   +-------------------------------------+----------------------------------------+
//   | %ProgramData%/Qlik/Sense/Log/Engine | %UserProfile%/Documents/Qlik/Sense/Log |
//   +-------------------------------------+----------------------------------------+
//
// DoReloadExParams:
//
//   +----------+--------------------------------+---------+
//   |   NAME   |          DESCRIPTION           |  TYPE   |
//   +----------+--------------------------------+---------+
//   | qMode    | Error handling mode  One of:   | Integer |
//   |          |    * 0: for default mode.  *   |         |
//   |          | 1: for ABEND; the reload of    |         |
//   |          | the script ends if an error    |         |
//   |          | occurs.  * 2: for ignore; the  |         |
//   |          | reload of the script continues |         |
//   |          | even if an error is detected   |         |
//   |          | in the script.                 |         |
//   | qPartial | Set to true for partial        | Boolean |
//   |          | reload.  The default value is  |         |
//   |          | false.                         |         |
//   | qDebug   | Set to true if debug           | Boolean |
//   |          | breakpoints are to be honored. |         |
//   |          | The execution of the script    |         |
//   |          | will be in debug mode.  The    |         |
//   |          | default value is false.        |         |
//   +----------+--------------------------------+---------+
//
// DoReloadExResult:
//
//   +----------------+--------------------------------+---------+
//   |      NAME      |          DESCRIPTION           |  TYPE   |
//   +----------------+--------------------------------+---------+
//   | qSuccess       | The operation is successful if | Boolean |
//   |                | qSuccess is set to True.       |         |
//   | qScriptLogFile | Path to the script log file.   | String  |
//   +----------------+--------------------------------+---------+
//
// If the data load has successfully finished, no matter how the indexing behaves, true is returned. This happens even if there is a timeout, a memory limit is reached or any other error occurs during the indexing.
func (obj *Doc) DoReloadExRaw(ctx context.Context, params interface{}) (json.RawMessage, error) {
	result := &struct {
		Result json.RawMessage `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "DoReloadEx", result, ensureEncodable(params))
	return result.Result, err
}

// Saves an app. All objects and data in the data model are saved.
//
// Parameters:
//
// ◾ fileName   -   Name of the file to save.
//
func (obj *Doc) DoSave(ctx context.Context, fileName string) error {
	err := obj.rpc(ctx, "DoSave", nil, fileName)
	return err
}

// Evaluates an expression and returns the result as a string.
//
// Example:
//
// The client sends:
// ```
// {
// "handle": 1,
// "method": "Evaluate",
// "params": {
// "qExpression": "Sum(Holes)"
// },
// "id": 6,
// "jsonrpc": "2.0"
// }
// ```
// The engine returns:
// ```
// {
// "jsonrpc": "2.0",
// "id": 6,
// "result": {
// "qReturn": "361716"
// }
// }
// ```
//
// Parameters:
//
// ◾ expression   -   Expression to evaluate.
//
func (obj *Doc) Evaluate(ctx context.Context, expression string) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "Evaluate", result, expression)
	return result.Return, err
}

// Evaluates an expression and returns the result as a dual.
//
// Example:
//
// The client sends:
// ```
// {
// "handle": 1,
// "method": "EvaluateEx",
// "params": {
// "qExpression": "Sum(Holes)"
// },
// "id": 7,
// "jsonrpc": "2.0"
// }
// ```
// The engine returns:
// ```
// {
// "jsonrpc": "2.0",
// "id": 7,
// "result": {
// "qReturn": "361716"
// }
// }
// ```
//
// Parameters:
//
// ◾ expression   -   Expression to evaluate.
//
func (obj *Doc) EvaluateEx(ctx context.Context, expression string) (*FieldValue, error) {
	result := &struct {
		Value *FieldValue `json:"qValue"`
	}{}
	err := obj.rpc(ctx, "EvaluateEx", result, expression)
	return result.Value, err
}

// Evaluates an expression and returns the result as a dual.
//
// Example:
//
// The client sends:
// ```
// {
// "handle": 1,
// "method": "EvaluateEx",
// "params": {
// "qExpression": "Sum(Holes)"
// },
// "id": 7,
// "jsonrpc": "2.0"
// }
// ```
// The engine returns:
// ```
// {
// "jsonrpc": "2.0",
// "id": 7,
// "result": {
// "qReturn": "361716"
// }
// }
// ```
//
// Parameters:
//
// ◾ expression   -   Expression to evaluate.
//
func (obj *Doc) EvaluateExRaw(ctx context.Context, expression string) (json.RawMessage, error) {
	result := &struct {
		Value json.RawMessage `json:"qValue"`
	}{}
	err := obj.rpc(ctx, "EvaluateEx", result, ensureEncodable(expression))
	return result.Value, err
}

// Expands the expression.
//
// Parameters:
//
// ◾ expression   -   The expression string to expand.
//
func (obj *Doc) ExpandExpression(ctx context.Context, expression string) (string, error) {
	result := &struct {
		ExpandedExpression string `json:"qExpandedExpression"`
	}{}
	err := obj.rpc(ctx, "ExpandExpression", result, expression)
	return result.ExpandedExpression, err
}

// Retrieves any fields that belong to the same archipelago as the specified field and that match at least one of the specified tags.
// Tags set by Qlik Sense are prefixed by the $ sign.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field.
// This method looks for fields that belong to the same archipelago as this specified field.
//
// ◾ tags        -   List of tags.
// This method looks for fields that match at least one of the tags in this list.
//
func (obj *Doc) FindMatchingFields(ctx context.Context, fieldName string, tags []string) ([]*NxMatchingFieldInfo, error) {
	result := &struct {
		FieldNames []*NxMatchingFieldInfo `json:"qFieldNames"`
	}{}
	err := obj.rpc(ctx, "FindMatchingFields", result, fieldName, tags)
	return result.FieldNames, err
}

// Retrieves any fields that belong to the same archipelago as the specified field and that match at least one of the specified tags.
// Tags set by Qlik Sense are prefixed by the $ sign.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field.
// This method looks for fields that belong to the same archipelago as this specified field.
//
// ◾ tags        -   List of tags.
// This method looks for fields that match at least one of the tags in this list.
//
func (obj *Doc) FindMatchingFieldsRaw(ctx context.Context, fieldName string, tags []string) (json.RawMessage, error) {
	result := &struct {
		FieldNames json.RawMessage `json:"qFieldNames"`
	}{}
	err := obj.rpc(ctx, "FindMatchingFields", result, ensureEncodable(fieldName), ensureEncodable(tags))
	return result.FieldNames, err
}

// Loads the next logical operation (if any).
func (obj *Doc) Forward(ctx context.Context) error {
	err := obj.rpc(ctx, "Forward", nil)
	return err
}

// Returns the number of entries on the Forward stack.
func (obj *Doc) ForwardCount(ctx context.Context) (int, error) {
	result := &struct {
		Return int `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "ForwardCount", result)
	return result.Return, err
}

// Returns the identifier and the type of any generic object in the app.
func (obj *Doc) GetAllInfos(ctx context.Context) ([]*NxInfo, error) {
	result := &struct {
		Infos []*NxInfo `json:"qInfos"`
	}{}
	err := obj.rpc(ctx, "GetAllInfos", result)
	return result.Infos, err
}

// Returns the identifier and the type of any generic object in the app.
func (obj *Doc) GetAllInfosRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Infos json.RawMessage `json:"qInfos"`
	}{}
	err := obj.rpc(ctx, "GetAllInfos", result)
	return result.Infos, err
}

// Evaluates an app.
// Returns dynamic properties (if any) in addition to the engine (fixed) properties.
// A data set is returned.
func (obj *Doc) GetAppLayout(ctx context.Context) (*NxAppLayout, error) {
	result := &struct {
		Layout *NxAppLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetAppLayout", result)
	return result.Layout, err
}

// Evaluates an app.
// Returns dynamic properties (if any) in addition to the engine (fixed) properties.
// A data set is returned.
func (obj *Doc) GetAppLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetAppLayout", result)
	return result.Layout, err
}

// Gets the properties of an app.
func (obj *Doc) GetAppProperties(ctx context.Context) (*NxAppProperties, error) {
	result := &struct {
		Prop *NxAppProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetAppProperties", result)
	return result.Prop, err
}

// Gets the properties of an app.
func (obj *Doc) GetAppPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetAppProperties", result)
	return result.Prop, err
}

// Computes a set of association scores for each pair of fields between two given tables that have been loaded in an app.
// When a table contains some synthetic keys, all fields in the synthetic key tables are analyzed against fields in other tables. To denote that a field is a synthetic key, the field name is prefixed by [Synthetic Key]: .
//
// Parameters:
//
// ◾ table1   -   Name of the first table.
//
// ◾ table2   -   Name of the second table.
//
func (obj *Doc) GetAssociationScores(ctx context.Context, table1 string, table2 string) ([]*AssociationScore, error) {
	result := &struct {
		Score []*AssociationScore `json:"qScore"`
	}{}
	err := obj.rpc(ctx, "GetAssociationScores", result, table1, table2)
	return result.Score, err
}

// Computes a set of association scores for each pair of fields between two given tables that have been loaded in an app.
// When a table contains some synthetic keys, all fields in the synthetic key tables are analyzed against fields in other tables. To denote that a field is a synthetic key, the field name is prefixed by [Synthetic Key]: .
//
// Parameters:
//
// ◾ table1   -   Name of the first table.
//
// ◾ table2   -   Name of the second table.
//
func (obj *Doc) GetAssociationScoresRaw(ctx context.Context, table1 string, table2 string) (json.RawMessage, error) {
	result := &struct {
		Score json.RawMessage `json:"qScore"`
	}{}
	err := obj.rpc(ctx, "GetAssociationScores", result, ensureEncodable(table1), ensureEncodable(table2))
	return result.Score, err
}

// Returns the handle of a bookmark.
//
// Parameters:
//
// ◾ id   -   Identifier of the bookmark.
//
func (obj *Doc) GetBookmark(ctx context.Context, id string) (*GenericBookmark, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetBookmark", result, id)
	if err != nil {
		return nil, err
	}
	return &GenericBookmark{obj.session.getRemoteObject(result.Return)}, err
}

// Returns all bookmarks compatible with options.
//
// Parameters:
//
// ◾ options   -   Bookmark type filter and requested properties.
//
func (obj *Doc) GetBookmarks(ctx context.Context, options *NxGetBookmarkOptions) ([]*NxContainerEntry, error) {
	result := &struct {
		List []*NxContainerEntry `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetBookmarks", result, options)
	return result.List, err
}

// Returns all bookmarks compatible with options.
//
// Parameters:
//
// ◾ options   -   Bookmark type filter and requested properties.
//
func (obj *Doc) GetBookmarksRaw(ctx context.Context, options interface{}) (json.RawMessage, error) {
	result := &struct {
		List json.RawMessage `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetBookmarks", result, ensureEncodable(options))
	return result.List, err
}

// Retrieves a connection and returns:
//
// • The creation time of the connection.
//
// • The identifier of the connection.
//
// • The type of the connection.
//
// • The name of the connection.
//
// • The connection string.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
func (obj *Doc) GetConnection(ctx context.Context, connectionId string) (*Connection, error) {
	result := &struct {
		Connection *Connection `json:"qConnection"`
	}{}
	err := obj.rpc(ctx, "GetConnection", result, connectionId)
	return result.Connection, err
}

// Retrieves a connection and returns:
//
// • The creation time of the connection.
//
// • The identifier of the connection.
//
// • The type of the connection.
//
// • The name of the connection.
//
// • The connection string.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
func (obj *Doc) GetConnectionRaw(ctx context.Context, connectionId string) (json.RawMessage, error) {
	result := &struct {
		Connection json.RawMessage `json:"qConnection"`
	}{}
	err := obj.rpc(ctx, "GetConnection", result, ensureEncodable(connectionId))
	return result.Connection, err
}

// Lists the connections in an app.
// In Qlik Sense Enterprise, there is an additional file connection named AttachedFiles . This connection is stored in the Qlik Sense repository.
func (obj *Doc) GetConnections(ctx context.Context) ([]*Connection, error) {
	result := &struct {
		Connections []*Connection `json:"qConnections"`
	}{}
	err := obj.rpc(ctx, "GetConnections", result)
	return result.Connections, err
}

// Lists the connections in an app.
// In Qlik Sense Enterprise, there is an additional file connection named AttachedFiles . This connection is stored in the Qlik Sense repository.
func (obj *Doc) GetConnectionsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Connections json.RawMessage `json:"qConnections"`
	}{}
	err := obj.rpc(ctx, "GetConnections", result)
	return result.Connections, err
}

// Lists the content libraries.
// To differentiate a global content library from an app specific content library, you can check the property qAppSpecific . If this property is set to true, it means that the content library is app specific.
// There is always one specific content library per app.
//
// Qlik Sense:
//
// Returns the global content libraries and the app specific content library.
// When using Qlik Sense, you can have more than one global content library. The global content libraries are common to all apps in the Qlik Sense repository.
// By default, there is one global content library named Default .
//
// Qlik Sense Desktop:
//
// Returns the global content library and the app specific content library from the disk.
func (obj *Doc) GetContentLibraries(ctx context.Context) (*ContentLibraryList, error) {
	result := &struct {
		List *ContentLibraryList `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetContentLibraries", result)
	return result.List, err
}

// Lists the content libraries.
// To differentiate a global content library from an app specific content library, you can check the property qAppSpecific . If this property is set to true, it means that the content library is app specific.
// There is always one specific content library per app.
//
// Qlik Sense:
//
// Returns the global content libraries and the app specific content library.
// When using Qlik Sense, you can have more than one global content library. The global content libraries are common to all apps in the Qlik Sense repository.
// By default, there is one global content library named Default .
//
// Qlik Sense Desktop:
//
// Returns the global content library and the app specific content library from the disk.
func (obj *Doc) GetContentLibrariesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		List json.RawMessage `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetContentLibraries", result)
	return result.List, err
}

// Gives information about an ODBC, OLEDB or CUSTOM connection. See Outputs for more details.
//
// Parameters:
//
// ◾ connectionId   -   Name of the connection.
//
func (obj *Doc) GetDatabaseInfo(ctx context.Context, connectionId string) (*DatabaseInfo, error) {
	result := &struct {
		Info *DatabaseInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseInfo", result, connectionId)
	return result.Info, err
}

// Gives information about an ODBC, OLEDB or CUSTOM connection. See Outputs for more details.
//
// Parameters:
//
// ◾ connectionId   -   Name of the connection.
//
func (obj *Doc) GetDatabaseInfoRaw(ctx context.Context, connectionId string) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseInfo", result, ensureEncodable(connectionId))
	return result.Info, err
}

// Lists the owners of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
//
func (obj *Doc) GetDatabaseOwners(ctx context.Context, connectionId string, database string) ([]*DatabaseOwner, error) {
	result := &struct {
		Owners []*DatabaseOwner `json:"qOwners"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseOwners", result, connectionId, database)
	return result.Owners, err
}

// Lists the owners of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
//
func (obj *Doc) GetDatabaseOwnersRaw(ctx context.Context, connectionId string, database string) (json.RawMessage, error) {
	result := &struct {
		Owners json.RawMessage `json:"qOwners"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseOwners", result, ensureEncodable(connectionId), ensureEncodable(database))
	return result.Owners, err
}

// Lists the fields inside a table of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
// ◾ table          -   Name of the table.
//
func (obj *Doc) GetDatabaseTableFields(ctx context.Context, connectionId string, database string, owner string, table string) ([]*DataField, error) {
	result := &struct {
		Fields []*DataField `json:"qFields"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTableFields", result, connectionId, database, owner, table)
	return result.Fields, err
}

// Lists the fields inside a table of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
// ◾ table          -   Name of the table.
//
func (obj *Doc) GetDatabaseTableFieldsRaw(ctx context.Context, connectionId string, database string, owner string, table string) (json.RawMessage, error) {
	result := &struct {
		Fields json.RawMessage `json:"qFields"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTableFields", result, ensureEncodable(connectionId), ensureEncodable(database), ensureEncodable(owner), ensureEncodable(table))
	return result.Fields, err
}

// Retrieves the values of the specified table of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
// ◾ table          -   Name of the table.
//
// ◾ conditions     -
//
func (obj *Doc) GetDatabaseTablePreview(ctx context.Context, connectionId string, database string, owner string, table string, conditions *FilterInfo) ([]*DataRecord, int, error) {
	result := &struct {
		Preview  []*DataRecord `json:"qPreview"`
		RowCount int           `json:"qRowCount"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTablePreview", result, connectionId, database, owner, table, conditions)
	return result.Preview, result.RowCount, err
}

// Retrieves the values of the specified table of a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
// ◾ table          -   Name of the table.
//
// ◾ conditions     -
//
func (obj *Doc) GetDatabaseTablePreviewRaw(ctx context.Context, connectionId string, database string, owner string, table string, conditions interface{}) (json.RawMessage, int, error) {
	result := &struct {
		Preview  json.RawMessage `json:"qPreview"`
		RowCount int             `json:"qRowCount"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTablePreview", result, ensureEncodable(connectionId), ensureEncodable(database), ensureEncodable(owner), ensureEncodable(table), ensureEncodable(conditions))
	return result.Preview, result.RowCount, err
}

// Lists the tables inside a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
func (obj *Doc) GetDatabaseTables(ctx context.Context, connectionId string, database string, owner string) ([]*DataTable, error) {
	result := &struct {
		Tables []*DataTable `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTables", result, connectionId, database, owner)
	return result.Tables, err
}

// Lists the tables inside a database for a ODBC, OLEDB or CUSTOM connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ database       -   Name of the database.
// If qDatabase is not set then qOwner must be set.
//
// ◾ owner          -   Owner of the database.
// If qOwner is not set then qDatabase must be set.
//
func (obj *Doc) GetDatabaseTablesRaw(ctx context.Context, connectionId string, database string, owner string) (json.RawMessage, error) {
	result := &struct {
		Tables json.RawMessage `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetDatabaseTables", result, ensureEncodable(connectionId), ensureEncodable(database), ensureEncodable(owner))
	return result.Tables, err
}

// Lists the databases inside a ODBC, OLEDB or CUSTOM data source.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
func (obj *Doc) GetDatabases(ctx context.Context, connectionId string) ([]*Database, error) {
	result := &struct {
		Databases []*Database `json:"qDatabases"`
	}{}
	err := obj.rpc(ctx, "GetDatabases", result, connectionId)
	return result.Databases, err
}

// Lists the databases inside a ODBC, OLEDB or CUSTOM data source.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
func (obj *Doc) GetDatabasesRaw(ctx context.Context, connectionId string) (json.RawMessage, error) {
	result := &struct {
		Databases json.RawMessage `json:"qDatabases"`
	}{}
	err := obj.rpc(ctx, "GetDatabases", result, ensureEncodable(connectionId))
	return result.Databases, err
}

// Returns the handle of a dimension.
//
// Parameters:
//
// ◾ id   -   Identifier of the dimension.
//
func (obj *Doc) GetDimension(ctx context.Context, id string) (*GenericDimension, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetDimension", result, id)
	if err != nil {
		return nil, err
	}
	return &GenericDimension{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a script that contains one section. This section contains SET statements that give localized information from the regional settings of the computer.
// The computer regional settings are retrieved when the engine starts.
//
// Parameters:
//
// ◾ localizedMainSection   -   Name of the script section.
// The default value is Main .
//
func (obj *Doc) GetEmptyScript(ctx context.Context, localizedMainSection string) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetEmptyScript", result, localizedMainSection)
	return result.Return, err
}

// Retrieves the variables that are tagged as favorite.
func (obj *Doc) GetFavoriteVariables(ctx context.Context) ([]string, error) {
	result := &struct {
		Names []string `json:"qNames"`
	}{}
	err := obj.rpc(ctx, "GetFavoriteVariables", result)
	return result.Names, err
}

// Returns a handle to a field.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field.
//
// ◾ stateName   -   Name of the alternate state.
// Default state is current selections.
//
func (obj *Doc) GetField(ctx context.Context, fieldName string, stateName string) (*Field, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetField", result, fieldName, stateName)
	if err != nil {
		return nil, err
	}
	return &Field{obj.session.getRemoteObject(result.Return)}, err
}

// Get sample values from either a column in a table or from a field.
// Supports wildcard matches in tables or field names:
// - '*' for zero or more characters.
// - '?' for one character.
//
// Parameters:
//
// ◾ fieldsOrColumnsWithWildcards   -   Pairs of table (optionally) and field names. Support wildcard matches.
//
// ◾ maxNumberOfValues              -   Max number of sample values returned. Depending on the column or field size the number of returned samples can be less than MaxNumberOfValues. If MaxNumberOfValues is negative all sample values are returned.
//
// ◾ randSeed                       -   Optional. Sets the random number seed. Should only be set for test purposes.
//
func (obj *Doc) GetFieldAndColumnSamples(ctx context.Context, fieldsOrColumnsWithWildcards []*FieldOrColumn, maxNumberOfValues int, randSeed int) ([]*SampleResult, error) {
	result := &struct {
		Result []*SampleResult `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "GetFieldAndColumnSamples", result, fieldsOrColumnsWithWildcards, maxNumberOfValues, randSeed)
	return result.Result, err
}

// Get sample values from either a column in a table or from a field.
// Supports wildcard matches in tables or field names:
// - '*' for zero or more characters.
// - '?' for one character.
//
// Parameters:
//
// ◾ fieldsOrColumnsWithWildcards   -   Pairs of table (optionally) and field names. Support wildcard matches.
//
// ◾ maxNumberOfValues              -   Max number of sample values returned. Depending on the column or field size the number of returned samples can be less than MaxNumberOfValues. If MaxNumberOfValues is negative all sample values are returned.
//
// ◾ randSeed                       -   Optional. Sets the random number seed. Should only be set for test purposes.
//
func (obj *Doc) GetFieldAndColumnSamplesRaw(ctx context.Context, fieldsOrColumnsWithWildcards interface{}, maxNumberOfValues int, randSeed int) (json.RawMessage, error) {
	result := &struct {
		Result json.RawMessage `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "GetFieldAndColumnSamples", result, ensureEncodable(fieldsOrColumnsWithWildcards), ensureEncodable(maxNumberOfValues), ensureEncodable(randSeed))
	return result.Result, err
}

// Returns the description of a field.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field.
//
func (obj *Doc) GetFieldDescription(ctx context.Context, fieldName string) (*FieldDescription, error) {
	result := &struct {
		Return *FieldDescription `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetFieldDescription", result, fieldName)
	return result.Return, err
}

// Returns the description of a field.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field.
//
func (obj *Doc) GetFieldDescriptionRaw(ctx context.Context, fieldName string) (json.RawMessage, error) {
	result := &struct {
		Return json.RawMessage `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetFieldDescription", result, ensureEncodable(fieldName))
	return result.Return, err
}

// Find the field-on-the-fly by passing its readable name.
//
// Parameters:
//
// ◾ readableName   -   Readable name of the field-on-the-fly.
//
func (obj *Doc) GetFieldOnTheFlyByName(ctx context.Context, readableName string) (string, error) {
	result := &struct {
		Name string `json:"qName"`
	}{}
	err := obj.rpc(ctx, "GetFieldOnTheFlyByName", result, readableName)
	return result.Name, err
}

// Lists the fields of a table for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
// ◾ table          -   Name of the table.
// This parameter must be set for XLS , XLSX , HTML   and XML files.
//
func (obj *Doc) GetFileTableFields(ctx context.Context, connectionId string, relativePath string, dataFormat *FileDataFormat, table string) ([]*DataField, string, error) {
	result := &struct {
		Fields     []*DataField `json:"qFields"`
		FormatSpec string       `json:"qFormatSpec"`
	}{}
	err := obj.rpc(ctx, "GetFileTableFields", result, connectionId, relativePath, dataFormat, table)
	return result.Fields, result.FormatSpec, err
}

// Lists the fields of a table for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
// ◾ table          -   Name of the table.
// This parameter must be set for XLS , XLSX , HTML   and XML files.
//
func (obj *Doc) GetFileTableFieldsRaw(ctx context.Context, connectionId string, relativePath string, dataFormat interface{}, table string) (json.RawMessage, string, error) {
	result := &struct {
		Fields     json.RawMessage `json:"qFields"`
		FormatSpec string          `json:"qFormatSpec"`
	}{}
	err := obj.rpc(ctx, "GetFileTableFields", result, ensureEncodable(connectionId), ensureEncodable(relativePath), ensureEncodable(dataFormat), ensureEncodable(table))
	return result.Fields, result.FormatSpec, err
}

// Lists the values in a table for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
// ◾ table          -   Name of the table.
// This parameter must be set for XLS , XLSX , HTML   and XML files.
//
func (obj *Doc) GetFileTablePreview(ctx context.Context, connectionId string, relativePath string, dataFormat *FileDataFormat, table string) ([]*DataRecord, string, error) {
	result := &struct {
		Preview    []*DataRecord `json:"qPreview"`
		FormatSpec string        `json:"qFormatSpec"`
	}{}
	err := obj.rpc(ctx, "GetFileTablePreview", result, connectionId, relativePath, dataFormat, table)
	return result.Preview, result.FormatSpec, err
}

// Lists the values in a table for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
// ◾ table          -   Name of the table.
// This parameter must be set for XLS , XLSX , HTML   and XML files.
//
func (obj *Doc) GetFileTablePreviewRaw(ctx context.Context, connectionId string, relativePath string, dataFormat interface{}, table string) (json.RawMessage, string, error) {
	result := &struct {
		Preview    json.RawMessage `json:"qPreview"`
		FormatSpec string          `json:"qFormatSpec"`
	}{}
	err := obj.rpc(ctx, "GetFileTablePreview", result, ensureEncodable(connectionId), ensureEncodable(relativePath), ensureEncodable(dataFormat), ensureEncodable(table))
	return result.Preview, result.FormatSpec, err
}

// Lists the tables for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
func (obj *Doc) GetFileTables(ctx context.Context, connectionId string, relativePath string, dataFormat *FileDataFormat) ([]*DataTable, error) {
	result := &struct {
		Tables []*DataTable `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetFileTables", result, connectionId, relativePath, dataFormat)
	return result.Tables, err
}

// Lists the tables for a folder connection.
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
func (obj *Doc) GetFileTablesRaw(ctx context.Context, connectionId string, relativePath string, dataFormat interface{}) (json.RawMessage, error) {
	result := &struct {
		Tables json.RawMessage `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetFileTables", result, ensureEncodable(connectionId), ensureEncodable(relativePath), ensureEncodable(dataFormat))
	return result.Tables, err
}

// Lists the tables and fields of a JSON or XML file for a folder connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
func (obj *Doc) GetFileTablesEx(ctx context.Context, connectionId string, relativePath string, dataFormat *FileDataFormat) ([]*DataTableEx, error) {
	result := &struct {
		Tables []*DataTableEx `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetFileTablesEx", result, connectionId, relativePath, dataFormat)
	return result.Tables, err
}

// Lists the tables and fields of a JSON or XML file for a folder connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Path of the connection file.
//
// ◾ dataFormat     -   Type of the file.
//
func (obj *Doc) GetFileTablesExRaw(ctx context.Context, connectionId string, relativePath string, dataFormat interface{}) (json.RawMessage, error) {
	result := &struct {
		Tables json.RawMessage `json:"qTables"`
	}{}
	err := obj.rpc(ctx, "GetFileTablesEx", result, ensureEncodable(connectionId), ensureEncodable(relativePath), ensureEncodable(dataFormat))
	return result.Tables, err
}

// Lists the items for a folder connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Relative path of the connection.
//
func (obj *Doc) GetFolderItemsForConnection(ctx context.Context, connectionId string, relativePath string) ([]*FolderItem, error) {
	result := &struct {
		FolderItems []*FolderItem `json:"qFolderItems"`
	}{}
	err := obj.rpc(ctx, "GetFolderItemsForConnection", result, connectionId, relativePath)
	return result.FolderItems, err
}

// Lists the items for a folder connection.
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection.
//
// ◾ relativePath   -   Relative path of the connection.
//
func (obj *Doc) GetFolderItemsForConnectionRaw(ctx context.Context, connectionId string, relativePath string) (json.RawMessage, error) {
	result := &struct {
		FolderItems json.RawMessage `json:"qFolderItems"`
	}{}
	err := obj.rpc(ctx, "GetFolderItemsForConnection", result, ensureEncodable(connectionId), ensureEncodable(relativePath))
	return result.FolderItems, err
}

// Gets the content of a file.
//
// Parameters:
//
// ◾ path   -   ["lib://CONNECTION_NAME\\\<the name of the file you want to use>.txt"]
// OR
// ["lib://Connection_Name\\\<Folder under your connection>\\\<the name of the file you want to use>.txt"]
// [ ] should be used when the first variable contains a lib reference.
//
func (obj *Doc) GetIncludeFileContent(ctx context.Context, path string) (string, error) {
	result := &struct {
		Content string `json:"qContent"`
	}{}
	err := obj.rpc(ctx, "GetIncludeFileContent", result, path)
	return result.Content, err
}

// Returns the content of a library.
//
// Global content library:
//
// In Qlik Sense Desktop, the content files are retrieved from:
// _%userprofile%\Documents\Qlik\Sense\Content\Default_
// In Qlik Sense Enterprise, the content files are retrieved from the Qlik Sense repository.
//
// App specific content library:
//
// The embedded files are returned.
//
// Parameters:
//
// ◾ name   -   Name of the content library.
// It corresponds to the property qContentLibraryListItem/qName returned by the GetContentLibraries method.
//
func (obj *Doc) GetLibraryContent(ctx context.Context, name string) (*StaticContentList, error) {
	result := &struct {
		List *StaticContentList `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetLibraryContent", result, name)
	return result.List, err
}

// Returns the content of a library.
//
// Global content library:
//
// In Qlik Sense Desktop, the content files are retrieved from:
// _%userprofile%\Documents\Qlik\Sense\Content\Default_
// In Qlik Sense Enterprise, the content files are retrieved from the Qlik Sense repository.
//
// App specific content library:
//
// The embedded files are returned.
//
// Parameters:
//
// ◾ name   -   Name of the content library.
// It corresponds to the property qContentLibraryListItem/qName returned by the GetContentLibraries method.
//
func (obj *Doc) GetLibraryContentRaw(ctx context.Context, name string) (json.RawMessage, error) {
	result := &struct {
		List json.RawMessage `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetLibraryContent", result, ensureEncodable(name))
	return result.List, err
}

// Gets the lineage information of the app. The lineage information includes the LOAD and STORE statements from the data load script associated with this app.
// An array of lineage information.
func (obj *Doc) GetLineage(ctx context.Context) ([]*LineageInfo, error) {
	result := &struct {
		Lineage []*LineageInfo `json:"qLineage"`
	}{}
	err := obj.rpc(ctx, "GetLineage", result)
	return result.Lineage, err
}

// Gets the lineage information of the app. The lineage information includes the LOAD and STORE statements from the data load script associated with this app.
// An array of lineage information.
func (obj *Doc) GetLineageRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Lineage json.RawMessage `json:"qLineage"`
	}{}
	err := obj.rpc(ctx, "GetLineage", result)
	return result.Lineage, err
}

// Returns locale information.
func (obj *Doc) GetLocaleInfo(ctx context.Context) (*LocaleInfo, error) {
	result := &struct {
		Return *LocaleInfo `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetLocaleInfo", result)
	return result.Return, err
}

// Returns locale information.
func (obj *Doc) GetLocaleInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Return json.RawMessage `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetLocaleInfo", result)
	return result.Return, err
}

// Returns a list of table states.
//
// The following states apply:
//
// • 0 The table is not loosely coupled.
//
// • 1 The table is loosely coupled.
//
// • 2 The table is loosely coupled and cannot be changed to another state using the Qlik Engine API.
//
// The last three values in the vector are for internal use.
//
// In case of circular references, the engine automatically sets the table state to loosely coupled to avoid creating loops.
func (obj *Doc) GetLooselyCoupledVector(ctx context.Context) ([]string, error) {
	result := &struct {
		V []string `json:"qv"`
	}{}
	err := obj.rpc(ctx, "GetLooselyCoupledVector", result)
	return result.V, err
}

// Retrieves any fields that match all of the specified tags or just one of them in the data model of an app.
// Tags set by Qlik Sense are prefixed by the $ sign.
//
// Parameters:
//
// ◾ tags                -   List of tags.
// The GetMatchingFields method looks for fields that match one or all of the tags in this list, depending on the value of qMatchingFieldMode .
//
// ◾ matchingFieldMode   -   Matching field mode.
// The default value is MATCHINGFIELDMODE_MATCH_ALL.
//
// One of:
//
// • MATCHINGFIELDMODE_MATCH_ALL
//
// • MATCHINGFIELDMODE_MATCH_ONE
//
func (obj *Doc) GetMatchingFields(ctx context.Context, tags []string, matchingFieldMode string) ([]*NxMatchingFieldInfo, error) {
	result := &struct {
		FieldNames []*NxMatchingFieldInfo `json:"qFieldNames"`
	}{}
	err := obj.rpc(ctx, "GetMatchingFields", result, tags, matchingFieldMode)
	return result.FieldNames, err
}

// Retrieves any fields that match all of the specified tags or just one of them in the data model of an app.
// Tags set by Qlik Sense are prefixed by the $ sign.
//
// Parameters:
//
// ◾ tags                -   List of tags.
// The GetMatchingFields method looks for fields that match one or all of the tags in this list, depending on the value of qMatchingFieldMode .
//
// ◾ matchingFieldMode   -   Matching field mode.
// The default value is MATCHINGFIELDMODE_MATCH_ALL.
//
// One of:
//
// • MATCHINGFIELDMODE_MATCH_ALL
//
// • MATCHINGFIELDMODE_MATCH_ONE
//
func (obj *Doc) GetMatchingFieldsRaw(ctx context.Context, tags []string, matchingFieldMode string) (json.RawMessage, error) {
	result := &struct {
		FieldNames json.RawMessage `json:"qFieldNames"`
	}{}
	err := obj.rpc(ctx, "GetMatchingFields", result, ensureEncodable(tags), ensureEncodable(matchingFieldMode))
	return result.FieldNames, err
}

// Returns the handle of a measure.
//
// Parameters:
//
// ◾ id   -   Identifier of the measure.
//
func (obj *Doc) GetMeasure(ctx context.Context, id string) (*GenericMeasure, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetMeasure", result, id)
	if err != nil {
		return nil, err
	}
	return &GenericMeasure{obj.session.getRemoteObject(result.Return)}, err
}

// Lists the media files.
func (obj *Doc) GetMediaList(ctx context.Context) (*MediaList, error) {
	result := &struct {
		List   *MediaList `json:"qList"`
		Return bool       `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetMediaList", result)
	return result.List, err
}

// Lists the media files.
func (obj *Doc) GetMediaListRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		List   json.RawMessage `json:"qList"`
		Return bool            `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetMediaList", result)
	return result.List, err
}

// Returns the type of the app object and the corresponding handle.
//
// Parameters:
//
// ◾ id   -   Identifier of the object to retrieve.
//
func (obj *Doc) GetObject(ctx context.Context, id string) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetObject", result, id)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Returns all objects compatible with options.
//
// Parameters:
//
// ◾ options   -   Object type filter and requested properties.
//
func (obj *Doc) GetObjects(ctx context.Context, options *NxGetObjectOptions) ([]*NxContainerEntry, error) {
	result := &struct {
		List []*NxContainerEntry `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetObjects", result, options)
	return result.List, err
}

// Returns all objects compatible with options.
//
// Parameters:
//
// ◾ options   -   Object type filter and requested properties.
//
func (obj *Doc) GetObjectsRaw(ctx context.Context, options interface{}) (json.RawMessage, error) {
	result := &struct {
		List json.RawMessage `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetObjects", result, ensureEncodable(options))
	return result.List, err
}

// Gets values in script.
func (obj *Doc) GetScript(ctx context.Context) (string, error) {
	result := &struct {
		Script string `json:"qScript"`
	}{}
	err := obj.rpc(ctx, "GetScript", result)
	return result.Script, err
}

// Lists the breakpoints in the script of an app.
func (obj *Doc) GetScriptBreakpoints(ctx context.Context) ([]*EditorBreakpoint, error) {
	result := &struct {
		Breakpoints []*EditorBreakpoint `json:"qBreakpoints"`
	}{}
	err := obj.rpc(ctx, "GetScriptBreakpoints", result)
	return result.Breakpoints, err
}

// Lists the breakpoints in the script of an app.
func (obj *Doc) GetScriptBreakpointsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Breakpoints json.RawMessage `json:"qBreakpoints"`
	}{}
	err := obj.rpc(ctx, "GetScriptBreakpoints", result)
	return result.Breakpoints, err
}

// Gets script and script meta-data.
func (obj *Doc) GetScriptEx(ctx context.Context) (*AppScript, error) {
	result := &struct {
		Script *AppScript `json:"qScript"`
	}{}
	err := obj.rpc(ctx, "GetScriptEx", result)
	return result.Script, err
}

// Gets script and script meta-data.
func (obj *Doc) GetScriptExRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Script json.RawMessage `json:"qScript"`
	}{}
	err := obj.rpc(ctx, "GetScriptEx", result)
	return result.Script, err
}

// Returns a set analysis expression from active selections or from a saved bookmark. Fields on the fly and Calculated dimensions will not be included in the generated expressions, instead a message indicating 'missing fields' will provided within the expression.
//   | | BookmarkId empty | BookmarkId set |
//   |-----------------------|--------------------------------------|----------------------------------------------------|
//   |StateName empty (or $) | Default selections state is returned.| Default state ($) in bookmark with id is returned. |
//   |StateName set | State selections is returned. | State in bookmark with id is returned. |
//
// Parameters:
//
// ◾ stateName    -   Optional. The name of the state to get set analysis expression for. If left empty, the default state will be retrieved.
//
// ◾ bookmarkId   -   Optional. The Id of the bookmark to get the set analysis expression for. If left empty, the current selection will be retrieved.
//
func (obj *Doc) GetSetAnalysis(ctx context.Context, stateName string, bookmarkId string) (string, error) {
	result := &struct {
		SetExpression string `json:"qSetExpression"`
	}{}
	err := obj.rpc(ctx, "GetSetAnalysis", result, stateName, bookmarkId)
	return result.SetExpression, err
}

// Retrieves the data of a specific table.
//
// Parameters:
//
// ◾ offset          -   Position from the top, starting from 0.
// If the offset is set to 0, the rows starting from the position/index 0 are shown.
//
// ◾ rows            -   Number of rows to show.
//
// ◾ syntheticMode   -   If this parameter is set to true, the internal data/table representation is shown. Synthetic fields are present (if any).
//
// ◾ tableName       -   Name of the table.
//
func (obj *Doc) GetTableData(ctx context.Context, offset int, rows int, syntheticMode bool, tableName string) ([]*TableRow, error) {
	result := &struct {
		Data []*TableRow `json:"qData"`
	}{}
	err := obj.rpc(ctx, "GetTableData", result, offset, rows, syntheticMode, tableName)
	return result.Data, err
}

// Retrieves the data of a specific table.
//
// Parameters:
//
// ◾ offset          -   Position from the top, starting from 0.
// If the offset is set to 0, the rows starting from the position/index 0 are shown.
//
// ◾ rows            -   Number of rows to show.
//
// ◾ syntheticMode   -   If this parameter is set to true, the internal data/table representation is shown. Synthetic fields are present (if any).
//
// ◾ tableName       -   Name of the table.
//
func (obj *Doc) GetTableDataRaw(ctx context.Context, offset int, rows int, syntheticMode bool, tableName string) (json.RawMessage, error) {
	result := &struct {
		Data json.RawMessage `json:"qData"`
	}{}
	err := obj.rpc(ctx, "GetTableData", result, ensureEncodable(offset), ensureEncodable(rows), ensureEncodable(syntheticMode), ensureEncodable(tableName))
	return result.Data, err
}

// Returns:
//
// • The list of tables in an app and the fields inside each table.
//
// • The list of derived fields.
//
// • The list of key fields.
//
// Parameters:
//
// ◾ windowSize       -   Size of the window that is used to display the results.
//
// ◾ nullSize         -
//
// ◾ cellHeight       -   Height of a cell in a table in pixels.
//
// ◾ syntheticMode    -   One of:
//
// • true for internal table viewer:
// Shows a more detailed view on how the Qlik engine defines the relations between fields and the quality of the keys.
//
// • false for source table viewer:
// Shows the natural relation between fields without reference to synthetic keys and resultant linking synthetic tables. Instead synthetic keys are represented by multiple connectors between tables.
//
// ◾ includeSysVars   -   If set to true, the system variables are included.
//
func (obj *Doc) GetTablesAndKeys(ctx context.Context, windowSize *Size, nullSize *Size, cellHeight int, syntheticMode bool, includeSysVars bool) ([]*TableRecord, []*SourceKeyRecord, error) {
	result := &struct {
		Tr []*TableRecord     `json:"qtr"`
		K  []*SourceKeyRecord `json:"qk"`
	}{}
	err := obj.rpc(ctx, "GetTablesAndKeys", result, windowSize, nullSize, cellHeight, syntheticMode, includeSysVars)
	return result.Tr, result.K, err
}

// Returns:
//
// • The list of tables in an app and the fields inside each table.
//
// • The list of derived fields.
//
// • The list of key fields.
//
// Parameters:
//
// ◾ windowSize       -   Size of the window that is used to display the results.
//
// ◾ nullSize         -
//
// ◾ cellHeight       -   Height of a cell in a table in pixels.
//
// ◾ syntheticMode    -   One of:
//
// • true for internal table viewer:
// Shows a more detailed view on how the Qlik engine defines the relations between fields and the quality of the keys.
//
// • false for source table viewer:
// Shows the natural relation between fields without reference to synthetic keys and resultant linking synthetic tables. Instead synthetic keys are represented by multiple connectors between tables.
//
// ◾ includeSysVars   -   If set to true, the system variables are included.
//
func (obj *Doc) GetTablesAndKeysRaw(ctx context.Context, windowSize interface{}, nullSize interface{}, cellHeight int, syntheticMode bool, includeSysVars bool) (json.RawMessage, json.RawMessage, error) {
	result := &struct {
		Tr json.RawMessage `json:"qtr"`
		K  json.RawMessage `json:"qk"`
	}{}
	err := obj.rpc(ctx, "GetTablesAndKeys", result, ensureEncodable(windowSize), ensureEncodable(nullSize), ensureEncodable(cellHeight), ensureEncodable(syntheticMode), ensureEncodable(includeSysVars))
	return result.Tr, result.K, err
}

// Fetches updated variables after a statement execution.
//
// If qRefSeqNo and qSetSeqNo are set to 0, it means that the variables were not updated.
func (obj *Doc) GetTextMacros(ctx context.Context) ([]*TextMacro, error) {
	result := &struct {
		Macros []*TextMacro `json:"qMacros"`
	}{}
	err := obj.rpc(ctx, "GetTextMacros", result)
	return result.Macros, err
}

// Fetches updated variables after a statement execution.
//
// If qRefSeqNo and qSetSeqNo are set to 0, it means that the variables were not updated.
func (obj *Doc) GetTextMacrosRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Macros json.RawMessage `json:"qMacros"`
	}{}
	err := obj.rpc(ctx, "GetTextMacros", result)
	return result.Macros, err
}

// Returns a handle to a variable.
//
// Parameters:
//
// ◾ name   -   Name of the variable.
//
func (obj *Doc) GetVariable(ctx context.Context, name string) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetVariable", result, name)
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Gets the handle of a variable.
//
// Parameters:
//
// ◾ id   -   Identifier of the variable.
//
func (obj *Doc) GetVariableById(ctx context.Context, id string) (*Variable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetVariableById", result, id)
	if err != nil {
		return nil, err
	}
	return &Variable{obj.session.getRemoteObject(result.Return)}, err
}

// Gets the handle of a variable.
//
// Parameters:
//
// ◾ name   -   Name of the variable.
//
func (obj *Doc) GetVariableByName(ctx context.Context, name string) (*GenericVariable, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetVariableByName", result, name)
	if err != nil {
		return nil, err
	}
	return &GenericVariable{obj.session.getRemoteObject(result.Return)}, err
}

func (obj *Doc) GetVariables(ctx context.Context, listDef *VariableListDef) ([]*NxVariableListItem, error) {
	result := &struct {
		List []*NxVariableListItem `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetVariables", result, listDef)
	return result.List, err
}

func (obj *Doc) GetVariablesRaw(ctx context.Context, listDef interface{}) (json.RawMessage, error) {
	result := &struct {
		List json.RawMessage `json:"qList"`
	}{}
	err := obj.rpc(ctx, "GetVariables", result, ensureEncodable(listDef))
	return result.List, err
}

// Returns information about the position of the tables in the data model viewer.
// The position of the broom points and the position of the connection points cannot be retrieved in Qlik Sense.
//
// Representation of tables, broom points and connection points:
//
// ![](images/ui_gen_BroomConnectionPoints_dmv.png)
//
// The green circles represent the broom points.
// The red circle represents a connection point.
func (obj *Doc) GetViewDlgSaveInfo(ctx context.Context) (*TableViewDlgSaveInfo, error) {
	result := &struct {
		Return *TableViewDlgSaveInfo `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetViewDlgSaveInfo", result)
	return result.Return, err
}

// Returns information about the position of the tables in the data model viewer.
// The position of the broom points and the position of the connection points cannot be retrieved in Qlik Sense.
//
// Representation of tables, broom points and connection points:
//
// ![](images/ui_gen_BroomConnectionPoints_dmv.png)
//
// The green circles represent the broom points.
// The red circle represents a connection point.
func (obj *Doc) GetViewDlgSaveInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Return json.RawMessage `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetViewDlgSaveInfo", result)
	return result.Return, err
}

// Guesses the data format for a given file.
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection file.
//
// ◾ relativePath   -   Path of the connection file.
//
func (obj *Doc) GuessFileType(ctx context.Context, connectionId string, relativePath string) (*FileDataFormat, error) {
	result := &struct {
		DataFormat *FileDataFormat `json:"qDataFormat"`
	}{}
	err := obj.rpc(ctx, "GuessFileType", result, connectionId, relativePath)
	return result.DataFormat, err
}

// Guesses the data format for a given file.
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// FileType:
//
// Recognized file formats are:
//
// • CSV for Delimited
//
// • FIX for Fixed Record
//
// • DIF for Data Interchange Format
//
// • EXCELBIFF_ for Microsoft Excel (XLS)
//
// • EXCELOOXML_ for Microsoft Excel (XLSX)
//
// • HTML for HTML
//
// • QVD for QVD file
//
// • XML for XML
//
// • QVX for QVX file
//
// • JSON for JSON format
//
// • KML for KML file
//
// Parameters:
//
// ◾ connectionId   -   Identifier of the connection file.
//
// ◾ relativePath   -   Path of the connection file.
//
func (obj *Doc) GuessFileTypeRaw(ctx context.Context, connectionId string, relativePath string) (json.RawMessage, error) {
	result := &struct {
		DataFormat json.RawMessage `json:"qDataFormat"`
	}{}
	err := obj.rpc(ctx, "GuessFileType", result, ensureEncodable(connectionId), ensureEncodable(relativePath))
	return result.DataFormat, err
}

// Locks all selections in fields for current state.
//
// Parameters:
//
// ◾ stateName   -   Alternate state name. When set, applies to alternate state instead of current.
//
func (obj *Doc) LockAll(ctx context.Context, stateName string) error {
	err := obj.rpc(ctx, "LockAll", nil, stateName)
	return err
}

// Updates a connection.
// The identifier of a connection cannot be updated. qType cannot be modified with the ModifyConnection method.
//
// Parameters:
//
// ◾ connectionId          -   Identifier of the connection.
//
// ◾ connection            -   Information about the connection.
// Properties that can be updated.
//
// ◾ overrideCredentials   -   Set this parameter to true to override the user name and password.
//
func (obj *Doc) ModifyConnection(ctx context.Context, connectionId string, connection *Connection, overrideCredentials bool) error {
	err := obj.rpc(ctx, "ModifyConnection", nil, connectionId, connection, overrideCredentials)
	return err
}

// Updates a connection.
// The identifier of a connection cannot be updated. qType cannot be modified with the ModifyConnection method.
//
// Parameters:
//
// ◾ connectionId          -   Identifier of the connection.
//
// ◾ connection            -   Information about the connection.
// Properties that can be updated.
//
// ◾ overrideCredentials   -   Set this parameter to true to override the user name and password.
//
func (obj *Doc) ModifyConnectionRaw(ctx context.Context, connectionId string, connection interface{}, overrideCredentials bool) error {
	err := obj.rpc(ctx, "ModifyConnection", nil, ensureEncodable(connectionId), ensureEncodable(connection), ensureEncodable(overrideCredentials))
	return err
}

// Publishes an app.
// All app objects are published. Generic objects, bookmarks, dimensions and measures inside the app are published.
// An app can only be published once and cannot be published to more than one stream.
//
// Parameters:
//
// ◾ streamId   -   Identifier of the stream.
//
// ◾ name       -   Name of the published app.
// If this parameter is not set, the engine automatically gives a new name to the published app.
//
func (obj *Doc) Publish(ctx context.Context, streamId string, name string) error {
	err := obj.rpc(ctx, "Publish", nil, streamId, name)
	return err
}

// Redoes the previous operation.
//
// The operation is successful if qSuccess is set to true.
func (obj *Doc) Redo(ctx context.Context) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "Redo", result)
	return result.Success, err
}

// Removes an alternate state in the app.
//
// Parameters:
//
// ◾ stateName   -   Name of the alternate state.
//
func (obj *Doc) RemoveAlternateState(ctx context.Context, stateName string) error {
	err := obj.rpc(ctx, "RemoveAlternateState", nil, stateName)
	return err
}

// Removes a variable.
//
// Parameters:
//
// ◾ name   -   Name of the variable. Variable names are case sensitive.
//
func (obj *Doc) RemoveVariable(ctx context.Context, name string) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "RemoveVariable", result, name)
	return result.Return, err
}

// Resumes the app as the user left it.
func (obj *Doc) Resume(ctx context.Context) error {
	err := obj.rpc(ctx, "Resume", nil)
	return err
}

// Saves all objects that were modified in the app.
// Data from the data model are not saved.
// This operation is possible only in Qlik Sense Enterprise.
func (obj *Doc) SaveObjects(ctx context.Context) error {
	err := obj.rpc(ctx, "SaveObjects", nil)
	return err
}

// Scrambles a field so the data is not recognizable. Some properties are retained to help debugging. For example, special characters are not changed, and small numbers are scrambled to another small number.
// Update access is required to use the function in Qlik Sense Enterprise.
//
// Parameters:
//
// ◾ fieldName   -   Name of the field to scramble.
//
func (obj *Doc) Scramble(ctx context.Context, fieldName string) error {
	err := obj.rpc(ctx, "Scramble", nil, fieldName)
	return err
}

// Returns the search matches for one or more search terms.
// The search results depend on the search context.
// _SearchCombinationOptions_
//
// SearchMatchCombinations:
//
//   +--------------------------+-------------------------------+------------------------+
//   |           NAME           |          DESCRIPTION          |          TYPE          |
//   +--------------------------+-------------------------------+------------------------+
//   | qSearchMatchCombinations | Array of search combinations. | Array of               |
//   |                          |                               | SearchMatchCombination |
//   |                          |                               |                        |
//   +--------------------------+-------------------------------+------------------------+
//
// Parameters:
//
// ◾ options   -   Information about the search fields and the search context.
//
// ◾ terms     -   List of terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchAssociations(ctx context.Context, options *SearchCombinationOptions, terms []string, page *SearchPage) (*SearchAssociationResult, error) {
	result := &struct {
		Results *SearchAssociationResult `json:"qResults"`
	}{}
	err := obj.rpc(ctx, "SearchAssociations", result, options, terms, page)
	return result.Results, err
}

// Returns the search matches for one or more search terms.
// The search results depend on the search context.
// _SearchCombinationOptions_
//
// SearchMatchCombinations:
//
//   +--------------------------+-------------------------------+------------------------+
//   |           NAME           |          DESCRIPTION          |          TYPE          |
//   +--------------------------+-------------------------------+------------------------+
//   | qSearchMatchCombinations | Array of search combinations. | Array of               |
//   |                          |                               | SearchMatchCombination |
//   |                          |                               |                        |
//   +--------------------------+-------------------------------+------------------------+
//
// Parameters:
//
// ◾ options   -   Information about the search fields and the search context.
//
// ◾ terms     -   List of terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchAssociationsRaw(ctx context.Context, options interface{}, terms []string, page interface{}) (json.RawMessage, error) {
	result := &struct {
		Results json.RawMessage `json:"qResults"`
	}{}
	err := obj.rpc(ctx, "SearchAssociations", result, ensureEncodable(options), ensureEncodable(terms), ensureEncodable(page))
	return result.Results, err
}

// Returns the generic objects corresponding to one or more search terms. The search is performed within the title, subtitle, footnote and type. In addition, associated dimension values are also searched in. For example, if the country “Japan” is selected and the object contains the dimension City, the object will appear in the results for “Osaka” but not for “Johannesburg”. The generic objects with the following types will never appear in the results: slideitem , sheet , story , slide , masterobject , snapshot , LoadModel , appprops and searchhistory .
//
// Parameters:
//
// ◾ options   -   Information about attributes.
//
// ◾ terms     -   Terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchObjects(ctx context.Context, options *SearchObjectOptions, terms []string, page *SearchPage) (*SearchResult, error) {
	result := &struct {
		Result *SearchResult `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchObjects", result, options, terms, page)
	return result.Result, err
}

// Returns the generic objects corresponding to one or more search terms. The search is performed within the title, subtitle, footnote and type. In addition, associated dimension values are also searched in. For example, if the country “Japan” is selected and the object contains the dimension City, the object will appear in the results for “Osaka” but not for “Johannesburg”. The generic objects with the following types will never appear in the results: slideitem , sheet , story , slide , masterobject , snapshot , LoadModel , appprops and searchhistory .
//
// Parameters:
//
// ◾ options   -   Information about attributes.
//
// ◾ terms     -   Terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchObjectsRaw(ctx context.Context, options interface{}, terms []string, page interface{}) (json.RawMessage, error) {
	result := &struct {
		Result json.RawMessage `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchObjects", result, ensureEncodable(options), ensureEncodable(terms), ensureEncodable(page))
	return result.Result, err
}

// Returns the search matches for one or more search terms.
// Search results are organized in search groups. The type of search group indicates where the search matches come from (from data for example).
// Each search group contains search results that correspond to a combination of search terms.
// For example, if the search terms are organic , pasta , and America , the possible combination of search groups are:
//
// • organic
//
// • pasta
//
// • America
//
// • organic, pasta, America
//
// • organic, pasta
//
// • organic, America
//
// • pasta, America
//
// For every search group, there are one or more search group items. Each subgroup item contains results that correspond to an item type (for example a field).
// For every search group item, there are one or several search matches. The position of the match in each search result is given.
//
// Parameters:
//
// ◾ options   -   Information about the search combinations.
//
// ◾ terms     -   Terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchResults(ctx context.Context, options *SearchCombinationOptions, terms []string, page *SearchPage) (*SearchResult, error) {
	result := &struct {
		Result *SearchResult `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchResults", result, options, terms, page)
	return result.Result, err
}

// Returns the search matches for one or more search terms.
// Search results are organized in search groups. The type of search group indicates where the search matches come from (from data for example).
// Each search group contains search results that correspond to a combination of search terms.
// For example, if the search terms are organic , pasta , and America , the possible combination of search groups are:
//
// • organic
//
// • pasta
//
// • America
//
// • organic, pasta, America
//
// • organic, pasta
//
// • organic, America
//
// • pasta, America
//
// For every search group, there are one or more search group items. Each subgroup item contains results that correspond to an item type (for example a field).
// For every search group item, there are one or several search matches. The position of the match in each search result is given.
//
// Parameters:
//
// ◾ options   -   Information about the search combinations.
//
// ◾ terms     -   Terms to search for.
//
// ◾ page      -   Array of pages to retrieve.
//
func (obj *Doc) SearchResultsRaw(ctx context.Context, options interface{}, terms []string, page interface{}) (json.RawMessage, error) {
	result := &struct {
		Result json.RawMessage `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchResults", result, ensureEncodable(options), ensureEncodable(terms), ensureEncodable(page))
	return result.Result, err
}

// Returns search terms suggestions.
//
// Parameters:
//
// ◾ options   -   Information about the search combinations.
//
// ◾ terms     -   Terms to search for.
//
func (obj *Doc) SearchSuggest(ctx context.Context, options *SearchCombinationOptions, terms []string) (*SearchSuggestionResult, error) {
	result := &struct {
		Result *SearchSuggestionResult `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchSuggest", result, options, terms)
	return result.Result, err
}

// Returns search terms suggestions.
//
// Parameters:
//
// ◾ options   -   Information about the search combinations.
//
// ◾ terms     -   Terms to search for.
//
func (obj *Doc) SearchSuggestRaw(ctx context.Context, options interface{}, terms []string) (json.RawMessage, error) {
	result := &struct {
		Result json.RawMessage `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SearchSuggest", result, ensureEncodable(options), ensureEncodable(terms))
	return result.Result, err
}

// Selects all search hits for a specified group.
// The results depend on the search context.
// _SearchCombinationOptions_.
//
// Parameters:
//
// ◾ options    -   Information about the search fields and the search context.
//
// ◾ terms      -   List of terms to search for.
//
// ◾ matchIx    -   Index (value of qId ) of the search result to select.
//
// ◾ softLock   -   This parameter is deprecated and should not be set.
//
func (obj *Doc) SelectAssociations(ctx context.Context, options *SearchCombinationOptions, terms []string, matchIx int, softLock bool) error {
	err := obj.rpc(ctx, "SelectAssociations", nil, options, terms, matchIx, softLock)
	return err
}

// Selects all search hits for a specified group.
// The results depend on the search context.
// _SearchCombinationOptions_.
//
// Parameters:
//
// ◾ options    -   Information about the search fields and the search context.
//
// ◾ terms      -   List of terms to search for.
//
// ◾ matchIx    -   Index (value of qId ) of the search result to select.
//
// ◾ softLock   -   This parameter is deprecated and should not be set.
//
func (obj *Doc) SelectAssociationsRaw(ctx context.Context, options interface{}, terms []string, matchIx int, softLock bool) error {
	err := obj.rpc(ctx, "SelectAssociations", nil, ensureEncodable(options), ensureEncodable(terms), ensureEncodable(matchIx), ensureEncodable(softLock))
	return err
}

// Sends a generic command to a custom connector.
// For more information on the commands that can be sent to a custom connector, see the QVX SDK help.
//
// Parameters:
//
// ◾ provider           -   Connector file name.
// Command to be executed by the connector.
//
// ◾ command            -   One of:
//
// • JsonRequest
//
// • GetCustomCaption
//
// • IsConnected
//
// • DisableQlikViewSelectButton
//
// • HaveStarField
//
// ◾ method             -   Method name to be used within the command.
// The available methods depend on the chosen connector.
//
// ◾ parameters         -   Parameters of the command.
// No parameters are required.
//
// ◾ appendConnection   -   Name of the connection.
//
func (obj *Doc) SendGenericCommandToCustomConnector(ctx context.Context, provider string, command string, method string, parameters []string, appendConnection string) (string, error) {
	result := &struct {
		Result string `json:"qResult"`
	}{}
	err := obj.rpc(ctx, "SendGenericCommandToCustomConnector", result, provider, command, method, parameters, appendConnection)
	return result.Result, err
}

// Sets properties to an app.
// The qLastReloadTime, qMigrationHash and qSavedInProductVersion properties does not need to be set but if they are, they should match the current values in the app layout.
//
// Parameters:
//
// ◾ prop   -   Information about the properties of an app.
//
func (obj *Doc) SetAppProperties(ctx context.Context, prop *NxAppProperties) error {
	err := obj.rpc(ctx, "SetAppProperties", nil, prop)
	return err
}

// Sets properties to an app.
// The qLastReloadTime, qMigrationHash and qSavedInProductVersion properties does not need to be set but if they are, they should match the current values in the app layout.
//
// Parameters:
//
// ◾ prop   -   Information about the properties of an app.
//
func (obj *Doc) SetAppPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetAppProperties", nil, ensureEncodable(prop))
	return err
}

// Set some variables as favorite.
//
// Parameters:
//
// ◾ names   -   Variables to set as favorite.
//
func (obj *Doc) SetFavoriteVariables(ctx context.Context, names []string) error {
	err := obj.rpc(ctx, "SetFavoriteVariables", nil, names)
	return err
}

// Limits the number of rows of data to load from a data source.
// This method works when reloading in debug mode.
//
// Parameters:
//
// ◾ limit   -   Fetch limit.
// Number of rows to load.
//
func (obj *Doc) SetFetchLimit(ctx context.Context, limit int) error {
	err := obj.rpc(ctx, "SetFetchLimit", nil, limit)
	return err
}

// Sets a list of table states, one for each table.
//
// The following states apply:
//
// • 0 The table is not loosely coupled.
//
// • 1 The table is loosely coupled.
//
// • 2 The table is loosely coupled and cannot be changed to another state using the Qlik Engine API.
//
// The last three values in the vector are for internal use.
//
// Parameters:
//
// ◾ v   -   The list of table states to set. A state will not be changed if already set to 2.
//
func (obj *Doc) SetLooselyCoupledVector(ctx context.Context, v []string) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SetLooselyCoupledVector", result, v)
	return result.Return, err
}

// Sets values in script.
//
// Parameters:
//
// ◾ script   -   Script content.
//
func (obj *Doc) SetScript(ctx context.Context, script string) error {
	err := obj.rpc(ctx, "SetScript", nil, script)
	return err
}

// Set some breakpoints in the script of an app.
//
// Parameters:
//
// ◾ breakpoints   -   Information about the breakpoints.
//
func (obj *Doc) SetScriptBreakpoints(ctx context.Context, breakpoints []*EditorBreakpoint) error {
	err := obj.rpc(ctx, "SetScriptBreakpoints", nil, breakpoints)
	return err
}

// Set some breakpoints in the script of an app.
//
// Parameters:
//
// ◾ breakpoints   -   Information about the breakpoints.
//
func (obj *Doc) SetScriptBreakpointsRaw(ctx context.Context, breakpoints interface{}) error {
	err := obj.rpc(ctx, "SetScriptBreakpoints", nil, ensureEncodable(breakpoints))
	return err
}

// Sets the positions of the tables in the data model viewer.
// The position of the broom points and the position of the connection points cannot be set in Qlik Sense.
//
// Representation of tables, broom points and connection points:
//
// ![](images/ui_gen_BroomConnectionPoints_dmv.png)
//
// The green circles represent the broom points.
// The red circle represents a connection point.
//
// Parameters:
//
// ◾ info   -   Information about the table.
//
func (obj *Doc) SetViewDlgSaveInfo(ctx context.Context, info *TableViewDlgSaveInfo) error {
	err := obj.rpc(ctx, "SetViewDlgSaveInfo", nil, info)
	return err
}

// Sets the positions of the tables in the data model viewer.
// The position of the broom points and the position of the connection points cannot be set in Qlik Sense.
//
// Representation of tables, broom points and connection points:
//
// ![](images/ui_gen_BroomConnectionPoints_dmv.png)
//
// The green circles represent the broom points.
// The red circle represents a connection point.
//
// Parameters:
//
// ◾ info   -   Information about the table.
//
func (obj *Doc) SetViewDlgSaveInfoRaw(ctx context.Context, info interface{}) error {
	err := obj.rpc(ctx, "SetViewDlgSaveInfo", nil, ensureEncodable(info))
	return err
}

// Undoes the previous operation.
//
// The operation is successful if qSuccess is set to true.
func (obj *Doc) Undo(ctx context.Context) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "Undo", result)
	return result.Success, err
}

// Unlocks all selections in fields for current state.
//
// Parameters:
//
// ◾ stateName   -   Alternate state name. When set, applies to alternate state instead of current.
//
func (obj *Doc) UnlockAll(ctx context.Context, stateName string) error {
	err := obj.rpc(ctx, "UnlockAll", nil, stateName)
	return err
}

// This class describes all the methods that apply at field level.
// The handle member in the JSON request for all methods listed in this section is the handle of the field.
type Field struct {
	*RemoteObject
}

// Clears the selections in a specific field.
func (obj *Field) Clear(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "Clear", result)
	return result.Return, err
}

// Maintains the selections in the current field while clearing the selections in the other fields.
//
// Parameters:
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) ClearAllButThis(ctx context.Context, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "ClearAllButThis", result, softLock)
	return result.Return, err
}

// Returns the AND mode status of a field.
func (obj *Field) GetAndMode(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetAndMode", result)
	return result.Return, err
}

// Retrieves the number of distinct values in a field.
func (obj *Field) GetCardinal(ctx context.Context) (int, error) {
	result := &struct {
		Return int `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetCardinal", result)
	return result.Return, err
}

// Gets the properties of a field.
//
// The property OneAndOnlyOne is set to true if one and only value has been selected in the field prior setting the property.
func (obj *Field) GetNxProperties(ctx context.Context) (*NxFieldProperties, error) {
	result := &struct {
		Properties *NxFieldProperties `json:"qProperties"`
	}{}
	err := obj.rpc(ctx, "GetNxProperties", result)
	return result.Properties, err
}

// Gets the properties of a field.
//
// The property OneAndOnlyOne is set to true if one and only value has been selected in the field prior setting the property.
func (obj *Field) GetNxPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Properties json.RawMessage `json:"qProperties"`
	}{}
	err := obj.rpc(ctx, "GetNxProperties", result)
	return result.Properties, err
}

// Locks all selected values of a specific field.
func (obj *Field) Lock(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "Lock", result)
	return result.Return, err
}

// Selects some values in a field, by entering the element numbers related to the values to select.
//
// Parameters:
//
// ◾ values       -   Indexes (or element numbers) of the values to select.
//
// ◾ toggleMode   -   Set to true to keep any selections present in the list object.
// If this parameter is set to false, selections made before accepting the list object search become alternative.
//
// ◾ softLock     -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) LowLevelSelect(ctx context.Context, values []int, toggleMode bool, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "LowLevelSelect", result, values, toggleMode, softLock)
	return result.Return, err
}

// Selects field values matching a search string.
//
// Parameters:
//
// ◾ match                -   String to search for.
// Can contain wild cards or numeric search criteria.
//
// ◾ softLock             -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
// ◾ excludedValuesMode   -   Include excluded values in search.
//
func (obj *Field) Select(ctx context.Context, match string, softLock bool, excludedValuesMode int) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "Select", result, match, softLock, excludedValuesMode)
	return result.Return, err
}

// Selects all values of a field. Excluded values are also selected.
//
// Parameters:
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectAll(ctx context.Context, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectAll", result, softLock)
	return result.Return, err
}

// Selects all alternatives values in a specific field.
// In a field that contains at least one selected value, the values that are neither selected nor excluded are alternatives values.
//
// Parameters:
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectAlternative(ctx context.Context, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectAlternative", result, softLock)
	return result.Return, err
}

// Inverts the current selections.
//
// Parameters:
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectExcluded(ctx context.Context, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectExcluded", result, softLock)
	return result.Return, err
}

// Selects all possible values in a specific field.
//
// Parameters:
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectPossible(ctx context.Context, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectPossible", result, softLock)
	return result.Return, err
}

// Selects some values in a field, by entering the values to select.
//
// Parameters:
//
// ◾ fieldValues   -   List of the values to select.
//
// ◾ toggleMode    -   The default value is false.
//
// ◾ softLock      -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectValues(ctx context.Context, fieldValues []*FieldValue, toggleMode bool, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectValues", result, fieldValues, toggleMode, softLock)
	return result.Return, err
}

// Selects some values in a field, by entering the values to select.
//
// Parameters:
//
// ◾ fieldValues   -   List of the values to select.
//
// ◾ toggleMode    -   The default value is false.
//
// ◾ softLock      -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *Field) SelectValuesRaw(ctx context.Context, fieldValues interface{}, toggleMode bool, softLock bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SelectValues", result, ensureEncodable(fieldValues), ensureEncodable(toggleMode), ensureEncodable(softLock))
	return result.Return, err
}

// Sets a field in the AND mode.
//
// Parameters:
//
// ◾ andMode   -   Specifies if the AND mode applies to the field.
// Set this parameter to true to enter the AND mode.
//
func (obj *Field) SetAndMode(ctx context.Context, andMode bool) error {
	err := obj.rpc(ctx, "SetAndMode", nil, andMode)
	return err
}

// Sets some properties to a field.
//
// Parameters:
//
// ◾ properties   -   Information about the properties of the field.
//
func (obj *Field) SetNxProperties(ctx context.Context, properties *NxFieldProperties) error {
	err := obj.rpc(ctx, "SetNxProperties", nil, properties)
	return err
}

// Sets some properties to a field.
//
// Parameters:
//
// ◾ properties   -   Information about the properties of the field.
//
func (obj *Field) SetNxPropertiesRaw(ctx context.Context, properties interface{}) error {
	err := obj.rpc(ctx, "SetNxProperties", nil, ensureEncodable(properties))
	return err
}

// Toggle selects field values matching a search string.
//
// Parameters:
//
// ◾ match                -   String to search for.
// Can contain wild cards or numeric search criteria.
//
// ◾ softLock             -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
// ◾ excludedValuesMode   -   Include excluded values in search.
//
func (obj *Field) ToggleSelect(ctx context.Context, match string, softLock bool, excludedValuesMode int) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "ToggleSelect", result, match, softLock, excludedValuesMode)
	return result.Return, err
}

// Unlocks all selected values of a specific field if the target (or handle ) is a field.
func (obj *Field) Unlock(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "Unlock", result)
	return result.Return, err
}

// This class describes all the methods that apply at bookmark level.
// The handle member in the JSON request for all methods listed in this section is the handle of the bookmark.
type GenericBookmark struct {
	*RemoteObject
}

// Applies a bookmark.
//
// The operation is successful if qSuccess is set to true.
func (obj *GenericBookmark) Apply(ctx context.Context) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "Apply", result)
	return result.Success, err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericBookmark) ApplyPatches(ctx context.Context, patches []*NxPatch) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, patches)
	return err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericBookmark) ApplyPatchesRaw(ctx context.Context, patches interface{}) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, ensureEncodable(patches))
	return err
}

// Adds the generic bookmark to the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericBookmark) Approve(ctx context.Context) error {
	err := obj.rpc(ctx, "Approve", nil)
	return err
}

// Retrieves the values of a field.
//
// Fieldvalue:
//
//   +------------+--------------------------------+---------+
//   |    NAME    |          DESCRIPTION           |  TYPE   |
//   +------------+--------------------------------+---------+
//   | qText      | Text related to the field      | String  |
//   |            | value.                         |         |
//   | qIsNumeric | Is set to true if the value is | Boolean |
//   |            | a numeric.  Default is false.  |         |
//   | qNumber    | Numeric value of the field.    | Double  |
//   |            | This parameter is displayed if |         |
//   |            | qIsNumeric is set to true.     |         |
//   +------------+--------------------------------+---------+
//
// Parameters:
//
// ◾ field               -   Name of the field.
//
// ◾ getExcludedValues   -   If set to true, only excluded values are returned.
//
// ◾ dataPage            -   Range of returned values.
//
func (obj *GenericBookmark) GetFieldValues(ctx context.Context, field string, getExcludedValues bool, dataPage *BookmarkFieldPage) ([]*FieldValue, error) {
	result := &struct {
		FieldValues []*FieldValue `json:"qFieldValues"`
	}{}
	err := obj.rpc(ctx, "GetFieldValues", result, field, getExcludedValues, dataPage)
	return result.FieldValues, err
}

// Retrieves the values of a field.
//
// Fieldvalue:
//
//   +------------+--------------------------------+---------+
//   |    NAME    |          DESCRIPTION           |  TYPE   |
//   +------------+--------------------------------+---------+
//   | qText      | Text related to the field      | String  |
//   |            | value.                         |         |
//   | qIsNumeric | Is set to true if the value is | Boolean |
//   |            | a numeric.  Default is false.  |         |
//   | qNumber    | Numeric value of the field.    | Double  |
//   |            | This parameter is displayed if |         |
//   |            | qIsNumeric is set to true.     |         |
//   +------------+--------------------------------+---------+
//
// Parameters:
//
// ◾ field               -   Name of the field.
//
// ◾ getExcludedValues   -   If set to true, only excluded values are returned.
//
// ◾ dataPage            -   Range of returned values.
//
func (obj *GenericBookmark) GetFieldValuesRaw(ctx context.Context, field string, getExcludedValues bool, dataPage interface{}) (json.RawMessage, error) {
	result := &struct {
		FieldValues json.RawMessage `json:"qFieldValues"`
	}{}
	err := obj.rpc(ctx, "GetFieldValues", result, ensureEncodable(field), ensureEncodable(getExcludedValues), ensureEncodable(dataPage))
	return result.FieldValues, err
}

// Returns:
//
// • The type of the object.
//
// • The identifier of the object.
func (obj *GenericBookmark) GetInfo(ctx context.Context) (*NxInfo, error) {
	result := &struct {
		Info *NxInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Returns:
//
// • The type of the object.
//
// • The identifier of the object.
func (obj *GenericBookmark) GetInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated.
func (obj *GenericBookmark) GetLayout(ctx context.Context) (*GenericBookmarkLayout, error) {
	result := &struct {
		Layout *GenericBookmarkLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated.
func (obj *GenericBookmark) GetLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Shows the properties of an object.
// If the member delta is set to true in the request object, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericBookmark) GetProperties(ctx context.Context) (*GenericBookmarkProperties, error) {
	result := &struct {
		Prop *GenericBookmarkProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Shows the properties of an object.
// If the member delta is set to true in the request object, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericBookmark) GetPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Publishes a bookmark.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericBookmark) Publish(ctx context.Context) error {
	err := obj.rpc(ctx, "Publish", nil)
	return err
}

// Sets some properties for a bookmark.
//
// Parameters:
//
// ◾ prop   -   Information about the bookmark.
//
func (obj *GenericBookmark) SetProperties(ctx context.Context, prop *GenericBookmarkProperties) error {
	err := obj.rpc(ctx, "SetProperties", nil, prop)
	return err
}

// Sets some properties for a bookmark.
//
// Parameters:
//
// ◾ prop   -   Information about the bookmark.
//
func (obj *GenericBookmark) SetPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetProperties", nil, ensureEncodable(prop))
	return err
}

// Removes the generic bookmark from the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericBookmark) UnApprove(ctx context.Context) error {
	err := obj.rpc(ctx, "UnApprove", nil)
	return err
}

// Unpublishes a bookmark.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericBookmark) UnPublish(ctx context.Context) error {
	err := obj.rpc(ctx, "UnPublish", nil)
	return err
}

// This class describes all the methods that apply at dimension level.
// The handle member in the JSON request for all methods listed in this section is the handle of the dimension.
type GenericDimension struct {
	*RemoteObject
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericDimension) ApplyPatches(ctx context.Context, patches []*NxPatch) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, patches)
	return err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericDimension) ApplyPatchesRaw(ctx context.Context, patches interface{}) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, ensureEncodable(patches))
	return err
}

// Adds the generic dimension to the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericDimension) Approve(ctx context.Context) error {
	err := obj.rpc(ctx, "Approve", nil)
	return err
}

// Returns the definition of a dimension.
//
// The definition of the dimension is returned.
func (obj *GenericDimension) GetDimension(ctx context.Context) (*NxLibraryDimensionDef, error) {
	result := &struct {
		Dim *NxLibraryDimensionDef `json:"qDim"`
	}{}
	err := obj.rpc(ctx, "GetDimension", result)
	return result.Dim, err
}

// Returns the definition of a dimension.
//
// The definition of the dimension is returned.
func (obj *GenericDimension) GetDimensionRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Dim json.RawMessage `json:"qDim"`
	}{}
	err := obj.rpc(ctx, "GetDimension", result)
	return result.Dim, err
}

// Returns the type and identifier of the object.
func (obj *GenericDimension) GetInfo(ctx context.Context) (*NxInfo, error) {
	result := &struct {
		Info *NxInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Returns the type and identifier of the object.
func (obj *GenericDimension) GetInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Evaluates a dimension and displays its properties, including the dynamic properties.
func (obj *GenericDimension) GetLayout(ctx context.Context) (*GenericDimensionLayout, error) {
	result := &struct {
		Layout *GenericDimensionLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Evaluates a dimension and displays its properties, including the dynamic properties.
func (obj *GenericDimension) GetLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericDimension) GetLinkedObjects(ctx context.Context) ([]*NxLinkedObjectInfo, error) {
	result := &struct {
		Items []*NxLinkedObjectInfo `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericDimension) GetLinkedObjectsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Items json.RawMessage `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Shows the properties of an object.
// Returns the identifier and the definition of the dimension.
// If the member delta is set to true in the request object, only the delta is retrieved.
func (obj *GenericDimension) GetProperties(ctx context.Context) (*GenericDimensionProperties, error) {
	result := &struct {
		Prop *GenericDimensionProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Shows the properties of an object.
// Returns the identifier and the definition of the dimension.
// If the member delta is set to true in the request object, only the delta is retrieved.
func (obj *GenericDimension) GetPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Publishes a dimension.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericDimension) Publish(ctx context.Context) error {
	err := obj.rpc(ctx, "Publish", nil)
	return err
}

// Sets some properties for a dimension.
//
// Parameters:
//
// ◾ prop   -   Information about the dimension.
//
func (obj *GenericDimension) SetProperties(ctx context.Context, prop *GenericDimensionProperties) error {
	err := obj.rpc(ctx, "SetProperties", nil, prop)
	return err
}

// Sets some properties for a dimension.
//
// Parameters:
//
// ◾ prop   -   Information about the dimension.
//
func (obj *GenericDimension) SetPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetProperties", nil, ensureEncodable(prop))
	return err
}

// Removes the generic dimension from the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericDimension) UnApprove(ctx context.Context) error {
	err := obj.rpc(ctx, "UnApprove", nil)
	return err
}

// Unpublishes a dimension.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericDimension) UnPublish(ctx context.Context) error {
	err := obj.rpc(ctx, "UnPublish", nil)
	return err
}

// This class describes all the methods that apply at measure level.
// The handle member in the JSON request for all methods listed in this section is the handle of the measure.
type GenericMeasure struct {
	*RemoteObject
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericMeasure) ApplyPatches(ctx context.Context, patches []*NxPatch) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, patches)
	return err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericMeasure) ApplyPatchesRaw(ctx context.Context, patches interface{}) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, ensureEncodable(patches))
	return err
}

// Adds the generic measure to the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericMeasure) Approve(ctx context.Context) error {
	err := obj.rpc(ctx, "Approve", nil)
	return err
}

// Returns the type and identifier of the object.
func (obj *GenericMeasure) GetInfo(ctx context.Context) (*NxInfo, error) {
	result := &struct {
		Info *NxInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Returns the type and identifier of the object.
func (obj *GenericMeasure) GetInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Evaluates a measure and displays its properties, including the dynamic properties.
func (obj *GenericMeasure) GetLayout(ctx context.Context) (*GenericMeasureLayout, error) {
	result := &struct {
		Layout *GenericMeasureLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Evaluates a measure and displays its properties, including the dynamic properties.
func (obj *GenericMeasure) GetLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericMeasure) GetLinkedObjects(ctx context.Context) ([]*NxLinkedObjectInfo, error) {
	result := &struct {
		Items []*NxLinkedObjectInfo `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericMeasure) GetLinkedObjectsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Items json.RawMessage `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Returns the definition of a measure.
func (obj *GenericMeasure) GetMeasure(ctx context.Context) (*NxLibraryMeasureDef, error) {
	result := &struct {
		Measure *NxLibraryMeasureDef `json:"qMeasure"`
	}{}
	err := obj.rpc(ctx, "GetMeasure", result)
	return result.Measure, err
}

// Returns the definition of a measure.
func (obj *GenericMeasure) GetMeasureRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Measure json.RawMessage `json:"qMeasure"`
	}{}
	err := obj.rpc(ctx, "GetMeasure", result)
	return result.Measure, err
}

// Shows the properties of an object.
// Returns the identifier and the definition of the measure.
// If the member delta is set to true in the request object, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericMeasure) GetProperties(ctx context.Context) (*GenericMeasureProperties, error) {
	result := &struct {
		Prop *GenericMeasureProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Shows the properties of an object.
// Returns the identifier and the definition of the measure.
// If the member delta is set to true in the request object, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericMeasure) GetPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Publishes a measure.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericMeasure) Publish(ctx context.Context) error {
	err := obj.rpc(ctx, "Publish", nil)
	return err
}

// Sets some properties for a measure.
//
// Parameters:
//
// ◾ prop   -   Information about the measure.
//
func (obj *GenericMeasure) SetProperties(ctx context.Context, prop *GenericMeasureProperties) error {
	err := obj.rpc(ctx, "SetProperties", nil, prop)
	return err
}

// Sets some properties for a measure.
//
// Parameters:
//
// ◾ prop   -   Information about the measure.
//
func (obj *GenericMeasure) SetPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetProperties", nil, ensureEncodable(prop))
	return err
}

// Removes the generic measure from the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericMeasure) UnApprove(ctx context.Context) error {
	err := obj.rpc(ctx, "UnApprove", nil)
	return err
}

// Unpublishes a measure.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericMeasure) UnPublish(ctx context.Context) error {
	err := obj.rpc(ctx, "UnPublish", nil)
	return err
}

// This class describes all the methods that apply at generic object level.
// The handle member in the JSON request for all methods listed in this section is the handle of the generic object.
type GenericObject struct {
	*RemoteObject
}

// Aborts the results of a search in a list object.
// This method applies to list objects (objects with one dimension).
// After an abort on a list object search, the GetLayout Method does not return any more search results but it does return the values in the field.
//
// Parameters:
//
// ◾ path   -   Path to the definition of the list object.
// For example, /qListObjectDef .
//
func (obj *GenericObject) AbortListObjectSearch(ctx context.Context, path string) error {
	err := obj.rpc(ctx, "AbortListObjectSearch", nil, path)
	return err
}

// Accept the results of a search in a list object. The search results become selected in the field.
// This method applies to list objects (objects with one dimension).
// The search results are displayed using the GetLayout Method.
//
// Parameters:
//
// ◾ path         -   Path to the definition of the list object.
// For example, /qListObjectDef .
//
// ◾ toggleMode   -   Set to true to keep any selections present in the list object.
// If this parameter is set to false, selections made before accepting the list object search become alternative.
//
// ◾ softLock     -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) AcceptListObjectSearch(ctx context.Context, path string, toggleMode bool, softLock bool) error {
	err := obj.rpc(ctx, "AcceptListObjectSearch", nil, path, toggleMode, softLock)
	return err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// It is possible to apply a patch to the properties of a generic object, that is not persistent. Such a patch is called a soft patch.
// In that case, the result of the operation on the properties (add, remove or delete) is not shown when doing GetProperties , and only a GetLayout call shows the result of the operation.
// Properties that are not persistent are called soft properties. Once the engine session is over, soft properties are cleared.
// Soft properties apply only to generic objects.
//
// Parameters:
//
// ◾ patches     -   Array of patches.
//
// ◾ softPatch   -   If set to true, it means that the properties to be applied are not persistent. The patch is a soft patch.
// The default value is false.
//
func (obj *GenericObject) ApplyPatches(ctx context.Context, patches []*NxPatch, softPatch bool) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, patches, softPatch)
	return err
}

// Applies a patch to the properties of an object. Allows an update to some of the properties.
// It is possible to apply a patch to the properties of a generic object, that is not persistent. Such a patch is called a soft patch.
// In that case, the result of the operation on the properties (add, remove or delete) is not shown when doing GetProperties , and only a GetLayout call shows the result of the operation.
// Properties that are not persistent are called soft properties. Once the engine session is over, soft properties are cleared.
// Soft properties apply only to generic objects.
//
// Parameters:
//
// ◾ patches     -   Array of patches.
//
// ◾ softPatch   -   If set to true, it means that the properties to be applied are not persistent. The patch is a soft patch.
// The default value is false.
//
func (obj *GenericObject) ApplyPatchesRaw(ctx context.Context, patches interface{}, softPatch bool) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, ensureEncodable(patches), ensureEncodable(softPatch))
	return err
}

// Adds the generic object to the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericObject) Approve(ctx context.Context) error {
	err := obj.rpc(ctx, "Approve", nil)
	return err
}

// Begins the selection mode. The app enters the modal state. The specified object enters the selection mode and a modal window is opened. The selection mode can apply to only one object in an app at a time.
// When a visualization is in selection mode, selections can be made in this visualization. The visualization is not sorted until the selection mode is ended. Once the selection mode is ended and if the selections are accepted, the visualization is sorted according to the sort criteria. For more information about:
//
// • Ending the selection mode, see EndSelections Method.
//
// • The sort criteria, see ListObjectDef or HyperCubeDef.
//
// Example:
//
// A sheet contains a list object and a chart. If the list object is in selection mode then the chart cannot be in selection mode. No selection on the chart can be made until the list object exits the selection mode.
//
// Parameters:
//
// ◾ paths   -   List of the paths to the definition of the objects to enter selection mode.
// For example, /qListObjectDef .
//
func (obj *GenericObject) BeginSelections(ctx context.Context, paths []string) error {
	err := obj.rpc(ctx, "BeginSelections", nil, paths)
	return err
}

// Clears the selections in a dimension of a visualization.
//
// Parameters:
//
// ◾ path         -   Path to the definition of the visualization.
// For example, /qListObjectDef .
//
// ◾ colIndices   -   Array of dimension numbers or indexes. The selections are cleared in the specified dimensions.
// Dimension numbers/indexes start from 0.
// If this parameter is not set, all dimensions are cleared.
//
func (obj *GenericObject) ClearSelections(ctx context.Context, path string, colIndices []int) error {
	err := obj.rpc(ctx, "ClearSelections", nil, path, colIndices)
	return err
}

// Clears the soft properties of a generic object.
// For more information on how to add soft properties to a generic object, see ApplyPatches Method.
func (obj *GenericObject) ClearSoftPatches(ctx context.Context) error {
	err := obj.rpc(ctx, "ClearSoftPatches", nil)
	return err
}

// Collapses the left dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
// In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
//
// Parameters:
//
// ◾ path   -   Path to the definition of the object to be collapsed.
// For example, /qHyperCubeDef .
//
// ◾ row    -   Row index in the data matrix.
// Indexing starts from 0.
//
// ◾ col    -   Column index. The index is based on the left dimension indexes.
// Indexing starts from 0.
//
// ◾ all    -   If set to true, it collapses all cells.
// Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
//
func (obj *GenericObject) CollapseLeft(ctx context.Context, path string, row int, col int, all bool) error {
	err := obj.rpc(ctx, "CollapseLeft", nil, path, row, col, all)
	return err
}

// Collapses the top dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
// In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
//
// Parameters:
//
// ◾ path   -   Path to the definition of the object to be collapsed
// For example, /qHyperCubeDef .
//
// ◾ row    -   Row index. The index is based on the top dimension indexes.
// Indexing starts from 0.
//
// ◾ col    -   Column index in the data matrix.
// Indexing starts from 0.
//
// ◾ all    -   If set to true, it collapses all cells.
// Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
//
func (obj *GenericObject) CollapseTop(ctx context.Context, path string, row int, col int, all bool) error {
	err := obj.rpc(ctx, "CollapseTop", nil, path, row, col, all)
	return err
}

// Copies the properties of a generic object and its children.
// The source object is specified by the parameter qFromId and the destination object is referenced by its handle.
// The identifier of the destination object is the same as before the copy takes place.
//
// Parameters:
//
// ◾ fromId   -   Identifier of the object to copy.
//
func (obj *GenericObject) CopyFrom(ctx context.Context, fromId string) error {
	err := obj.rpc(ctx, "CopyFrom", nil, fromId)
	return err
}

// Creates a generic object that is a child of another generic object.
// It is possible to update the properties of the child's parent at the same time that the child is created. Both operations are performed by the same call.
// It is possible to create a child that is linked to another generic object. The two objects have the same properties.
//
// Parameters:
//
// ◾ prop          -   Information about the child.
// It is possible to create a child that is linked to another object.
//
// ◾ propForThis   -   Identifier of the parent's object.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) CreateChild(ctx context.Context, prop *GenericObjectProperties, propForThis *GenericObjectProperties) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateChild", result, prop, propForThis)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a generic object that is a child of another generic object.
// It is possible to update the properties of the child's parent at the same time that the child is created. Both operations are performed by the same call.
// It is possible to create a child that is linked to another generic object. The two objects have the same properties.
//
// Parameters:
//
// ◾ prop          -   Information about the child.
// It is possible to create a child that is linked to another object.
//
// ◾ propForThis   -   Identifier of the parent's object.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) CreateChildRaw(ctx context.Context, prop interface{}, propForThis interface{}) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateChild", result, ensureEncodable(prop), ensureEncodable(propForThis))
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Removes all children and all children to the children on an object.
//
// Parameters:
//
// ◾ propForThis   -   Identifier of the parent's object and property to update.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) DestroyAllChildren(ctx context.Context, propForThis *GenericObjectProperties) error {
	err := obj.rpc(ctx, "DestroyAllChildren", nil, propForThis)
	return err
}

// Removes all children and all children to the children on an object.
//
// Parameters:
//
// ◾ propForThis   -   Identifier of the parent's object and property to update.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) DestroyAllChildrenRaw(ctx context.Context, propForThis interface{}) error {
	err := obj.rpc(ctx, "DestroyAllChildren", nil, ensureEncodable(propForThis))
	return err
}

// Removes a child object.
// It is possible to update the properties of the child's parent at the same time that the child is removed. Both operations are performed by the same call.
// Removing a linked object, invalidate the linking object.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id            -   Identifier of the child to remove.
//
// ◾ propForThis   -   Identifier of the parent's object and property to update.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) DestroyChild(ctx context.Context, id string, propForThis *GenericObjectProperties) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyChild", result, id, propForThis)
	return result.Success, err
}

// Removes a child object.
// It is possible to update the properties of the child's parent at the same time that the child is removed. Both operations are performed by the same call.
// Removing a linked object, invalidate the linking object.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ id            -   Identifier of the child to remove.
//
// ◾ propForThis   -   Identifier of the parent's object and property to update.
// Should be set to update the properties of the parent's object at the same time the child is created.
//
func (obj *GenericObject) DestroyChildRaw(ctx context.Context, id string, propForThis interface{}) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DestroyChild", result, ensureEncodable(id), ensureEncodable(propForThis))
	return result.Success, err
}

// You can use the drillUp method with any object that contains a drill-down group as a dimension.
// This method allows you to move between different levels of information (from a detailed level to a less detailed level of information). You can go back to previous visualizations up to the highest level of the hierarchy.
// If you try to drill up more steps than there are available levels, the first level of the hierarchy is displayed.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ dimNo      -   Dimension number or index starting from 0.
// The default value is 0.
//
// ◾ nbrSteps   -   Number of steps you want to drill up.
// The default value is 0.
//
func (obj *GenericObject) DrillUp(ctx context.Context, path string, dimNo int, nbrSteps int) error {
	err := obj.rpc(ctx, "DrillUp", nil, path, dimNo, nbrSteps)
	return err
}

// Adds a snapshot to a generic object.
// Only one snapshot can be embedded in a generic object.
// If you embed a snapshot in an object that already contains a snapshot, the new snapshot overwrites the previous one.
//
// Parameters:
//
// ◾ id   -   Identifier of the bookmark.
//
func (obj *GenericObject) EmbedSnapshotObject(ctx context.Context, id string) error {
	err := obj.rpc(ctx, "EmbedSnapshotObject", nil, id)
	return err
}

// Ends the selection mode on a visualization. The selections are accepted or aborted when exiting the selection mode, depending on the qAccept parameter value.
//
// Parameters:
//
// ◾ accept   -   Set this parameter to true to accept the selections before exiting the selection mode.
//
func (obj *GenericObject) EndSelections(ctx context.Context, accept bool) error {
	err := obj.rpc(ctx, "EndSelections", nil, accept)
	return err
}

// Expands the left dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
// In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
//
// Parameters:
//
// ◾ path   -   Path to the definition of the object to be expanded.
// For example, /qHyperCubeDef .
//
// ◾ row    -   Row index in the data matrix to expand.
// Indexing starts from 0.
//
// ◾ col    -   Column index. The index is based on the left dimension indexes.
// Indexing starts from 0.
//
// ◾ all    -   If set to true, it expands all cells.
// Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
//
func (obj *GenericObject) ExpandLeft(ctx context.Context, path string, row int, col int, all bool) error {
	err := obj.rpc(ctx, "ExpandLeft", nil, path, row, col, all)
	return err
}

// Expands the top dimensions of a pivot table. This method applies only to pivot tables that are not always fully expanded.
// In the definition of the hypercube (in HyperCubeDef ), the parameter qAlwaysFullyExpanded must be set to false.
//
// Parameters:
//
// ◾ path   -   Path to the definition of the object to be expanded.
// For example, /qHyperCubeDef .
//
// ◾ row    -   Row index. The index is based on the top dimension indexes.
// Indexing starts from 0.
//
// ◾ col    -   Column index in the data matrix.
// Indexing starts from 0.
//
// ◾ all    -   If set to true, it expands all cells.
// Parameters qRow and qCol are not used if qAll is set to true, but they need to be set (for example to 0).
//
func (obj *GenericObject) ExpandTop(ctx context.Context, path string, row int, col int, all bool) error {
	err := obj.rpc(ctx, "ExpandTop", nil, path, row, col, all)
	return err
}

// Exports the data of any generic object to an Excel file or a open XML file. If the object contains excluded values, those excluded values are not exported.
// This API has limited functionality and will not support CSV export from all types of objects. Consider using Excel export instead. Treemap and bar chart are not supported.
//
// Default limitations in number of rows and columns:
//
// The default maximum number of rows and columns in the Excel export file is:
//
// • 1048566 rows per sheet. For pivot tables: 1048566 column dimensions. 10 rows can be added after the export.
//
// • 16384 columns per sheet. If the number of columns exceeds the limit, the exported file is truncated and a warning message is sent.
//
// Default limitations in number of cells:
//
// The default maximum number of cells in the export file is:
//
// • 1000000 to export to an Excel file
//
// • 5000000 to export to a CSV file
//
// The exported file is truncated if the number of cells exceeds the limit. A warning message with code 1000 is sent.
// There is an option to export only the possible values ( qExportState is P).
//
// Default limitation in number of columns:
//
// The default maximum number of columns in the export file is:
//
// • 1000 to export to a CSV file
//
// The exported file is truncated if the number of cells exceeds the limit. A warning message with code 1000 is sent.
// There is an option to export only the possible values ( qExportState is P).
//
// Default limitation in size:
//
// If the exported file is larger than the maximum value, then an out-of-memory error with code 13000 is returned.
//
// Exported files are temporary and are available only for a certain time span and only to the user who created them.
//
// Parameters:
//
// ◾ fileType      -   Type of the file to export.
//
// One of:
//
// • CSV_C or EXPORT_CSV_C
//
// • CSV_T or EXPORT_CSV_T
//
// • OOXML or EXPORT_OOXML
//
// ◾ path          -   Path to the definition of the object to be exported.
// For example, /qHyperCubeDef .
// This parameter is mandatory if the file type is CSVC_ or CSVT_ .
//
// ◾ fileName      -   Name of the exported file after download from browser.
// This parameter is optional and only used in Qlik Sense Desktop.
//
// ◾ exportState   -   Defines the values to be exported.
// The default value is A.
//
// One of:
//
// • P or EXPORT_POSSIBLE
//
// • A or EXPORT_ALL
//
func (obj *GenericObject) ExportData(ctx context.Context, fileType string, path string, fileName string, exportState string) (string, []int, error) {
	result := &struct {
		Url      string `json:"qUrl"`
		Warnings []int  `json:"qWarnings"`
	}{}
	err := obj.rpc(ctx, "ExportData", result, fileType, path, fileName, exportState)
	return result.Url, result.Warnings, err
}

// Returns the type of the object and the corresponding handle.
//
// Parameters:
//
// ◾ id   -   Identifier of the object.
//
func (obj *GenericObject) GetChild(ctx context.Context, id string) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetChild", result, id)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Returns the identifier and the type for each child in an app object. If the child contains extra properties in qInfos , these properties are returned.
//
// Full dynamic properties are optional and are returned if they exist in the definition of the object.
func (obj *GenericObject) GetChildInfos(ctx context.Context) ([]*NxInfo, error) {
	result := &struct {
		Infos []*NxInfo `json:"qInfos"`
	}{}
	err := obj.rpc(ctx, "GetChildInfos", result)
	return result.Infos, err
}

// Returns the identifier and the type for each child in an app object. If the child contains extra properties in qInfos , these properties are returned.
//
// Full dynamic properties are optional and are returned if they exist in the definition of the object.
func (obj *GenericObject) GetChildInfosRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Infos json.RawMessage `json:"qInfos"`
	}{}
	err := obj.rpc(ctx, "GetChildInfos", result)
	return result.Infos, err
}

// Returns the identifier, the type and the properties of the object.
// If the object contains some soft properties, the soft properties are returned.
// If the object is linked to another object, the properties of the linking object are returned.
// GetEffectiveProperties method
// Returns the identifier, the type and the properties of the object.
// If the object contains some soft properties, the soft properties are returned.
// If the object is linked to another object, the properties of the linking object are returned.
func (obj *GenericObject) GetEffectiveProperties(ctx context.Context) (*GenericObjectProperties, error) {
	result := &struct {
		Prop *GenericObjectProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetEffectiveProperties", result)
	return result.Prop, err
}

// Returns the identifier, the type and the properties of the object.
// If the object contains some soft properties, the soft properties are returned.
// If the object is linked to another object, the properties of the linking object are returned.
// GetEffectiveProperties method
// Returns the identifier, the type and the properties of the object.
// If the object contains some soft properties, the soft properties are returned.
// If the object is linked to another object, the properties of the linking object are returned.
func (obj *GenericObject) GetEffectivePropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetEffectiveProperties", result)
	return result.Prop, err
}

// Gets the properties of:
//
// • A generic object.
//
// • The children of the generic object.
//
// • The bookmarks/embedded snapshots of the generic object.
func (obj *GenericObject) GetFullPropertyTree(ctx context.Context) (*GenericObjectEntry, error) {
	result := &struct {
		PropEntry *GenericObjectEntry `json:"qPropEntry"`
	}{}
	err := obj.rpc(ctx, "GetFullPropertyTree", result)
	return result.PropEntry, err
}

// Gets the properties of:
//
// • A generic object.
//
// • The children of the generic object.
//
// • The bookmarks/embedded snapshots of the generic object.
func (obj *GenericObject) GetFullPropertyTreeRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		PropEntry json.RawMessage `json:"qPropEntry"`
	}{}
	err := obj.rpc(ctx, "GetFullPropertyTree", result)
	return result.PropEntry, err
}

// This method supports data binning.
// When a generic object with two or three measures and one dimension contains a lot of data, groups of points (for example, cells) can be rendered instead of points.
// A zone of interest can be refined (for zooming in) up to a maximum refinement level (set in the qQueryLevel parameter) or coarsened (for zoom out).
// The grid of cells is adaptive (not static), meaning that it adapts to different length scales.
// The GetHyperCubeBinnedData method gives information about the adaptive grid and the values of the generic object.
// The number of points in a cell and the coordinates (expressed in the measure range) of each cell are returned.
// Dimension values and measure values are rendered at point level (highest detailed level).
// The generic object should contain two or three measures and one dimension. When the refinement is high, the first two measures are represented on the x-axis and on the y-axis, while the third measure is visualized as color or point size.
//
// Adaptive Grid:
//
// More details about the properties of the adaptive grid are given in this paragraph.
// When the refinement is not the highest (cells are rendered), information about the adaptive grid is returned through several arrays.
// The first array contains the following properties:
//
//   +-------------+--------------------------------+----------------------------+
//   |    NAME     |          DESCRIPTION           |            TYPE            |
//   +-------------+--------------------------------+----------------------------+
//   | qNum        | Maximum number of points that  | String                     |
//   |             | a cell can contain.            |                            |
//   | qElemNumber | Is set to 0.                   | Boolean                    |
//   | qState      | The default value is L.        | One of:   * L for Locked   |
//   |             |                                |  * S for Selected  *       |
//   |             |                                | O for Optional  * D        |
//   |             |                                | for Deselected  * A        |
//   |             |                                | for Alternative  * X       |
//   |             |                                | for eXcluded  * XS for     |
//   |             |                                | eXcluded Selected  * XL    |
//   |             |                                | for eXcluded Locked        |
//   +-------------+--------------------------------+----------------------------+
//
// The next arrays give the coordinates of each cell in the page.
// Each array contains the following properties:
//
//   +-------------+--------------------------------+--------------------------------+
//   |    NAME     |          DESCRIPTION           |              TYPE              |
//   +-------------+--------------------------------+--------------------------------+
//   | qText       | Coordinates of a cell in       | String                         |
//   |             | the measure range.  “qText”:   |                                |
//   |             | “[[<left>, <top>, <right>,     |                                |
//   |             | <bottom>], [<left>, <top>,     |                                |
//   |             | <right>, <bottom>], ....       |                                |
//   |             | [<left>, <top>, <right>,       |                                |
//   |             | <bottom>]]  Where:  < left     |                                |
//   |             | >, < top >, < right > and <    |                                |
//   |             | bottom > are the coordinates   |                                |
//   |             | of the cell in the measure     |                                |
//   |             | range.                         |                                |
//   | qNum        | Number of points in the cell.  | Double precision floating      |
//   |             |                                | point                          |
//   | qElemNumber | Unique identifier for each     | Integer                        |
//   |             | cell, calculated by the engine |                                |
//   |             | during the construction of     |                                |
//   |             | the grid.  This element number |                                |
//   |             | is not stored in the database  |                                |
//   |             | and can have a positive or a   |                                |
//   |             | negative value.                |                                |
//   | qState      | The default value is L.        | One of:   * L for Locked       |
//   |             |                                |  * S for Selected  *           |
//   |             |                                | O for Optional  * D            |
//   |             |                                | for Deselected  * A            |
//   |             |                                | for Alternative  * X           |
//   |             |                                | for eXcluded  * XS for         |
//   |             |                                | eXcluded Selected  * XL        |
//   |             |                                | for eXcluded Locked            |
//   +-------------+--------------------------------+--------------------------------+
//
// Cells are represented as rectangles.
//
// Dimension values and measures values:
//
// More details about the properties, when dimension and measure values are returned, are given in this paragraph.
// When the refinement is high, points are rendered (not cells) and dimension and measure values for each cell are returned.
// The first array is empty because no information on the adaptive grid is needed.
// The next arrays bring information about the dimension and the measure values.
//
//   +-------------+--------------------------------+--------------------------------+
//   |    NAME     |          DESCRIPTION           |              TYPE              |
//   +-------------+--------------------------------+--------------------------------+
//   | qText       | Text value of the dimension or | String                         |
//   |             | the measure.                   |                                |
//   | qNum        | Numerical value of the         | Double precision floating      |
//   |             | dimension or the measure.  Is  | point                          |
//   |             | set to 0 if the value is only  |                                |
//   |             | text.                          |                                |
//   | qElemNumber | Unique identifier for each     | Integer                        |
//   |             | cell, calculated by the engine |                                |
//   |             | during the construction of     |                                |
//   |             | the grid.  This element number |                                |
//   |             | is not stored in the database  |                                |
//   |             | and can have a positive or a   |                                |
//   |             | negative value.                |                                |
//   | qState      | The default value is L.        | One of:   * L for Locked       |
//   |             |                                |  * S for Selected  *           |
//   |             |                                | O for Optional  * D            |
//   |             |                                | for Deselected  * A            |
//   |             |                                | for Alternative  * X           |
//   |             |                                | for eXcluded  * XS for         |
//   |             |                                | eXcluded Selected  * XL        |
//   |             |                                | for eXcluded Locked            |
//   +-------------+--------------------------------+--------------------------------+
//
// Parameters:
//
// ◾ path            -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ pages           -   Array of pages to retrieve.
// Since the generic object contains two measures and one dimension, qWidth should be set to 3.
// If the value of a measure is Null, the value cannot be rendered. Therefore, the number of elements rendered in a page can be less than the number defined in the property qHeight .
//
// ◾ viewport        -   Defines the canvas and the zoom level.
// This parameter is not yet used and is optional.
//
// ◾ dataRanges      -   Range of the data to render.
// This range applies to the measure values.
// The lowest and highest values of a measure can be retrieved by using the GetLayout method (in /qHyperCube/qMeasureInfo ).
//
// ◾ maxNbrCells     -   Maximum number of cells in the grid.
//
// ◾ queryLevel      -   Level of details. The higher the level, the more detailed information you get (zoom-in).
// When the number of points to render falls below a certain threshold, the values are no longer rendered as cells but as points.
// The query level should be no greater than 20.
//
// ◾ binningMethod   -   Selects the algorithm.
// The default value is 0.
// One of:
//
// • 0: Adaptive grid
//
// • 1: Hexagonal grid
//
// • 2: Uniform grid
//
func (obj *GenericObject) GetHyperCubeBinnedData(ctx context.Context, path string, pages []*NxPage, viewport *NxViewPort, dataRanges []*NxDataAreaPage, maxNbrCells int, queryLevel int, binningMethod int) ([]*NxDataPage, error) {
	result := &struct {
		DataPages []*NxDataPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeBinnedData", result, path, pages, viewport, dataRanges, maxNbrCells, queryLevel, binningMethod)
	return result.DataPages, err
}

// This method supports data binning.
// When a generic object with two or three measures and one dimension contains a lot of data, groups of points (for example, cells) can be rendered instead of points.
// A zone of interest can be refined (for zooming in) up to a maximum refinement level (set in the qQueryLevel parameter) or coarsened (for zoom out).
// The grid of cells is adaptive (not static), meaning that it adapts to different length scales.
// The GetHyperCubeBinnedData method gives information about the adaptive grid and the values of the generic object.
// The number of points in a cell and the coordinates (expressed in the measure range) of each cell are returned.
// Dimension values and measure values are rendered at point level (highest detailed level).
// The generic object should contain two or three measures and one dimension. When the refinement is high, the first two measures are represented on the x-axis and on the y-axis, while the third measure is visualized as color or point size.
//
// Adaptive Grid:
//
// More details about the properties of the adaptive grid are given in this paragraph.
// When the refinement is not the highest (cells are rendered), information about the adaptive grid is returned through several arrays.
// The first array contains the following properties:
//
//   +-------------+--------------------------------+----------------------------+
//   |    NAME     |          DESCRIPTION           |            TYPE            |
//   +-------------+--------------------------------+----------------------------+
//   | qNum        | Maximum number of points that  | String                     |
//   |             | a cell can contain.            |                            |
//   | qElemNumber | Is set to 0.                   | Boolean                    |
//   | qState      | The default value is L.        | One of:   * L for Locked   |
//   |             |                                |  * S for Selected  *       |
//   |             |                                | O for Optional  * D        |
//   |             |                                | for Deselected  * A        |
//   |             |                                | for Alternative  * X       |
//   |             |                                | for eXcluded  * XS for     |
//   |             |                                | eXcluded Selected  * XL    |
//   |             |                                | for eXcluded Locked        |
//   +-------------+--------------------------------+----------------------------+
//
// The next arrays give the coordinates of each cell in the page.
// Each array contains the following properties:
//
//   +-------------+--------------------------------+--------------------------------+
//   |    NAME     |          DESCRIPTION           |              TYPE              |
//   +-------------+--------------------------------+--------------------------------+
//   | qText       | Coordinates of a cell in       | String                         |
//   |             | the measure range.  “qText”:   |                                |
//   |             | “[[<left>, <top>, <right>,     |                                |
//   |             | <bottom>], [<left>, <top>,     |                                |
//   |             | <right>, <bottom>], ....       |                                |
//   |             | [<left>, <top>, <right>,       |                                |
//   |             | <bottom>]]  Where:  < left     |                                |
//   |             | >, < top >, < right > and <    |                                |
//   |             | bottom > are the coordinates   |                                |
//   |             | of the cell in the measure     |                                |
//   |             | range.                         |                                |
//   | qNum        | Number of points in the cell.  | Double precision floating      |
//   |             |                                | point                          |
//   | qElemNumber | Unique identifier for each     | Integer                        |
//   |             | cell, calculated by the engine |                                |
//   |             | during the construction of     |                                |
//   |             | the grid.  This element number |                                |
//   |             | is not stored in the database  |                                |
//   |             | and can have a positive or a   |                                |
//   |             | negative value.                |                                |
//   | qState      | The default value is L.        | One of:   * L for Locked       |
//   |             |                                |  * S for Selected  *           |
//   |             |                                | O for Optional  * D            |
//   |             |                                | for Deselected  * A            |
//   |             |                                | for Alternative  * X           |
//   |             |                                | for eXcluded  * XS for         |
//   |             |                                | eXcluded Selected  * XL        |
//   |             |                                | for eXcluded Locked            |
//   +-------------+--------------------------------+--------------------------------+
//
// Cells are represented as rectangles.
//
// Dimension values and measures values:
//
// More details about the properties, when dimension and measure values are returned, are given in this paragraph.
// When the refinement is high, points are rendered (not cells) and dimension and measure values for each cell are returned.
// The first array is empty because no information on the adaptive grid is needed.
// The next arrays bring information about the dimension and the measure values.
//
//   +-------------+--------------------------------+--------------------------------+
//   |    NAME     |          DESCRIPTION           |              TYPE              |
//   +-------------+--------------------------------+--------------------------------+
//   | qText       | Text value of the dimension or | String                         |
//   |             | the measure.                   |                                |
//   | qNum        | Numerical value of the         | Double precision floating      |
//   |             | dimension or the measure.  Is  | point                          |
//   |             | set to 0 if the value is only  |                                |
//   |             | text.                          |                                |
//   | qElemNumber | Unique identifier for each     | Integer                        |
//   |             | cell, calculated by the engine |                                |
//   |             | during the construction of     |                                |
//   |             | the grid.  This element number |                                |
//   |             | is not stored in the database  |                                |
//   |             | and can have a positive or a   |                                |
//   |             | negative value.                |                                |
//   | qState      | The default value is L.        | One of:   * L for Locked       |
//   |             |                                |  * S for Selected  *           |
//   |             |                                | O for Optional  * D            |
//   |             |                                | for Deselected  * A            |
//   |             |                                | for Alternative  * X           |
//   |             |                                | for eXcluded  * XS for         |
//   |             |                                | eXcluded Selected  * XL        |
//   |             |                                | for eXcluded Locked            |
//   +-------------+--------------------------------+--------------------------------+
//
// Parameters:
//
// ◾ path            -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ pages           -   Array of pages to retrieve.
// Since the generic object contains two measures and one dimension, qWidth should be set to 3.
// If the value of a measure is Null, the value cannot be rendered. Therefore, the number of elements rendered in a page can be less than the number defined in the property qHeight .
//
// ◾ viewport        -   Defines the canvas and the zoom level.
// This parameter is not yet used and is optional.
//
// ◾ dataRanges      -   Range of the data to render.
// This range applies to the measure values.
// The lowest and highest values of a measure can be retrieved by using the GetLayout method (in /qHyperCube/qMeasureInfo ).
//
// ◾ maxNbrCells     -   Maximum number of cells in the grid.
//
// ◾ queryLevel      -   Level of details. The higher the level, the more detailed information you get (zoom-in).
// When the number of points to render falls below a certain threshold, the values are no longer rendered as cells but as points.
// The query level should be no greater than 20.
//
// ◾ binningMethod   -   Selects the algorithm.
// The default value is 0.
// One of:
//
// • 0: Adaptive grid
//
// • 1: Hexagonal grid
//
// • 2: Uniform grid
//
func (obj *GenericObject) GetHyperCubeBinnedDataRaw(ctx context.Context, path string, pages interface{}, viewport interface{}, dataRanges interface{}, maxNbrCells int, queryLevel int, binningMethod int) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeBinnedData", result, ensureEncodable(path), ensureEncodable(pages), ensureEncodable(viewport), ensureEncodable(dataRanges), ensureEncodable(maxNbrCells), ensureEncodable(queryLevel), ensureEncodable(binningMethod))
	return result.DataPages, err
}

// Retrieves and packs compressed hypercube and axis data. It is possible to retrieve specific pages of data.
// Binning is done on the time stamp data as well as the date. This means that you can zoom in to a level of granularity as low as seconds.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ options       -   Defines the data to return.
//
// ◾ reverseSort   -   If set to true the returned data pages are reverse sorted.
// Optional.
//
func (obj *GenericObject) GetHyperCubeContinuousData(ctx context.Context, path string, options *NxContinuousDataOptions, reverseSort bool) ([]*NxDataPage, *NxAxisData, error) {
	result := &struct {
		DataPages []*NxDataPage `json:"qDataPages"`
		AxisData  *NxAxisData   `json:"qAxisData"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeContinuousData", result, path, options, reverseSort)
	return result.DataPages, result.AxisData, err
}

// Retrieves and packs compressed hypercube and axis data. It is possible to retrieve specific pages of data.
// Binning is done on the time stamp data as well as the date. This means that you can zoom in to a level of granularity as low as seconds.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ options       -   Defines the data to return.
//
// ◾ reverseSort   -   If set to true the returned data pages are reverse sorted.
// Optional.
//
func (obj *GenericObject) GetHyperCubeContinuousDataRaw(ctx context.Context, path string, options interface{}, reverseSort bool) (json.RawMessage, json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
		AxisData  json.RawMessage `json:"qAxisData"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeContinuousData", result, ensureEncodable(path), ensureEncodable(options), ensureEncodable(reverseSort))
	return result.DataPages, result.AxisData, err
}

// Retrieves the calculated data for a chart, a table, or a scatter plot. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_STRAIGHT.
//
// A data set is returned.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages   -   Array of pages to retrieve.
//
func (obj *GenericObject) GetHyperCubeData(ctx context.Context, path string, pages []*NxPage) ([]*NxDataPage, error) {
	result := &struct {
		DataPages []*NxDataPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeData", result, path, pages)
	return result.DataPages, err
}

// Retrieves the calculated data for a chart, a table, or a scatter plot. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_STRAIGHT.
//
// A data set is returned.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages   -   Array of pages to retrieve.
//
func (obj *GenericObject) GetHyperCubeDataRaw(ctx context.Context, path string, pages interface{}) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeData", result, ensureEncodable(path), ensureEncodable(pages))
	return result.DataPages, err
}

// Retrieves the values of a pivot table. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_PIVOT.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages   -   Array of pages to retrieve.
//
func (obj *GenericObject) GetHyperCubePivotData(ctx context.Context, path string, pages []*NxPage) ([]*NxPivotPage, error) {
	result := &struct {
		DataPages []*NxPivotPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubePivotData", result, path, pages)
	return result.DataPages, err
}

// Retrieves the values of a pivot table. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_PIVOT.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages   -   Array of pages to retrieve.
//
func (obj *GenericObject) GetHyperCubePivotDataRaw(ctx context.Context, path string, pages interface{}) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubePivotData", result, ensureEncodable(path), ensureEncodable(pages))
	return result.DataPages, err
}

// Reduces the data of a bar chart, a line chart or a scatter plot chart and retrieves them.
// The reduction is dependent on the zoom factor (parameter qZoomFactor ) and on the reduction mode.
// This method can be used to create mini charts.
//
// Bar chart or line chart data reduction:
//
// For the data reduction to happen, the following conditions must be fulfilled:
//
// • The values cannot fit in the defined page (parameter qPages ).
//
// • The zoom factor is not 0 (parameter qZoomFactor ).
//
// • The reduction mode must be set to D1.
//
// The reduction algorithm keeps the shape of the visualizations and works whatever the number of dimensions in the chart. The global profile of the chart is reduced, and not only a specific dimension. A visualization that has been reduced contains fewer values but its shape is the same. Data of all types can be reduced. Therefore it is hard to relate the values before and after a reduction especially when reducing string values.
//
// Example:
//
// If you have a chart with 1 million data, and you have set the zoom factor to 5, the GetHyperCubeReducedData method reduces the chart and retrieves 200 000 data.
//
// Scatter plot chart data reduction:
//
// The reduction mode must be set to C.
// This reduction mechanism follows the 2D K-Means algorithm. Data are reduced into a number of clusters. Each data is assigned to a specific centroid.
// The number of centroids can be defined in the parameter qZoomFactor.
//
// Scatter plot chart resolution reduction:
//
// The reduction mode must be set to S.
// The resolution is reduced according to the zoom factor (parameter qZoomFactor ).
//
// Example:
//
// If you have a scatter plot chart and the zoom factor is set to 2, the scatter plot chart resolution is reduced by 4.
//
// Parameters:
//
// ◾ path            -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages           -   Array of pages.
//
// ◾ zoomFactor      -   Defines the zoom factor.
// If set to -1, the engine decides of the zoom factor.
//
// • If the reduction mode is D1 or S , the zoom factor is 2ⁿ. If the zoom factor is 5, the data are reduced by a factor 32.
//
// • If the reduction mode is C , the zoom factor defines the number of centroids.
//
// ◾ reductionMode   -   Defines the reduction mode.
//
// One of:
//
// • N or DATA_REDUCTION_NONE
//
// • D1 or DATA_REDUCTION_ONEDIM
//
// • S or DATA_REDUCTION_SCATTERED
//
// • C or DATA_REDUCTION_CLUSTERED
//
// • ST or DATA_REDUCTION_STACKED
//
func (obj *GenericObject) GetHyperCubeReducedData(ctx context.Context, path string, pages []*NxPage, zoomFactor int, reductionMode string) ([]*NxDataPage, error) {
	result := &struct {
		DataPages []*NxDataPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeReducedData", result, path, pages, zoomFactor, reductionMode)
	return result.DataPages, err
}

// Reduces the data of a bar chart, a line chart or a scatter plot chart and retrieves them.
// The reduction is dependent on the zoom factor (parameter qZoomFactor ) and on the reduction mode.
// This method can be used to create mini charts.
//
// Bar chart or line chart data reduction:
//
// For the data reduction to happen, the following conditions must be fulfilled:
//
// • The values cannot fit in the defined page (parameter qPages ).
//
// • The zoom factor is not 0 (parameter qZoomFactor ).
//
// • The reduction mode must be set to D1.
//
// The reduction algorithm keeps the shape of the visualizations and works whatever the number of dimensions in the chart. The global profile of the chart is reduced, and not only a specific dimension. A visualization that has been reduced contains fewer values but its shape is the same. Data of all types can be reduced. Therefore it is hard to relate the values before and after a reduction especially when reducing string values.
//
// Example:
//
// If you have a chart with 1 million data, and you have set the zoom factor to 5, the GetHyperCubeReducedData method reduces the chart and retrieves 200 000 data.
//
// Scatter plot chart data reduction:
//
// The reduction mode must be set to C.
// This reduction mechanism follows the 2D K-Means algorithm. Data are reduced into a number of clusters. Each data is assigned to a specific centroid.
// The number of centroids can be defined in the parameter qZoomFactor.
//
// Scatter plot chart resolution reduction:
//
// The reduction mode must be set to S.
// The resolution is reduced according to the zoom factor (parameter qZoomFactor ).
//
// Example:
//
// If you have a scatter plot chart and the zoom factor is set to 2, the scatter plot chart resolution is reduced by 4.
//
// Parameters:
//
// ◾ path            -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages           -   Array of pages.
//
// ◾ zoomFactor      -   Defines the zoom factor.
// If set to -1, the engine decides of the zoom factor.
//
// • If the reduction mode is D1 or S , the zoom factor is 2ⁿ. If the zoom factor is 5, the data are reduced by a factor 32.
//
// • If the reduction mode is C , the zoom factor defines the number of centroids.
//
// ◾ reductionMode   -   Defines the reduction mode.
//
// One of:
//
// • N or DATA_REDUCTION_NONE
//
// • D1 or DATA_REDUCTION_ONEDIM
//
// • S or DATA_REDUCTION_SCATTERED
//
// • C or DATA_REDUCTION_CLUSTERED
//
// • ST or DATA_REDUCTION_STACKED
//
func (obj *GenericObject) GetHyperCubeReducedDataRaw(ctx context.Context, path string, pages interface{}, zoomFactor int, reductionMode string) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeReducedData", result, ensureEncodable(path), ensureEncodable(pages), ensureEncodable(zoomFactor), ensureEncodable(reductionMode))
	return result.DataPages, err
}

// Retrieves the values of a stacked pivot table. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_PIVOT_STACK.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages         -   Array of pages to retrieve.
//
// ◾ maxNbrCells   -   Maximum number of cells at outer level.
// The default value is 10 000.
//
func (obj *GenericObject) GetHyperCubeStackData(ctx context.Context, path string, pages []*NxPage, maxNbrCells int) ([]*NxStackPage, error) {
	result := &struct {
		DataPages []*NxStackPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeStackData", result, path, pages, maxNbrCells)
	return result.DataPages, err
}

// Retrieves the values of a stacked pivot table. It is possible to retrieve specific pages of data.
// This method works for a hypercube in DATA_MODE_PIVOT_STACK.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ pages         -   Array of pages to retrieve.
//
// ◾ maxNbrCells   -   Maximum number of cells at outer level.
// The default value is 10 000.
//
func (obj *GenericObject) GetHyperCubeStackDataRaw(ctx context.Context, path string, pages interface{}, maxNbrCells int) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeStackData", result, ensureEncodable(path), ensureEncodable(pages), ensureEncodable(maxNbrCells))
	return result.DataPages, err
}

// Retrieves data for nodes in a tree structure. It is possible to retrieve specific pages of data.
// This method works for a treedata object or a hypercube in DATA_MODE_TREE.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object to be selected.
//
// ◾ nodeOptions   -   Specifies all the paging filters needed to define the tree to be fetched. If left out the complete tree is returned.
//
func (obj *GenericObject) GetHyperCubeTreeData(ctx context.Context, path string, nodeOptions *NxTreeDataOption) ([]*NxTreeNode, error) {
	result := &struct {
		Nodes []*NxTreeNode `json:"qNodes"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeTreeData", result, path, nodeOptions)
	return result.Nodes, err
}

// Retrieves data for nodes in a tree structure. It is possible to retrieve specific pages of data.
// This method works for a treedata object or a hypercube in DATA_MODE_TREE.
//
// Parameters:
//
// ◾ path          -   Path to the definition of the object to be selected.
//
// ◾ nodeOptions   -   Specifies all the paging filters needed to define the tree to be fetched. If left out the complete tree is returned.
//
func (obj *GenericObject) GetHyperCubeTreeDataRaw(ctx context.Context, path string, nodeOptions interface{}) (json.RawMessage, error) {
	result := &struct {
		Nodes json.RawMessage `json:"qNodes"`
	}{}
	err := obj.rpc(ctx, "GetHyperCubeTreeData", result, ensureEncodable(path), ensureEncodable(nodeOptions))
	return result.Nodes, err
}

// Returns the type and identifier of the object.
func (obj *GenericObject) GetInfo(ctx context.Context) (*NxInfo, error) {
	result := &struct {
		Info *NxInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Returns the type and identifier of the object.
func (obj *GenericObject) GetInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated. A GetLayout call on a generic object, returns up to one level down in the hierarchy.
//
// Example::
//
// _A_ is a generic object and is the parent of the objects B and C. B is the parent of the objects D and E.
//
// ![](images/dr_gen_QVCPMethodGetLayoutHierarchy.png)
//
// A GetLayout call on A returns information on the objects A, B and C.
// A GetLayout call on B returns information on the objects B, D and E.
// A  GetLayout call on C returns information on the object C.
//
// In addition to the parameters displayed above, the GetLayout method can return other properties according to what is defined in the generic object.
// For example, if qHyperCubeDef is defined in the generic object, the GetLayout method returns the properties described in HyperCube.
func (obj *GenericObject) GetLayout(ctx context.Context) (*GenericObjectLayout, error) {
	result := &struct {
		Layout *GenericObjectLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated. A GetLayout call on a generic object, returns up to one level down in the hierarchy.
//
// Example::
//
// _A_ is a generic object and is the parent of the objects B and C. B is the parent of the objects D and E.
//
// ![](images/dr_gen_QVCPMethodGetLayoutHierarchy.png)
//
// A GetLayout call on A returns information on the objects A, B and C.
// A GetLayout call on B returns information on the objects B, D and E.
// A  GetLayout call on C returns information on the object C.
//
// In addition to the parameters displayed above, the GetLayout method can return other properties according to what is defined in the generic object.
// For example, if qHyperCubeDef is defined in the generic object, the GetLayout method returns the properties described in HyperCube.
func (obj *GenericObject) GetLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericObject) GetLinkedObjects(ctx context.Context) ([]*NxLinkedObjectInfo, error) {
	result := &struct {
		Items []*NxLinkedObjectInfo `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Lists the linked objects to a generic object, a dimension or a measure.
func (obj *GenericObject) GetLinkedObjectsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Items json.RawMessage `json:"qItems"`
	}{}
	err := obj.rpc(ctx, "GetLinkedObjects", result)
	return result.Items, err
}

// Retrieves the values of a list object.
// A data set is returned.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ pages   -   Array of pages you are interested in.
//
func (obj *GenericObject) GetListObjectData(ctx context.Context, path string, pages []*NxPage) ([]*NxDataPage, error) {
	result := &struct {
		DataPages []*NxDataPage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetListObjectData", result, path, pages)
	return result.DataPages, err
}

// Retrieves the values of a list object.
// A data set is returned.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ pages   -   Array of pages you are interested in.
//
func (obj *GenericObject) GetListObjectDataRaw(ctx context.Context, path string, pages interface{}) (json.RawMessage, error) {
	result := &struct {
		DataPages json.RawMessage `json:"qDataPages"`
	}{}
	err := obj.rpc(ctx, "GetListObjectData", result, ensureEncodable(path), ensureEncodable(pages))
	return result.DataPages, err
}

// Returns the type of the object and the corresponding handle to the parent object in the hiearchy.
func (obj *GenericObject) GetParent(ctx context.Context) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetParent", result)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Returns the identifier, the type and the properties of the object.
// Because it is not mandatory to set all properties when you define an object, the GetProperties method may show properties that were not set. In that case, default values are given.
// If the object contains some soft properties, the soft properties are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
// If the object is linked to another object, the properties of the linking object are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
// The properties depends on the generic object type, see [properties](genericobject-layout.html).
//
// If the member delta is set to true in the request object, only the delta is retrieved.
func (obj *GenericObject) GetProperties(ctx context.Context) (*GenericObjectProperties, error) {
	result := &struct {
		Prop *GenericObjectProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Returns the identifier, the type and the properties of the object.
// Because it is not mandatory to set all properties when you define an object, the GetProperties method may show properties that were not set. In that case, default values are given.
// If the object contains some soft properties, the soft properties are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
// If the object is linked to another object, the properties of the linking object are not returned by the GetProperties method. Use the GetEffectiveProperties method instead.
// The properties depends on the generic object type, see [properties](genericobject-layout.html).
//
// If the member delta is set to true in the request object, only the delta is retrieved.
func (obj *GenericObject) GetPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Returns the type of the object and the corresponding handle.
func (obj *GenericObject) GetSnapshotObject(ctx context.Context) (*GenericObject, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetSnapshotObject", result)
	if err != nil {
		return nil, err
	}
	return &GenericObject{obj.session.getRemoteObject(result.Return)}, err
}

// Locks the selected values of a generic object.
//
// Parameters:
//
// ◾ path         -   Path to the definition of the object.
// For example, /qListObjectDef .
//
// ◾ colIndices   -   Dimension numbers or dimension indexes where the lock should apply.
// Dimension numbers/indexes start from 0.
// If this parameter is not set, the selected values in all dimensions are locked.
//
func (obj *GenericObject) Lock(ctx context.Context, path string, colIndices []int) error {
	err := obj.rpc(ctx, "Lock", nil, path, colIndices)
	return err
}

// Makes multiple range selections in measures.
// This method applies to hypercubes. For example, bar charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ ranges                    -   Ranges of selections.
//
// ◾ orMode                    -   Applies to hypercubes with multiple measures.
// If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
// If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
// The default value is false.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) MultiRangeSelectHyperCubeValues(ctx context.Context, path string, ranges []*NxMultiRangeSelectInfo, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "MultiRangeSelectHyperCubeValues", result, path, ranges, orMode, deselectOnlyOneSelected)
	return result.Success, err
}

// Makes multiple range selections in measures.
// This method applies to hypercubes. For example, bar charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ ranges                    -   Ranges of selections.
//
// ◾ orMode                    -   Applies to hypercubes with multiple measures.
// If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
// If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
// The default value is false.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) MultiRangeSelectHyperCubeValuesRaw(ctx context.Context, path string, ranges interface{}, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "MultiRangeSelectHyperCubeValues", result, ensureEncodable(path), ensureEncodable(ranges), ensureEncodable(orMode), ensureEncodable(deselectOnlyOneSelected))
	return result.Success, err
}

func (obj *GenericObject) MultiRangeSelectTreeDataValues(ctx context.Context, path string, ranges []*NxTreeMultiRangeSelectInfo, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "MultiRangeSelectTreeDataValues", result, path, ranges, orMode, deselectOnlyOneSelected)
	return result.Success, err
}

func (obj *GenericObject) MultiRangeSelectTreeDataValuesRaw(ctx context.Context, path string, ranges interface{}, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "MultiRangeSelectTreeDataValues", result, ensureEncodable(path), ensureEncodable(ranges), ensureEncodable(orMode), ensureEncodable(deselectOnlyOneSelected))
	return result.Success, err
}

// Publishes a generic object.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericObject) Publish(ctx context.Context) error {
	err := obj.rpc(ctx, "Publish", nil)
	return err
}

// Makes range selections in measures.
// This method applies to hypercubes. For example, bar charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ ranges                    -   Ranges of selections.
//
// ◾ columnsToSelect           -   Indicates which dimensions to select.
// The dimensions numbering starts at 0 (first dimension is 0).
// If the array is empty, all dimensions are selected.
//
// ◾ orMode                    -   Applies to hypercubes with multiple measures.
// If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
// If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
// The default value is false.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) RangeSelectHyperCubeValues(ctx context.Context, path string, ranges []*NxRangeSelectInfo, columnsToSelect []int, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "RangeSelectHyperCubeValues", result, path, ranges, columnsToSelect, orMode, deselectOnlyOneSelected)
	return result.Success, err
}

// Makes range selections in measures.
// This method applies to hypercubes. For example, bar charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ ranges                    -   Ranges of selections.
//
// ◾ columnsToSelect           -   Indicates which dimensions to select.
// The dimensions numbering starts at 0 (first dimension is 0).
// If the array is empty, all dimensions are selected.
//
// ◾ orMode                    -   Applies to hypercubes with multiple measures.
// If set to true, it means that at least one of the measures must be in the range of selections for the group of measures to be selected.
// If set to false, it means that all measures must be in the range of selections for the group of measures to be selected.
// The default value is false.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) RangeSelectHyperCubeValuesRaw(ctx context.Context, path string, ranges interface{}, columnsToSelect []int, orMode bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "RangeSelectHyperCubeValues", result, ensureEncodable(path), ensureEncodable(ranges), ensureEncodable(columnsToSelect), ensureEncodable(orMode), ensureEncodable(deselectOnlyOneSelected))
	return result.Success, err
}

// Resets all selections made in selection mode.
func (obj *GenericObject) ResetMadeSelections(ctx context.Context) error {
	err := obj.rpc(ctx, "ResetMadeSelections", nil)
	return err
}

// Searches for a string in a list object.
// This method applies to list objects (objects with one dimension).
// The search results can be displayed using the GetLayout Method.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ path    -   Path to the definition of the list object.
// For example, /qListObjectDef .
//
// ◾ match   -   Search string.
// Wild card characters are allowed. The search is not case sensitive.
// Examples:
//
// • P*U*: retrieves only values that start with P and contain U
//
// • P U S: retrieves values that start with P, U or S
//
func (obj *GenericObject) SearchListObjectFor(ctx context.Context, path string, match string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SearchListObjectFor", result, path, match)
	return result.Success, err
}

// Makes selections in multiple dimensions and measures.
// This method applies to hypercubes, such as bar charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ rowIndices                -   Array of row indexes to select, starting from 0.
// If the array is empty [ ] , all rows are selected.
//
// ◾ colIndices                -   Indexes of the columns to select, starting from 0.
// A column corresponds to a dimension in the order they are added to the hypercube.
// If a column is hidden it is ignored, qColIndex n refers to the n:th visible column (starting from zero).
// Example:
// If the hypercube has two dimensions:
//
// • [0] selects the first column (i.e the first dimension).
//
// • [1] selects the second column (i.e the second dimension).
//
// If the array is empty [ ] , all columns are selected.
//
// ◾ softLock                  -   Set to true to ignore locks; in that case, locked fields can be selected.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) SelectHyperCubeCells(ctx context.Context, path string, rowIndices []int, colIndices []int, softLock bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectHyperCubeCells", result, path, rowIndices, colIndices, softLock, deselectOnlyOneSelected)
	return result.Success, err
}

// The following is returned in the output:
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ ranges     -   Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
// If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectHyperCubeContinuousRange(ctx context.Context, path string, ranges []*NxContinuousRangeSelectInfo, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectHyperCubeContinuousRange", result, path, ranges, softLock)
	return result.Success, err
}

// The following is returned in the output:
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ ranges     -   Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
// If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectHyperCubeContinuousRangeRaw(ctx context.Context, path string, ranges interface{}, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectHyperCubeContinuousRange", result, ensureEncodable(path), ensureEncodable(ranges), ensureEncodable(softLock))
	return result.Success, err
}

// Selects some values in one dimension.
// The values are identified by their element numbers.
// This method applies to charts, tables and scatter plots.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path         -   Path to the definition of the object to be selected.
// For example, /qHyperCubeDef .
//
// ◾ dimNo        -   Dimension number or index to select.
// Dimension numbers/index start from 0.
//
// ◾ values       -   Element numbers of the field to select.
// You can select multiple elements; the separator is the comma.
//
// ◾ toggleMode   -   Set to true to toggle.
//
func (obj *GenericObject) SelectHyperCubeValues(ctx context.Context, path string, dimNo int, values []int, toggleMode bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectHyperCubeValues", result, path, dimNo, values, toggleMode)
	return result.Success, err
}

// Selects all values of a field.
// This method applies to list objects (objects with one dimension).
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectAll(ctx context.Context, path string, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectAll", result, path, softLock)
	return result.Success, err
}

// Selects all alternative values in a specific field.
// This method applies to list objects (objects with one dimension).
// If a field contains at least one selected value, the values that are neither selected nor excluded are alternatives values.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectAlternative(ctx context.Context, path string, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectAlternative", result, path, softLock)
	return result.Success, err
}

// The following is returned in the output:
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ ranges     -   Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
// If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectContinuousRange(ctx context.Context, path string, ranges []*Range, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectContinuousRange", result, path, ranges, softLock)
	return result.Success, err
}

// The following is returned in the output:
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ ranges     -   Selects ranges in a hypercube in (Ranges[N].Min,Ranges[N].Max) intervals.
// If either Ranges[N].MinInclEq or Ranges[N].MaxInclEq, or both flags are set to true then Min and Max values will be selected.
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectContinuousRangeRaw(ctx context.Context, path string, ranges interface{}, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectContinuousRange", result, ensureEncodable(path), ensureEncodable(ranges), ensureEncodable(softLock))
	return result.Success, err
}

// Inverts the current selections in a specific field.
// This method applies to list objects (objects with one dimension).
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectExcluded(ctx context.Context, path string, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectExcluded", result, path, softLock)
	return result.Success, err
}

// Selects all possible values of a list object.
// This method applies to list objects (objects with one dimension).
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path       -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ softLock   -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectPossible(ctx context.Context, path string, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectPossible", result, path, softLock)
	return result.Success, err
}

// Makes single selections in dimensions.
// This method applies to list objects only.
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path         -   Path to the definition of the object to be selected.
// For example, /qListObjectDef .
//
// ◾ values       -   Element numbers to select.
// You can select multiple values; the separator is the comma.
//
// ◾ toggleMode   -   Set to true to toggle.
//
// ◾ softLock     -   Set to true to ignore locks; in that case, locked fields can be selected.
// The default value is false.
//
func (obj *GenericObject) SelectListObjectValues(ctx context.Context, path string, values []int, toggleMode bool, softLock bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectListObjectValues", result, path, values, toggleMode, softLock)
	return result.Success, err
}

// This method only applies to hypercubes that are not represented as straight tables. The parameter qMode in HyperCubeDef must be set either to P  or K .
//
// Pivot table:
//
// Makes selections in the top or left dimension cells of a pivot table or in the data matrix. Only expanded dimensions can be selected.
//
// Stacked table:
//
// Makes selections in the left dimension cells of a stacked table or in the data matrix.
// There is no top dimensions in a stacked table. A stacked table can only contain one measure.
//
// Example of a pivot table:
//
// ![](images/ui_gen_ExampleQVCPPivotTableDescription.png)
//
// In the representation above:
//
//   +-------------------+--------------------------------+
//   | Sum(OrderTotal)   | Are pseudo dimensions.         |
//   | Count(OrderTotal) |                                |
//   | CategoryName      | Is a left dimension.           |
//   |                   | Beverages , Condiments ... are |
//   |                   | left dimension values.         |
//   | ProductName       | Is a top dimension.  Chef      |
//   |                   | Anton's Cajun Seasoning is a   |
//   |                   | top dimension value.           |
//   | Numeric values    | Are calculated values in the   |
//   |                   | data matrix.  626291,832 is a  |
//   |                   | calculated value.              |
//   +-------------------+--------------------------------+
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ selections                -   Information about the selections to perform.
//
// ◾ softLock                  -   Set to true to ignore locks; in that case, locked fields can be selected.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) SelectPivotCells(ctx context.Context, path string, selections []*NxSelectionCell, softLock bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectPivotCells", result, path, selections, softLock, deselectOnlyOneSelected)
	return result.Success, err
}

// This method only applies to hypercubes that are not represented as straight tables. The parameter qMode in HyperCubeDef must be set either to P  or K .
//
// Pivot table:
//
// Makes selections in the top or left dimension cells of a pivot table or in the data matrix. Only expanded dimensions can be selected.
//
// Stacked table:
//
// Makes selections in the left dimension cells of a stacked table or in the data matrix.
// There is no top dimensions in a stacked table. A stacked table can only contain one measure.
//
// Example of a pivot table:
//
// ![](images/ui_gen_ExampleQVCPPivotTableDescription.png)
//
// In the representation above:
//
//   +-------------------+--------------------------------+
//   | Sum(OrderTotal)   | Are pseudo dimensions.         |
//   | Count(OrderTotal) |                                |
//   | CategoryName      | Is a left dimension.           |
//   |                   | Beverages , Condiments ... are |
//   |                   | left dimension values.         |
//   | ProductName       | Is a top dimension.  Chef      |
//   |                   | Anton's Cajun Seasoning is a   |
//   |                   | top dimension value.           |
//   | Numeric values    | Are calculated values in the   |
//   |                   | data matrix.  626291,832 is a  |
//   |                   | calculated value.              |
//   +-------------------+--------------------------------+
//
// The member Change returns the handles of the objects that are updated following the selections.
// _qSuccess_ is set to true if the selections are successful and is set to false in the following cases:
//
// • The object contains some invalid fields (fields that are not in the data model).
//
// • The selection applies to a locked field.
//
// • A range selection is performed and the parameter OneAndOnlyOne is set to true in the definition of the object.
//
// Parameters:
//
// ◾ path                      -   Path to the definition of the object.
// For example, /qHyperCubeDef .
//
// ◾ selections                -   Information about the selections to perform.
//
// ◾ softLock                  -   Set to true to ignore locks; in that case, locked fields can be selected.
//
// ◾ deselectOnlyOneSelected   -   Set this parameter to true to unselect the last single selected value. There must be only one selected value in the field.
// The default value is false.
//
func (obj *GenericObject) SelectPivotCellsRaw(ctx context.Context, path string, selections interface{}, softLock bool, deselectOnlyOneSelected bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "SelectPivotCells", result, ensureEncodable(path), ensureEncodable(selections), ensureEncodable(softLock), ensureEncodable(deselectOnlyOneSelected))
	return result.Success, err
}

// Sets the order of the children in a generic object.
// To change the order of the children in a generic object, the identifiers of all the children must be included in the list of the identifiers (in qIds ).
//
// Parameters:
//
// ◾ ids   -   List of the children identifiers.
//
func (obj *GenericObject) SetChildArrayOrder(ctx context.Context, ids []string) error {
	err := obj.rpc(ctx, "SetChildArrayOrder", nil, ids)
	return err
}

// Sets the properties of:
//
// • A generic object.
//
// • The children of the generic object.
//
// • The bookmarks/embedded snapshots of the generic object.
//
// If the SetFullPropertyTree method is asked to set some properties to a child that does not exist, it creates the child.
// The type of an object cannot be updated.
//
// Parameters:
//
// ◾ propEntry   -   Information about the generic object entry.
//
func (obj *GenericObject) SetFullPropertyTree(ctx context.Context, propEntry *GenericObjectEntry) error {
	err := obj.rpc(ctx, "SetFullPropertyTree", nil, propEntry)
	return err
}

// Sets the properties of:
//
// • A generic object.
//
// • The children of the generic object.
//
// • The bookmarks/embedded snapshots of the generic object.
//
// If the SetFullPropertyTree method is asked to set some properties to a child that does not exist, it creates the child.
// The type of an object cannot be updated.
//
// Parameters:
//
// ◾ propEntry   -   Information about the generic object entry.
//
func (obj *GenericObject) SetFullPropertyTreeRaw(ctx context.Context, propEntry interface{}) error {
	err := obj.rpc(ctx, "SetFullPropertyTree", nil, ensureEncodable(propEntry))
	return err
}

// Sets some properties for a generic object.
// The properties depends on the generic object type, see [properties](genericobject-property.html).
//
// Parameters:
//
// ◾ prop   -   Information about the generic object.
//
func (obj *GenericObject) SetProperties(ctx context.Context, prop *GenericObjectProperties) error {
	err := obj.rpc(ctx, "SetProperties", nil, prop)
	return err
}

// Sets some properties for a generic object.
// The properties depends on the generic object type, see [properties](genericobject-property.html).
//
// Parameters:
//
// ◾ prop   -   Information about the generic object.
//
func (obj *GenericObject) SetPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetProperties", nil, ensureEncodable(prop))
	return err
}

// Removes the generic object from the list of approved objects
// This operation is possible only in Qlik Sense Enterprise.
func (obj *GenericObject) UnApprove(ctx context.Context) error {
	err := obj.rpc(ctx, "UnApprove", nil)
	return err
}

// Unpublishes a generic object.
// This operation is not applicable for Qlik Sense Desktop.
func (obj *GenericObject) UnPublish(ctx context.Context) error {
	err := obj.rpc(ctx, "UnPublish", nil)
	return err
}

// Unlocks the selected values of a generic object if the target (or handle ) is a generic object
//
// Parameters:
//
// ◾ path         -   Path to the definition of the object.
// For example, /qListObjectDef .
//
// ◾ colIndices   -   Dimension numbers/indexes where the unlock should apply.
// Dimension numbers/indexes start from 0.
// If this parameter is not set, the locked values in all dimensions are unlocked.
//
func (obj *GenericObject) Unlock(ctx context.Context, path string, colIndices []int) error {
	err := obj.rpc(ctx, "Unlock", nil, path, colIndices)
	return err
}

// This class describes all the methods that apply at generic variable level.
// The handle member in the JSON request for all methods listed in this section is the handle of the generic variable.
type GenericVariable struct {
	*RemoteObject
}

// Applies a patch to the properties of a variable. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericVariable) ApplyPatches(ctx context.Context, patches []*NxPatch) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, patches)
	return err
}

// Applies a patch to the properties of a variable. Allows an update to some of the properties.
// Applying a patch takes less time than resetting all the properties.
//
// Parameters:
//
// ◾ patches   -   Array of patches.
//
func (obj *GenericVariable) ApplyPatchesRaw(ctx context.Context, patches interface{}) error {
	err := obj.rpc(ctx, "ApplyPatches", nil, ensureEncodable(patches))
	return err
}

// Returns the type and identifier of the object.
func (obj *GenericVariable) GetInfo(ctx context.Context) (*NxInfo, error) {
	result := &struct {
		Info *NxInfo `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Returns the type and identifier of the object.
func (obj *GenericVariable) GetInfoRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Info json.RawMessage `json:"qInfo"`
	}{}
	err := obj.rpc(ctx, "GetInfo", result)
	return result.Info, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated.
func (obj *GenericVariable) GetLayout(ctx context.Context) (*GenericVariableLayout, error) {
	result := &struct {
		Layout *GenericVariableLayout `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Evaluates an object and displays its properties including the dynamic properties.
// If the member delta is set to true in the request object, only the delta is evaluated.
func (obj *GenericVariable) GetLayoutRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Layout json.RawMessage `json:"qLayout"`
	}{}
	err := obj.rpc(ctx, "GetLayout", result)
	return result.Layout, err
}

// Shows the properties of an object.
// If the member delta is set to true in the request, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericVariable) GetProperties(ctx context.Context) (*GenericVariableProperties, error) {
	result := &struct {
		Prop *GenericVariableProperties `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Shows the properties of an object.
// If the member delta is set to true in the request, only the delta is retrieved.
//
// The following is always returned in the output:
func (obj *GenericVariable) GetPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Prop json.RawMessage `json:"qProp"`
	}{}
	err := obj.rpc(ctx, "GetProperties", result)
	return result.Prop, err
}

// Sets the value of a dual variable.
// These changes are not persistent. They only last the duration of the engine session.
//
// Parameters:
//
// ◾ text   -   String representation of a dual value. Set this parameter to "", if the string representation is to be Null.
//
// ◾ num    -   Numeric representation of a dual value.
//
func (obj *GenericVariable) SetDualValue(ctx context.Context, text string, num Float64) error {
	err := obj.rpc(ctx, "SetDualValue", nil, text, num)
	return err
}

// Sets a numerical value to a variable.
// These changes are not persistent. They only last the duration of the engine session.
//
// Parameters:
//
// ◾ val   -   Value of the variable.
//
func (obj *GenericVariable) SetNumValue(ctx context.Context, val Float64) error {
	err := obj.rpc(ctx, "SetNumValue", nil, val)
	return err
}

// Sets some properties for a variable.
// The identifier of a variable cannot be modified.
// You cannot update the properties of a script-defined variable using the SetProperties method.
//
// Parameters:
//
// ◾ prop   -   Information about the variable.
//
func (obj *GenericVariable) SetProperties(ctx context.Context, prop *GenericVariableProperties) error {
	err := obj.rpc(ctx, "SetProperties", nil, prop)
	return err
}

// Sets some properties for a variable.
// The identifier of a variable cannot be modified.
// You cannot update the properties of a script-defined variable using the SetProperties method.
//
// Parameters:
//
// ◾ prop   -   Information about the variable.
//
func (obj *GenericVariable) SetPropertiesRaw(ctx context.Context, prop interface{}) error {
	err := obj.rpc(ctx, "SetProperties", nil, ensureEncodable(prop))
	return err
}

// Sets a string value to a variable.
// These changes are not persistent. They only last the duration of the engine session.
//
// Parameters:
//
// ◾ val   -   Value of the variable. The string can contain an expression.
//
func (obj *GenericVariable) SetStringValue(ctx context.Context, val string) error {
	err := obj.rpc(ctx, "SetStringValue", nil, val)
	return err
}

type Global struct {
	*RemoteObject
}

// Sets an abort flag on all pending and ongoing requests in the current engine session.
//
// • If an abort flag is set on a pending request, the request is aborted.
//
// • If an abort flag is set on an ongoing request, the engine checks to see if it is possible to abort the request.
func (obj *Global) AbortAll(ctx context.Context) error {
	err := obj.rpc(ctx, "AbortAll", nil)
	return err
}

// Sets an abort flag on a specific request in the current engine session.
//
// • If an abort flag is set on a pending request, the request is aborted.
//
// • If an abort flag is set on an ongoing request, the engine checks to see if it is possible to abort the request.
//
// Parameters:
//
// ◾ requestId   -   Identifier of request to abort.
//
func (obj *Global) AbortRequest(ctx context.Context, requestId int) error {
	err := obj.rpc(ctx, "AbortRequest", nil, requestId)
	return err
}

// Indicates whether or not a user is able to create an app.
func (obj *Global) AllowCreateApp(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "AllowCreateApp", result)
	return result.Return, err
}

// Cancels an ongoing reload. The reload of the app is stopped. The indexation can be canceled and true is still the return value of the reload task.
func (obj *Global) CancelReload(ctx context.Context) error {
	err := obj.rpc(ctx, "CancelReload", nil)
	return err
}

// Cancels an ongoing request. The request is stopped.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the request to stop.
//
func (obj *Global) CancelRequest(ctx context.Context, requestId int) error {
	err := obj.rpc(ctx, "CancelRequest", nil, requestId)
	return err
}

// Configures the engine's behavior during a reload.
// The ConfigureReload method should be run before the DoReload method.
//
// Parameters:
//
// ◾ cancelOnScriptError   -   If set to true, the script execution is halted on error.
// Otherwise, the engine continues the script execution.
// This parameter is relevant only if the variable ErrorMode is set to 1.
//
// ◾ useErrorData          -   If set to true, any script execution error is returned in qErrorData by the GetProgress method.
//
// ◾ interactOnError       -   If set to true, the script execution is halted on error and the engine is waiting for an interaction to be performed. If the result from the interaction is 1 (_qDef.qResult_ is 1), the engine continues the script execution otherwise the execution is halted.
// This parameter is relevant only if the variable ErrorMode is set to 1 and the script is run in debug mode (_qDebug_ is set to true when calling the DoReload method).
//
func (obj *Global) ConfigureReload(ctx context.Context, cancelOnScriptError bool, useErrorData bool, interactOnError bool) error {
	err := obj.rpc(ctx, "ConfigureReload", nil, cancelOnScriptError, useErrorData, interactOnError)
	return err
}

// Copies an app that is in the Qlik Sense repository.
// The engine copies the app into an app entity that was previously created by the repository. See the [Qlik Sense Repository Service API](
//
// csh-RepositoryServiceAPI-Introduction) for more information.:
//
// This operation is possible only in Qlik Sense Enterprise.
//
// Parameters:
//
// ◾ targetAppId   -   Identifier (GUID) of the app entity in the Qlik Sense repository.
// The app entity must have been previously created by the Qlik Sense Repository Service (QRS) API.
//
// ◾ srcAppId      -   Identifier (GUID) of the source app in the Qlik Sense repository.
//
// ◾ ids           -   Array of QRS identifiers.
// The list of all objects in the app to be copied must be given. This list must contain the GUIDs of all these objects.
// If the list of the QRS identifiers is empty, the CopyApp method copies all objects to the target app.
// Script-defined variables are automatically copied when copying an app. To be able to copy variables not created via script, the GUID of each variable must be provided in the list of QRS identifiers.
// To get the QRS identifiers of the objects in an app, you can use the QRS API. The GET method (from the QRS API) returns the identifiers of the objects in the app.
// The following example returns the QRS identifiers of all the objects in a specified app:
// GET /qrs/app/9c3f8634-6191-4a34-a114-a39102058d13
// Where
// _9c3f8634-6191-4a34-a114-a39102058d13_ is the identifier of the app.
//
func (obj *Global) CopyApp(ctx context.Context, targetAppId string, srcAppId string, ids []string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "CopyApp", result, targetAppId, srcAppId, ids)
	return result.Success, err
}

// Creates an app.
//
// The operation is successful if qSuccess is set to true.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +----------------------------------------+---------------------------------+
//   |           AUDIT ACTIVITY LOG           |       SYSTEM SERVICE LOG        |
//   +----------------------------------------+---------------------------------+
//   | <MachineName>_AuditActivity_Engine.txt | <MachineName>_ServiceEngine.txt |
//   | in Qlik Sense Enterprise               | in Qlik Sense Enterprise        |
//   | <MachineName>_AuditActivity_Engine.log | <MachineName>_ServiceEngine.log |
//   | in Qlik Sense Desktop                  | in Qlik Sense Desktop           |
//   +----------------------------------------+---------------------------------+
//
// Where to find the log files:
//
// The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
//
//   +-------------------------------------+----------------------------------------+
//   |        QLIK SENSE ENTERPRISE        |           QLIK SENSE DESKTOP           |
//   +-------------------------------------+----------------------------------------+
//   | %ProgramData%/Qlik/Sense/Log/Engine | %UserProfile%/Documents/Qlik/Sense/Log |
//   +-------------------------------------+----------------------------------------+
//
// Parameters:
//
// ◾ appName                      -   Name of the app.
//
// ◾ localizedScriptMainSection   -   Name of the first section in the script editor.
// The default value is Main.
//
func (obj *Global) CreateApp(ctx context.Context, appName string, localizedScriptMainSection string) (bool, string, error) {
	result := &struct {
		Success bool   `json:"qSuccess"`
		AppId   string `json:"qAppId"`
	}{}
	err := obj.rpc(ctx, "CreateApp", result, appName, localizedScriptMainSection)
	return result.Success, result.AppId, err
}

// Creates an app and opens an engine session.
// This operation is possible only in Qlik Sense Desktop.
//
// Parameters:
//
// ◾ docName                      -   Name of the app.
//
// ◾ userName                     -   Name of the user.
//
// ◾ password                     -   Password of the user.
//
// ◾ serial                       -   Current Qlik Sense serial number.
//
// ◾ localizedScriptMainSection   -   Name of the first section in the script editor.
// The default value is Main.
//
func (obj *Global) CreateDocEx(ctx context.Context, docName string, userName string, password string, serial string, localizedScriptMainSection string) (*Doc, error) {
	result := &struct {
		DocId  string           `json:"qDocId"`
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateDocEx", result, docName, userName, password, serial, localizedScriptMainSection)
	if err != nil {
		return nil, err
	}
	result.Return.GenericId = result.DocId
	return &Doc{obj.session.getRemoteObject(result.Return)}, err
}

// Creates an empty session app.
// The following applies:
//
// • The name of a session app cannot be chosen. The engine automatically assigns a unique identifier to the session app.
//
// • A session app is not persisted and cannot be saved. Everything created during a session app is non-persisted; for example: objects, data connections.
func (obj *Global) CreateSessionApp(ctx context.Context) (*Doc, error) {
	result := &struct {
		SessionAppId string           `json:"qSessionAppId"`
		Return       *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionApp", result)
	if err != nil {
		return nil, err
	}
	result.Return.GenericId = result.SessionAppId
	return &Doc{obj.session.getRemoteObject(result.Return)}, err
}

// Creates a session app from a source app.
// The following applies:
//
// • The objects in the source app are copied into the session app but contain no data.
//
// • The script of the session app can be edited and reloaded.
//
// • The name of a session app cannot be chosen. The engine automatically assigns a unique identifier to the session app.
//
// • A session app is not persisted and cannot be saved. Everything created during a session app is non-persisted; for example: objects, data connections.
//
// Parameters:
//
// ◾ srcAppId   -   App identifier of the source app.
// It corresponds to qAppId returned by the CreateApp method when creating the source app.
//
func (obj *Global) CreateSessionAppFromApp(ctx context.Context, srcAppId string) (*Doc, error) {
	result := &struct {
		SessionAppId string           `json:"qSessionAppId"`
		Return       *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "CreateSessionAppFromApp", result, srcAppId)
	if err != nil {
		return nil, err
	}
	result.Return.GenericId = result.SessionAppId
	return &Doc{obj.session.getRemoteObject(result.Return)}, err
}

// Deletes an app from the Qlik Sense repository or from the file system.
//
// Qlik Sense Enterprise:
//
// In addition to being removed from the repository, the app is removed from the directory as well:
//
// •<installation_directory>\Qlik\Sense\Apps*
// The default installation directory is ProgramData.
//
// Qlik Sense Desktop:
//
// The app is deleted from the directory %userprofile%\Documents\Qlik\ \Apps.
//
// The operation is successful if qSuccess is set to true.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +--------------------------------------+--------------------------------+
//   |          AUDIT ACTIVITY LOG          |       SYSTEM SERVICE LOG       |
//   +--------------------------------------+--------------------------------+
//   | <MachineName>AuditActivityEngine.txt | <MachineName>ServiceEngine.txt |
//   | in Qlik Sense Enterprise             | in Qlik Sense Enterprise       |
//   | <MachineName>AuditActivityEngine.log | <MachineName>ServiceEngine.log |
//   | in Qlik Sense Desktop                | in Qlik Sense Desktop          |
//   +--------------------------------------+--------------------------------+
//
// Where to find the log files:
//
// The location of the log files depends on whether you have installed Qlik Sense Enterprise or Qlik Sense Desktop.
//
//   +-------------------------------------+----------------------------------------+
//   |        QLIK SENSE ENTERPRISE        |           QLIK SENSE DESKTOP           |
//   +-------------------------------------+----------------------------------------+
//   | %ProgramData%/Qlik/Sense/Log/Engine | %UserProfile%/Documents/Qlik/Sense/Log |
//   +-------------------------------------+----------------------------------------+
//
// Parameters:
//
// ◾ appId   -   Identifier of the app to delete.
// In Qlik Sense Enterprise, the identifier of the app is a GUID in the Qlik Sense repository.
// In Qlik Sense Desktop, the identifier of the app is the name of the app, as defined in the apps folder %userprofile%\Documents\Qlik\Sense\Apps.
//
func (obj *Global) DeleteApp(ctx context.Context, appId string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "DeleteApp", result, appId)
	return result.Success, err
}

// Returns the version number of the Qlik engine component.
func (obj *Global) EngineVersion(ctx context.Context) (*NxEngineVersion, error) {
	result := &struct {
		Version *NxEngineVersion `json:"qVersion"`
	}{}
	err := obj.rpc(ctx, "EngineVersion", result)
	return result.Version, err
}

// Returns the version number of the Qlik engine component.
func (obj *Global) EngineVersionRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Version json.RawMessage `json:"qVersion"`
	}{}
	err := obj.rpc(ctx, "EngineVersion", result)
	return result.Version, err
}

// Exports an app from the Qlik Sense repository to the file system.
// This operation is possible only in Qlik Sense Enterprise.
//
// The operation is successful if qSuccess is set to true.
//
// Logs:
//
// When this method is called, audit activity logs are produced to track the user activity.
// In the case of errors, both audit activity logs and system services logs are produced.
// The log files are named as follows:
//
//   +-----------------------------------------+-----------------------------------+
//   |           AUDIT ACTIVITY LOG            |        SYSTEM SERVICE LOG         |
//   +-----------------------------------------+-----------------------------------+
//   | *<MachineName>_AuditActivityEngine.txt* | *<MachineName>_ServiceEngine.txt* |
//   +-----------------------------------------+-----------------------------------+
//
// The log files are located in:
// _%ProgramData%/Qlik/Sense/Log/Engine_
//
// Parameters:
//
// ◾ targetPath   -   Path and name of the target app.
//
// ◾ srcAppId     -   Identifier of the source app. The identifier is a GUID from the Qlik Sense repository.
//
// ◾ ids          -   Array of identifiers.
// The list of all the objects in the app to be exported must be given. This list must contain the GUIDs of all these objects.
//
// ◾ noData       -   Set this parameter to true if the data should be omitted in the exported app.
//
func (obj *Global) ExportApp(ctx context.Context, targetPath string, srcAppId string, ids []string, noData bool) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "ExportApp", result, targetPath, srcAppId, ids, noData)
	return result.Success, err
}

// Returns the handle of the current app.
func (obj *Global) GetActiveDoc(ctx context.Context) (*Doc, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetActiveDoc", result)
	if err != nil {
		return nil, err
	}
	return &Doc{obj.session.getRemoteObject(result.Return)}, err
}

// Retrieves the meta data of an app.
//
// Parameters:
//
// ◾ appID   -   Identifier of the app, as returned by the CreateApp method.
// One of:
//
// • Path and name of the app (Qlik Sense Desktop)
//
// • GUID (Qlik Sense Enterprise)
//
func (obj *Global) GetAppEntry(ctx context.Context, appID string) (*AppEntry, error) {
	result := &struct {
		Entry *AppEntry `json:"qEntry"`
	}{}
	err := obj.rpc(ctx, "GetAppEntry", result, appID)
	return result.Entry, err
}

// Retrieves the meta data of an app.
//
// Parameters:
//
// ◾ appID   -   Identifier of the app, as returned by the CreateApp method.
// One of:
//
// • Path and name of the app (Qlik Sense Desktop)
//
// • GUID (Qlik Sense Enterprise)
//
func (obj *Global) GetAppEntryRaw(ctx context.Context, appID string) (json.RawMessage, error) {
	result := &struct {
		Entry json.RawMessage `json:"qEntry"`
	}{}
	err := obj.rpc(ctx, "GetAppEntry", result, ensureEncodable(appID))
	return result.Entry, err
}

// Retrieves information about the authenticated user.
func (obj *Global) GetAuthenticatedUser(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetAuthenticatedUser", result)
	return result.Return, err
}

// Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language. The BNF rules define the syntax for the script statements and the script or chart functions.
// In the Qlik engine BNF grammar, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
//
// Parameters:
//
// ◾ bnfType   -   Returns a set of rules defining the syntax for:
//
// • The script statements and the script functions if qBnfType is set to S.
//
// • The chart functions if qBnfType is set to E.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBNF(ctx context.Context, bnfType string) ([]*BNFDef, error) {
	result := &struct {
		BnfDefs []*BNFDef `json:"qBnfDefs"`
	}{}
	err := obj.rpc(ctx, "GetBNF", result, bnfType)
	return result.BnfDefs, err
}

// Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language. The BNF rules define the syntax for the script statements and the script or chart functions.
// In the Qlik engine BNF grammar, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
//
// Parameters:
//
// ◾ bnfType   -   Returns a set of rules defining the syntax for:
//
// • The script statements and the script functions if qBnfType is set to S.
//
// • The chart functions if qBnfType is set to E.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBNFRaw(ctx context.Context, bnfType string) (json.RawMessage, error) {
	result := &struct {
		BnfDefs json.RawMessage `json:"qBnfDefs"`
	}{}
	err := obj.rpc(ctx, "GetBNF", result, ensureEncodable(bnfType))
	return result.BnfDefs, err
}

// Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language, as well as a string hash calculated from that grammar. The BNF rules define the syntax for the script statements and the script or chart functions. If the hash changes between subsequent calls to this method, this indicates that the BNF has changed.
// In the Qlik engine grammars, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
//
// Parameters:
//
// ◾ bnfType   -   The type of grammar to return:
//
// • The script statements and the script functions if qBnfType is set to S.
//
// • The chart functions if qBnfType is set to E.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBaseBNF(ctx context.Context, bnfType string) ([]*BNFDef, string, error) {
	result := &struct {
		BnfDefs []*BNFDef `json:"qBnfDefs"`
		BnfHash string    `json:"qBnfHash"`
	}{}
	err := obj.rpc(ctx, "GetBaseBNF", result, bnfType)
	return result.BnfDefs, result.BnfHash, err
}

// Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language, as well as a string hash calculated from that grammar. The BNF rules define the syntax for the script statements and the script or chart functions. If the hash changes between subsequent calls to this method, this indicates that the BNF has changed.
// In the Qlik engine grammars, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
//
// Parameters:
//
// ◾ bnfType   -   The type of grammar to return:
//
// • The script statements and the script functions if qBnfType is set to S.
//
// • The chart functions if qBnfType is set to E.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBaseBNFRaw(ctx context.Context, bnfType string) (json.RawMessage, string, error) {
	result := &struct {
		BnfDefs json.RawMessage `json:"qBnfDefs"`
		BnfHash string          `json:"qBnfHash"`
	}{}
	err := obj.rpc(ctx, "GetBaseBNF", result, ensureEncodable(bnfType))
	return result.BnfDefs, result.BnfHash, err
}

// Gets a string hash calculated from the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language. If the hash changes between subsequent calls to this method, this indicates that the BNF grammar has changed.
//
// Parameters:
//
// ◾ bnfType   -   The type of grammar to return:
//
// • The script statements and the script functions if qBnfType is set to S.
//
// • The chart functions if qBnfType is set to E.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBaseBNFHash(ctx context.Context, bnfType string) (string, error) {
	result := &struct {
		BnfHash string `json:"qBnfHash"`
	}{}
	err := obj.rpc(ctx, "GetBaseBNFHash", result, bnfType)
	return result.BnfHash, err
}

// Gets the current Backus-Naur Form (BNF) grammar of the Qlik engine scripting language, as well as a string hash calculated from that grammar. The BNF rules define the syntax for the script statements and the script or chart functions. If the hash changes between subsequent calls to this method, this indicates that the BNF has changed.
// In the Qlik engine grammars, a token is a string of one or more characters that is significant as a group. For example, a token could be a function name, a number, a letter, a parenthesis, and so on.
//
// Parameters:
//
// ◾ bnfType   -   The type of grammar to return:
//
// • S: returns the script statements and the script functions.
//
// • E: returns the chart functions.
//
// One of:
//
// • S or SCRIPT_TEXT_SCRIPT
//
// • E or SCRIPT_TEXT_EXPRESSION
//
func (obj *Global) GetBaseBNFString(ctx context.Context, bnfType string) (string, string, error) {
	result := &struct {
		BnfStr  string `json:"qBnfStr"`
		BnfHash string `json:"qBnfHash"`
	}{}
	err := obj.rpc(ctx, "GetBaseBNFString", result, bnfType)
	return result.BnfStr, result.BnfHash, err
}

// List the custom connectors available in the system.
//
// Parameters:
//
// ◾ reloadList   -   Sets if the list of custom connectors should be reloaded or not.
// If set to false, only the connectors that were returned the previous time are returned. If new connectors have been added since the last call to the GetCustomConnectors method was made, the new connectors are not returned.
// If set to true, the GetCustomConnectors method looks for new connectors in the file system.
// The default value is false.
//
func (obj *Global) GetCustomConnectors(ctx context.Context, reloadList bool) ([]*CustomConnector, error) {
	result := &struct {
		Connectors []*CustomConnector `json:"qConnectors"`
	}{}
	err := obj.rpc(ctx, "GetCustomConnectors", result, reloadList)
	return result.Connectors, err
}

// List the custom connectors available in the system.
//
// Parameters:
//
// ◾ reloadList   -   Sets if the list of custom connectors should be reloaded or not.
// If set to false, only the connectors that were returned the previous time are returned. If new connectors have been added since the last call to the GetCustomConnectors method was made, the new connectors are not returned.
// If set to true, the GetCustomConnectors method looks for new connectors in the file system.
// The default value is false.
//
func (obj *Global) GetCustomConnectorsRaw(ctx context.Context, reloadList bool) (json.RawMessage, error) {
	result := &struct {
		Connectors json.RawMessage `json:"qConnectors"`
	}{}
	err := obj.rpc(ctx, "GetCustomConnectors", result, ensureEncodable(reloadList))
	return result.Connectors, err
}

// Lists the databases in a ODBC, OLEDB or CUSTOM data source.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Global) GetDatabasesFromConnectionString(ctx context.Context, connection *Connection) ([]*Database, error) {
	result := &struct {
		Databases []*Database `json:"qDatabases"`
	}{}
	err := obj.rpc(ctx, "GetDatabasesFromConnectionString", result, connection)
	return result.Databases, err
}

// Lists the databases in a ODBC, OLEDB or CUSTOM data source.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Global) GetDatabasesFromConnectionStringRaw(ctx context.Context, connection interface{}) (json.RawMessage, error) {
	result := &struct {
		Databases json.RawMessage `json:"qDatabases"`
	}{}
	err := obj.rpc(ctx, "GetDatabasesFromConnectionString", result, ensureEncodable(connection))
	return result.Databases, err
}

// Returns the folder where the apps are stored.
// This method applies only if running Qlik Sense Desktop.
func (obj *Global) GetDefaultAppFolder(ctx context.Context) (string, error) {
	result := &struct {
		Path string `json:"qPath"`
	}{}
	err := obj.rpc(ctx, "GetDefaultAppFolder", result)
	return result.Path, err
}

// Returns the list of apps.
//
// In Qlik Sense Enterprise::
//
// The list is generated by the QRS. The GetDocList method only returns documents the current user is allowed to access.
//
// In Qlik Sense Desktop::
//
// The apps are located in C:\Users\<user name>\Documents\Qlik\Sense\Apps.
func (obj *Global) GetDocList(ctx context.Context) ([]*DocListEntry, error) {
	result := &struct {
		DocList []*DocListEntry `json:"qDocList"`
	}{}
	err := obj.rpc(ctx, "GetDocList", result)
	return result.DocList, err
}

// Returns the list of apps.
//
// In Qlik Sense Enterprise::
//
// The list is generated by the QRS. The GetDocList method only returns documents the current user is allowed to access.
//
// In Qlik Sense Desktop::
//
// The apps are located in C:\Users\<user name>\Documents\Qlik\Sense\Apps.
func (obj *Global) GetDocListRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		DocList json.RawMessage `json:"qDocList"`
	}{}
	err := obj.rpc(ctx, "GetDocList", result)
	return result.DocList, err
}

// Returns the files and folders located at a specified path.
//
// Parameters:
//
// ◾ path   -   Absolute or relative path.
// Relative paths are relative to the default Apps folder.
//
// In Qlik Sense Enterprise::
//
// The list is generated by the QRS. The GetDocList method only returns documents the current user is allowed to access.
//
// In Qlik Sense Desktop::
//
// The apps are located in C:\Users\<user name>\Documents\Qlik\Sense\Apps.
//
func (obj *Global) GetFolderItemsForPath(ctx context.Context, path string) ([]*FolderItem, error) {
	result := &struct {
		FolderItems []*FolderItem `json:"qFolderItems"`
	}{}
	err := obj.rpc(ctx, "GetFolderItemsForPath", result, path)
	return result.FolderItems, err
}

// Returns the files and folders located at a specified path.
//
// Parameters:
//
// ◾ path   -   Absolute or relative path.
// Relative paths are relative to the default Apps folder.
//
// In Qlik Sense Enterprise::
//
// The list is generated by the QRS. The GetDocList method only returns documents the current user is allowed to access.
//
// In Qlik Sense Desktop::
//
// The apps are located in C:\Users\<user name>\Documents\Qlik\Sense\Apps.
//
func (obj *Global) GetFolderItemsForPathRaw(ctx context.Context, path string) (json.RawMessage, error) {
	result := &struct {
		FolderItems json.RawMessage `json:"qFolderItems"`
	}{}
	err := obj.rpc(ctx, "GetFolderItemsForPath", result, ensureEncodable(path))
	return result.FolderItems, err
}

// Gets the list of all the script functions.
//
// Parameters:
//
// ◾ group   -   Name of the group.
// Default is all groups.
//
// One of:
//
// • ALL or FUNC_GROUP_ALL
//
// • U or FUNC_GROUP_UNKNOWN
//
// • NONE or FUNC_GROUP_NONE
//
// • AGGR or FUNC_GROUP_AGGR
//
// • NUM or FUNC_GROUP_NUMERIC
//
// • RNG or FUNC_GROUP_RANGE
//
// • EXP or FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC
//
// • TRIG or FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC
//
// • FIN or FUNC_GROUP_FINANCIAL
//
// • MATH or FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE
//
// • COUNT or FUNC_GROUP_COUNTER
//
// • STR or FUNC_GROUP_STRING
//
// • MAPP or FUNC_GROUP_MAPPING
//
// • RCRD or FUNC_GROUP_INTER_RECORD
//
// • CND or FUNC_GROUP_CONDITIONAL
//
// • LOG or FUNC_GROUP_LOGICAL
//
// • NULL or FUNC_GROUP_NULL
//
// • SYS or FUNC_GROUP_SYSTEM
//
// • FILE or FUNC_GROUP_FILE
//
// • TBL or FUNC_GROUP_TABLE
//
// • DATE or FUNC_GROUP_DATE_AND_TIME
//
// • NUMI or FUNC_GROUP_NUMBER_INTERPRET
//
// • FRMT or FUNC_GROUP_FORMATTING
//
// • CLR or FUNC_GROUP_COLOR
//
// • RNK or FUNC_GROUP_RANKING
//
// • GEO or FUNC_GROUP_GEO
//
// • EXT or FUNC_GROUP_EXTERNAL
//
// • PROB or FUNC_GROUP_PROBABILITY
//
// • ARRAY or FUNC_GROUP_ARRAY
//
// • LEG or FUNC_GROUP_LEGACY
//
func (obj *Global) GetFunctions(ctx context.Context, group string) ([]*Function, error) {
	result := &struct {
		Functions []*Function `json:"qFunctions"`
	}{}
	err := obj.rpc(ctx, "GetFunctions", result, group)
	return result.Functions, err
}

// Gets the list of all the script functions.
//
// Parameters:
//
// ◾ group   -   Name of the group.
// Default is all groups.
//
// One of:
//
// • ALL or FUNC_GROUP_ALL
//
// • U or FUNC_GROUP_UNKNOWN
//
// • NONE or FUNC_GROUP_NONE
//
// • AGGR or FUNC_GROUP_AGGR
//
// • NUM or FUNC_GROUP_NUMERIC
//
// • RNG or FUNC_GROUP_RANGE
//
// • EXP or FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC
//
// • TRIG or FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC
//
// • FIN or FUNC_GROUP_FINANCIAL
//
// • MATH or FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE
//
// • COUNT or FUNC_GROUP_COUNTER
//
// • STR or FUNC_GROUP_STRING
//
// • MAPP or FUNC_GROUP_MAPPING
//
// • RCRD or FUNC_GROUP_INTER_RECORD
//
// • CND or FUNC_GROUP_CONDITIONAL
//
// • LOG or FUNC_GROUP_LOGICAL
//
// • NULL or FUNC_GROUP_NULL
//
// • SYS or FUNC_GROUP_SYSTEM
//
// • FILE or FUNC_GROUP_FILE
//
// • TBL or FUNC_GROUP_TABLE
//
// • DATE or FUNC_GROUP_DATE_AND_TIME
//
// • NUMI or FUNC_GROUP_NUMBER_INTERPRET
//
// • FRMT or FUNC_GROUP_FORMATTING
//
// • CLR or FUNC_GROUP_COLOR
//
// • RNK or FUNC_GROUP_RANKING
//
// • GEO or FUNC_GROUP_GEO
//
// • EXT or FUNC_GROUP_EXTERNAL
//
// • PROB or FUNC_GROUP_PROBABILITY
//
// • ARRAY or FUNC_GROUP_ARRAY
//
// • LEG or FUNC_GROUP_LEGACY
//
func (obj *Global) GetFunctionsRaw(ctx context.Context, group string) (json.RawMessage, error) {
	result := &struct {
		Functions json.RawMessage `json:"qFunctions"`
	}{}
	err := obj.rpc(ctx, "GetFunctions", result, ensureEncodable(group))
	return result.Functions, err
}

// Retrieves information on the user interaction that is requested by the engine.
// Engine can request user interactions only during script reload and when the reload is performed in debug mode ( qDebug is set to true when using the DoReload method ).
// When running reload in debug mode, the engine pauses the script execution to receive data about user interaction. The engine can pause:
//
// • Before executing a new script statement.
//
// • When an error occurs while executing the script.
//
// • When the script execution is finished.
//
// To know if the engine is paused and waits for a response to an interaction request, the GetProgress method should be used. The engine waits for a response if the property qUserInteractionWanted is set to true in the response of the GetProgress request.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the request.
// Corresponds to the identifier of the DoReload request.
//
func (obj *Global) GetInteract(ctx context.Context, requestId int) (*InteractDef, error) {
	result := &struct {
		Def    *InteractDef `json:"qDef"`
		Return bool         `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetInteract", result, requestId)
	return result.Def, err
}

// Retrieves information on the user interaction that is requested by the engine.
// Engine can request user interactions only during script reload and when the reload is performed in debug mode ( qDebug is set to true when using the DoReload method ).
// When running reload in debug mode, the engine pauses the script execution to receive data about user interaction. The engine can pause:
//
// • Before executing a new script statement.
//
// • When an error occurs while executing the script.
//
// • When the script execution is finished.
//
// To know if the engine is paused and waits for a response to an interaction request, the GetProgress method should be used. The engine waits for a response if the property qUserInteractionWanted is set to true in the response of the GetProgress request.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the request.
// Corresponds to the identifier of the DoReload request.
//
func (obj *Global) GetInteractRaw(ctx context.Context, requestId int) (json.RawMessage, error) {
	result := &struct {
		Def    json.RawMessage `json:"qDef"`
		Return bool            `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetInteract", result, ensureEncodable(requestId))
	return result.Def, err
}

// Lists the logical drives in the system.
// This method applies only if running Qlik Sense Desktop.
func (obj *Global) GetLogicalDriveStrings(ctx context.Context) ([]*DriveInfo, error) {
	result := &struct {
		Drives []*DriveInfo `json:"qDrives"`
	}{}
	err := obj.rpc(ctx, "GetLogicalDriveStrings", result)
	return result.Drives, err
}

// Lists the logical drives in the system.
// This method applies only if running Qlik Sense Desktop.
func (obj *Global) GetLogicalDriveStringsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Drives json.RawMessage `json:"qDrives"`
	}{}
	err := obj.rpc(ctx, "GetLogicalDriveStrings", result)
	return result.Drives, err
}

// Returns the list of the ODBC connectors that are installed in the system.
func (obj *Global) GetOdbcDsns(ctx context.Context) ([]*OdbcDsn, error) {
	result := &struct {
		OdbcDsns []*OdbcDsn `json:"qOdbcDsns"`
	}{}
	err := obj.rpc(ctx, "GetOdbcDsns", result)
	return result.OdbcDsns, err
}

// Returns the list of the ODBC connectors that are installed in the system.
func (obj *Global) GetOdbcDsnsRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		OdbcDsns json.RawMessage `json:"qOdbcDsns"`
	}{}
	err := obj.rpc(ctx, "GetOdbcDsns", result)
	return result.OdbcDsns, err
}

// Returns the list of the OLEDB providers installed on the system.
func (obj *Global) GetOleDbProviders(ctx context.Context) ([]*OleDbProvider, error) {
	result := &struct {
		OleDbProviders []*OleDbProvider `json:"qOleDbProviders"`
	}{}
	err := obj.rpc(ctx, "GetOleDbProviders", result)
	return result.OleDbProviders, err
}

// Returns the list of the OLEDB providers installed on the system.
func (obj *Global) GetOleDbProvidersRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		OleDbProviders json.RawMessage `json:"qOleDbProviders"`
	}{}
	err := obj.rpc(ctx, "GetOleDbProviders", result)
	return result.OleDbProviders, err
}

// Gives information about the progress of the DoReload and DoSave calls.
// For more information on DoReload and DoSave, see the DoReload Method and DoSave Method.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the DoReload or DoSave request or 0.
// Complete information is returned if the identifier of the request is given.
// If the identifier is 0, less information is given. Progress messages and error messages are returned but information like when the request started and finished is not returned.
//
func (obj *Global) GetProgress(ctx context.Context, requestId int) (*ProgressData, error) {
	result := &struct {
		ProgressData *ProgressData `json:"qProgressData"`
	}{}
	err := obj.rpc(ctx, "GetProgress", result, requestId)
	return result.ProgressData, err
}

// Gives information about the progress of the DoReload and DoSave calls.
// For more information on DoReload and DoSave, see the DoReload Method and DoSave Method.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the DoReload or DoSave request or 0.
// Complete information is returned if the identifier of the request is given.
// If the identifier is 0, less information is given. Progress messages and error messages are returned but information like when the request started and finished is not returned.
//
func (obj *Global) GetProgressRaw(ctx context.Context, requestId int) (json.RawMessage, error) {
	result := &struct {
		ProgressData json.RawMessage `json:"qProgressData"`
	}{}
	err := obj.rpc(ctx, "GetProgress", result, ensureEncodable(requestId))
	return result.ProgressData, err
}

// Lists the streams.
func (obj *Global) GetStreamList(ctx context.Context) ([]*NxStreamListEntry, error) {
	result := &struct {
		StreamList []*NxStreamListEntry `json:"qStreamList"`
	}{}
	err := obj.rpc(ctx, "GetStreamList", result)
	return result.StreamList, err
}

// Lists the streams.
func (obj *Global) GetStreamListRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		StreamList json.RawMessage `json:"qStreamList"`
	}{}
	err := obj.rpc(ctx, "GetStreamList", result)
	return result.StreamList, err
}

// Lists the supported code pages.
func (obj *Global) GetSupportedCodePages(ctx context.Context) ([]*CodePage, error) {
	result := &struct {
		CodePages []*CodePage `json:"qCodePages"`
	}{}
	err := obj.rpc(ctx, "GetSupportedCodePages", result)
	return result.CodePages, err
}

// Lists the supported code pages.
func (obj *Global) GetSupportedCodePagesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		CodePages json.RawMessage `json:"qCodePages"`
	}{}
	err := obj.rpc(ctx, "GetSupportedCodePages", result)
	return result.CodePages, err
}

// Returns the unique identifier of the endpoint for the current user in the current app.
// This unique identifier can be used for logging purposes.
func (obj *Global) GetUniqueID(ctx context.Context) (string, error) {
	result := &struct {
		UniqueID string `json:"qUniqueID"`
	}{}
	err := obj.rpc(ctx, "GetUniqueID", result)
	return result.UniqueID, err
}

// Informs the engine that a user interaction (which was earlier requested by the engine) was performed and indicates to the engine what to do next.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the request.
// Corresponds to the identifier of the DoReload request.
//
// ◾ def         -   User response to the current interaction.
//
func (obj *Global) InteractDone(ctx context.Context, requestId int, def *InteractDef) error {
	err := obj.rpc(ctx, "InteractDone", nil, requestId, def)
	return err
}

// Informs the engine that a user interaction (which was earlier requested by the engine) was performed and indicates to the engine what to do next.
//
// Parameters:
//
// ◾ requestId   -   Identifier of the request.
// Corresponds to the identifier of the DoReload request.
//
// ◾ def         -   User response to the current interaction.
//
func (obj *Global) InteractDoneRaw(ctx context.Context, requestId int, def interface{}) error {
	err := obj.rpc(ctx, "InteractDone", nil, ensureEncodable(requestId), ensureEncodable(def))
	return err
}

// Indicates whether the user is working in Qlik Sense Desktop.
func (obj *Global) IsDesktopMode(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "IsDesktopMode", result)
	return result.Return, err
}

// Indicates whether or not the user is working in personal mode (Qlik Sense Desktop).
func (obj *Global) IsPersonalMode(ctx context.Context) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "IsPersonalMode", result)
	return result.Return, err
}

// Checks if a connection string is valid.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Global) IsValidConnectionString(ctx context.Context, connection *Connection) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "IsValidConnectionString", result, connection)
	return result.Return, err
}

// Checks if a connection string is valid.
//
// Parameters:
//
// ◾ connection   -   Information about the connection.
//
func (obj *Global) IsValidConnectionStringRaw(ctx context.Context, connection interface{}) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "IsValidConnectionString", result, ensureEncodable(connection))
	return result.Return, err
}

// Returns the name of the operating system.
func (obj *Global) OSName(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "OSName", result)
	return result.Return, err
}

// Returns the version number of the operating system.
func (obj *Global) OSVersion(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "OSVersion", result)
	return result.Return, err
}

// Opens an app and checks if the app needs to be migrated (if the app is deprecated).
// The OpenDoc method compares the version of the app with the version of Qlik Sense and migrates the app to the current version of Qlik Sense if necessary. Once the migration is done, the app is opened.
// If no migration is needed, the app is opened immediately.
// The following applies:
//
// • The app version is lower than 0.95: no migration is done. Apps older than the version 0.95 are not supported.
//
// • The app version is at least 0.95 and less than the Qlik Sense version: the app is migrated and then opened.
//
// • Qlik Sense and the app have the same version: the app is opened, no migration is needed.
//
// If the app is read-only, the app migration cannot occur. An error message is sent.
//
// Backups:
//
// In Qlik Sense Desktop, apps are automatically backed up before a migration.
// The backup files are located in %userprofile%\Documents\Qlik\Sense\AppsBackup\<Qlik Sense Desktop version>.
// In Qlik Sense Enterprise, no automatic back up is run. The back up should be done manually.
//
// Parameters:
//
// ◾ docName    -   The GUID (in Qlik Sense Enterprise) or Name (in Qlik Sense Desktop) of the app to retrieve.
//
// ◾ userName   -   Name of the user that opens the app.
//
// ◾ password   -   Password of the user.
//
// ◾ serial     -   Current Qlik Sense serial number.
//
// ◾ noData     -   Set this parameter to true to be able to open an app without loading its data.
// When this parameter is set to true, the objects in the app are present but contain no data. The script can be edited and reloaded.
// The default value is false.
//
func (obj *Global) OpenDoc(ctx context.Context, docName string, userName string, password string, serial string, noData bool) (*Doc, error) {
	result := &struct {
		Return *ObjectInterface `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "OpenDoc", result, docName, userName, password, serial, noData)
	if err != nil {
		return nil, err
	}
	return &Doc{obj.session.getRemoteObject(result.Return)}, err
}

// Returns the Qlik Sense version number.
func (obj *Global) ProductVersion(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "ProductVersion", result)
	return result.Return, err
}

// Publishes an app to the supplied stream.
//
// Parameters:
//
// ◾ appId      -   The Id of the app to publish.
//
// ◾ name       -   The name of the app to publish.
//
// ◾ streamId   -   The stream Id of the app to publish.
//
func (obj *Global) PublishApp(ctx context.Context, appId string, name string, streamId string) error {
	err := obj.rpc(ctx, "PublishApp", nil, appId, name, streamId)
	return err
}

// Returns the Qlik product name.
func (obj *Global) QTProduct(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "QTProduct", result)
	return result.Return, err
}

// Returns the Qlik Sense version number.
func (obj *Global) QvVersion(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "QvVersion", result)
	return result.Return, err
}

// Reloads the list of extensions.
func (obj *Global) ReloadExtensionList(ctx context.Context) error {
	err := obj.rpc(ctx, "ReloadExtensionList", nil)
	return err
}

// Replaces objects of a target app with the objects from a source app.
// The list of objects in the app to be replaced must be defined in qIds.
// The data model of the app cannot be updated.
// This operation is possible only in Qlik Sense Enterprise.
//
// The operation is successful if qSuccess is set to true.
//
// Parameters:
//
// ◾ targetAppId   -   Identifier (GUID) of the target app.
// The target app is the app to be replaced.
//
// ◾ srcAppID      -   Identifier (GUID) of the source app.
// The objects in the source app will replace the objects in the target app.
//
// ◾ ids           -   QRS identifiers (GUID) of the objects in the target app to be replaced. Only QRS-approved GUIDs are applicable.
// An object that is QRS-approved, is for example an object that has been published (for example, not private anymore).
// If an object is private, it should not be included in this list.
// If the array of identifiers contains objects that are not present in the source app, the objects related to these identifiers are removed from the target app.
// If qIds is empty, no objects are deleted in the target app.
//
func (obj *Global) ReplaceAppFromID(ctx context.Context, targetAppId string, srcAppID string, ids []string) (bool, error) {
	result := &struct {
		Success bool `json:"qSuccess"`
	}{}
	err := obj.rpc(ctx, "ReplaceAppFromID", result, targetAppId, srcAppID, ids)
	return result.Success, err
}

// Shuts down the Qlik engine.
// This operation is possible only in Qlik Sense Desktop.
func (obj *Global) ShutdownProcess(ctx context.Context) error {
	err := obj.rpc(ctx, "ShutdownProcess", nil)
	return err
}

// This class describes all the methods that apply at variable level.
// Methods in this class are deprecated. Use methods in the GenericVariableClass instead.
//
// The handle member in the JSON request for all methods listed in this section is the handle of the variable.
type Variable struct {
	*RemoteObject
}

// Sets the value of a dual variable overriding any input constraints.
//
// Parameters:
//
// ◾ s   -   String representation of a dual value.
// Set this parameter to "", if the string representation is to be Null.
//
// ◾ d   -   Numeric representation of a dual value.
//
func (obj *Variable) ForceContent(ctx context.Context, s string, d Float64) error {
	err := obj.rpc(ctx, "ForceContent", nil, s, d)
	return err
}

// Returns the calculated value of a variable.
func (obj *Variable) GetContent(ctx context.Context) (*AlfaNumString, error) {
	result := &struct {
		Content *AlfaNumString `json:"qContent"`
	}{}
	err := obj.rpc(ctx, "GetContent", result)
	return result.Content, err
}

// Returns the calculated value of a variable.
func (obj *Variable) GetContentRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Content json.RawMessage `json:"qContent"`
	}{}
	err := obj.rpc(ctx, "GetContent", result)
	return result.Content, err
}

// Gets the properties of a variable.
func (obj *Variable) GetNxProperties(ctx context.Context) (*NxVariableProperties, error) {
	result := &struct {
		Properties *NxVariableProperties `json:"qProperties"`
	}{}
	err := obj.rpc(ctx, "GetNxProperties", result)
	return result.Properties, err
}

// Gets the properties of a variable.
func (obj *Variable) GetNxPropertiesRaw(ctx context.Context) (json.RawMessage, error) {
	result := &struct {
		Properties json.RawMessage `json:"qProperties"`
	}{}
	err := obj.rpc(ctx, "GetNxProperties", result)
	return result.Properties, err
}

// Returns the raw value of a variable.
func (obj *Variable) GetRawContent(ctx context.Context) (string, error) {
	result := &struct {
		Return string `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "GetRawContent", result)
	return result.Return, err
}

// Sets a value to a variable.
//
// Parameters:
//
// ◾ content     -   Value of the variable.
//
// ◾ updateMRU   -   If set to true, the value is added to the Most Recently Used (MRU) list.
//
func (obj *Variable) SetContent(ctx context.Context, content string, updateMRU bool) (bool, error) {
	result := &struct {
		Return bool `json:"qReturn"`
	}{}
	err := obj.rpc(ctx, "SetContent", result, content, updateMRU)
	return result.Return, err
}

// Sets some properties to a variable.
//
// Parameters:
//
// ◾ properties   -   Information about the properties of the variable
//
func (obj *Variable) SetNxProperties(ctx context.Context, properties *NxVariableProperties) error {
	err := obj.rpc(ctx, "SetNxProperties", nil, properties)
	return err
}

// Sets some properties to a variable.
//
// Parameters:
//
// ◾ properties   -   Information about the properties of the variable
//
func (obj *Variable) SetNxPropertiesRaw(ctx context.Context, properties interface{}) error {
	err := obj.rpc(ctx, "SetNxProperties", nil, ensureEncodable(properties))
	return err
}

var argInitCalled = false

//argInit initializes all the valid arguments for the generated "enum" (string) types.
//This method should be called once for the argument validation to work.
func argInit() {
	argInitCalled = true
	AddArgumentsForType(BNFDefMetaType(""), []string{"NOT_META", "N", "META_DOC_NAME", "D", "META_RET_TYPE", "R", "META_DEFAULT_VALUE", "V"})
	AddArgumentsForType(BNFType(""), []string{"SCRIPT_TEXT_SCRIPT", "S", "SCRIPT_TEXT_EXPRESSION", "E"})
	AddArgumentsForType(CharEncodingType(""), []string{"CHAR_ENCODING_UTF8", "Utf8", "CHAR_ENCODING_UTF16", "Utf16"})
	AddArgumentsForType(DriveType(""), []string{"REMOVABLE", "FIXED", "NETWORK", "CD_ROM", "RAM", "UNKNOWN_TYPE"})
	AddArgumentsForType(ErrorDataCode(""), []string{"EDC_ERROR", "EDC_WARNING", "EDC_CIRCULAR_REFERENCE"})
	AddArgumentsForType(FieldAttrType(""), []string{"UNKNOWN", "U", "ASCII", "A", "INTEGER", "I", "REAL", "R", "FIX", "F", "MONEY", "M", "DATE", "D", "TIME", "T", "TIMESTAMP", "TS", "INTERVAL", "IV"})
	AddArgumentsForType(FieldType(""), []string{"NOT_PRESENT", "PRESENT", "IS_CYCLIC_GROUP", "IS_DRILL_GROUP", "IS_VAR", "IS_EXPR", "IS_IMPLICIT", "IS_DETAIL"})
	AddArgumentsForType(FileType(""), []string{"FILE_TYPE_CSV", "CSV", "FILE_TYPE_FIX", "FIX", "FILE_TYPE_DIF", "DIF", "FILE_TYPE_EXCEL_BIFF", "EXCEL_BIFF", "FILE_TYPE_EXCEL_OOXML", "EXCEL_OOXML", "FILE_TYPE_HTML", "HTML", "FILE_TYPE_QVD", "QVD", "FILE_TYPE_XML", "XML", "FILE_TYPE_QVX", "QVX", "FILE_TYPE_JSON", "JSON", "FILE_TYPE_KML", "KML"})
	AddArgumentsForType(FilterType(""), []string{"FILTER_TYPE_NONE", "NONE", "FILTER_TYPE_RAW", "RAW"})
	AddArgumentsForType(FolderItemType(""), []string{"FOLDER_ITEM_FOLDER", "FOLDER", "FOLDER_ITEM_FILE", "FILE", "FOLDER_ITEM_OTHER", "OTHER"})
	AddArgumentsForType(FunctionGroup(""), []string{"FUNC_GROUP_ALL", "ALL", "FUNC_GROUP_UNKNOWN", "U", "FUNC_GROUP_NONE", "NONE", "FUNC_GROUP_AGGR", "AGGR", "FUNC_GROUP_NUMERIC", "NUM", "FUNC_GROUP_RANGE", "RNG", "FUNC_GROUP_EXPONENTIAL_AND_LOGARITHMIC", "EXP", "FUNC_GROUP_TRIGONOMETRIC_AND_HYPERBOLIC", "TRIG", "FUNC_GROUP_FINANCIAL", "FIN", "FUNC_GROUP_MATH_CONSTANT_AND_PARAM_FREE", "MATH", "FUNC_GROUP_COUNTER", "COUNT", "FUNC_GROUP_STRING", "STR", "FUNC_GROUP_MAPPING", "MAPP", "FUNC_GROUP_INTER_RECORD", "RCRD", "FUNC_GROUP_CONDITIONAL", "CND", "FUNC_GROUP_LOGICAL", "LOG", "FUNC_GROUP_NULL", "NULL", "FUNC_GROUP_SYSTEM", "SYS", "FUNC_GROUP_FILE", "FILE", "FUNC_GROUP_TABLE", "TBL", "FUNC_GROUP_DATE_AND_TIME", "DATE", "FUNC_GROUP_NUMBER_INTERPRET", "NUMI", "FUNC_GROUP_FORMATTING", "FRMT", "FUNC_GROUP_COLOR", "CLR", "FUNC_GROUP_RANKING", "RNK", "FUNC_GROUP_GEO", "GEO", "FUNC_GROUP_EXTERNAL", "EXT", "FUNC_GROUP_PROBABILITY", "PROB", "FUNC_GROUP_ARRAY", "ARRAY", "FUNC_GROUP_LEGACY", "LEG"})
	AddArgumentsForType(GenericConnectMachine(""), []string{"CONNECT_DEFAULT", "CONNECT_64", "CONNECT_32"})
	AddArgumentsForType(InteractType(""), []string{"IT_MSGBOX", "IT_SCRIPTLINE", "IT_BREAK", "IT_INPUT", "IT_END", "IT_PASSWD", "IT_USERNAME"})
	AddArgumentsForType(KeyType(""), []string{"NOT_KEY", "ANY_KEY", "PRIMARY_KEY", "PERFECT_KEY"})
	AddArgumentsForType(LogOnType(""), []string{"LOG_ON_SERVICE_USER", "LOG_ON_CURRENT_USER"})
	AddArgumentsForType(NxDataReductionMode(""), []string{"DATA_REDUCTION_NONE", "N", "DATA_REDUCTION_ONEDIM", "D1", "DATA_REDUCTION_SCATTERED", "S", "DATA_REDUCTION_CLUSTERED", "C", "DATA_REDUCTION_STACKED", "ST"})
	AddArgumentsForType(NxDimCellType(""), []string{"NX_DIM_CELL_VALUE", "V", "NX_DIM_CELL_EMPTY", "E", "NX_DIM_CELL_NORMAL", "N", "NX_DIM_CELL_TOTAL", "T", "NX_DIM_CELL_OTHER", "O", "NX_DIM_CELL_AGGR", "A", "NX_DIM_CELL_PSEUDO", "P", "NX_DIM_CELL_ROOT", "R", "NX_DIM_CELL_NULL", "U", "NX_DIM_CELL_GENERATED", "G"})
	AddArgumentsForType(NxDimensionType(""), []string{"NX_DIMENSION_TYPE_DISCRETE", "D", "NX_DIMENSION_TYPE_NUMERIC", "N", "NX_DIMENSION_TYPE_TIME", "T"})
	AddArgumentsForType(NxExportFileType(""), []string{"EXPORT_CSV_C", "CSV_C", "EXPORT_CSV_T", "CSV_T", "EXPORT_OOXML", "OOXML"})
	AddArgumentsForType(NxExportState(""), []string{"EXPORT_POSSIBLE", "P", "EXPORT_ALL", "A"})
	AddArgumentsForType(NxFieldSelectionMode(""), []string{"SELECTION_MODE_NORMAL", "NORMAL", "SELECTION_MODE_AND", "AND", "SELECTION_MODE_NOT", "NOT"})
	AddArgumentsForType(NxFrequencyMode(""), []string{"NX_FREQUENCY_NONE", "N", "NX_FREQUENCY_VALUE", "V", "NX_FREQUENCY_PERCENT", "P", "NX_FREQUENCY_RELATIVE", "R"})
	AddArgumentsForType(NxGrpType(""), []string{"GRP_NX_NONE", "N", "GRP_NX_HIEARCHY", "H", "GRP_NX_COLLECTION", "C"})
	AddArgumentsForType(NxHypercubeMode(""), []string{"DATA_MODE_STRAIGHT", "S", "DATA_MODE_PIVOT", "P", "DATA_MODE_PIVOT_STACK", "K", "DATA_MODE_TREE", "T"})
	AddArgumentsForType(NxLocalizedErrorCode(""), []string{"LOCERR_INTERNAL_ERROR", "LOCERR_GENERIC_UNKNOWN", "LOCERR_GENERIC_OK", "LOCERR_GENERIC_NOT_SET", "LOCERR_GENERIC_NOT_FOUND", "LOCERR_GENERIC_ALREADY_EXISTS", "LOCERR_GENERIC_INVALID_PATH", "LOCERR_GENERIC_ACCESS_DENIED", "LOCERR_GENERIC_OUT_OF_MEMORY", "LOCERR_GENERIC_NOT_INITIALIZED", "LOCERR_GENERIC_INVALID_PARAMETERS", "LOCERR_GENERIC_EMPTY_PARAMETERS", "LOCERR_GENERIC_INTERNAL_ERROR", "LOCERR_GENERIC_CORRUPT_DATA", "LOCERR_GENERIC_MEMORY_INCONSISTENCY", "LOCERR_GENERIC_INVISIBLE_OWNER_ABORT", "LOCERR_GENERIC_PROHIBIT_VALIDATE", "LOCERR_GENERIC_ABORTED", "LOCERR_GENERIC_CONNECTION_LOST", "LOCERR_GENERIC_UNSUPPORTED_IN_PRODUCT_VERSION", "LOCERR_GENERIC_REST_CONNECTION_FAILURE", "LOCERR_GENERIC_MEMORY_LIMIT_REACHED", "LOCERR_GENERIC_NOT_IMPLEMENTED", "LOCERR_HTTP_400", "LOCERR_HTTP_401", "LOCERR_HTTP_402", "LOCERR_HTTP_403", "LOCERR_HTTP_404", "LOCERR_HTTP_405", "LOCERR_HTTP_406", "LOCERR_HTTP_407", "LOCERR_HTTP_408", "LOCERR_HTTP_409", "LOCERR_HTTP_410", "LOCERR_HTTP_411", "LOCERR_HTTP_412", "LOCERR_HTTP_413", "LOCERR_HTTP_414", "LOCERR_HTTP_415", "LOCERR_HTTP_416", "LOCERR_HTTP_417", "LOCERR_HTTP_422", "LOCERR_HTTP_429", "LOCERR_HTTP_500", "LOCERR_HTTP_501", "LOCERR_HTTP_502", "LOCERR_HTTP_503", "LOCERR_HTTP_504", "LOCERR_HTTP_505", "LOCERR_HTTP_509", "LOCERR_HTTP_COULD_NOT_RESOLVE_HOST", "LOCERR_APP_ALREADY_EXISTS", "LOCERR_APP_INVALID_NAME", "LOCERR_APP_ALREADY_OPEN", "LOCERR_APP_NOT_FOUND", "LOCERR_APP_IMPORT_FAILED", "LOCERR_APP_SAVE_FAILED", "LOCERR_APP_CREATE_FAILED", "LOCERR_APP_INVALID", "LOCERR_APP_CONNECT_FAILED", "LOCERR_APP_ALREADY_OPEN_IN_DIFFERENT_MODE", "LOCERR_APP_MIGRATION_COULD_NOT_CONTACT_MIGRATION_SERVICE", "LOCERR_APP_MIGRATION_COULD_NOT_START_MIGRATION", "LOCERR_APP_MIGRATION_FAILURE", "LOCERR_APP_SCRIPT_MISSING", "LOCERR_APP_EXPORT_FAILED", "LOCERR_CONNECTION_ALREADY_EXISTS", "LOCERR_CONNECTION_NOT_FOUND", "LOCERR_CONNECTION_FAILED_TO_LOAD", "LOCERR_CONNECTION_FAILED_TO_IMPORT", "LOCERR_CONNECTION_NAME_IS_INVALID", "LOCERR_CONNECTOR_NO_FILE_STREAMING_SUPPORT", "LOCERR_CONNECTOR_FILESIZE_EXCEEDED_BUFFER_SIZE", "LOCERR_FILE_ACCESS_DENIED", "LOCERR_FILE_NAME_INVALID", "LOCERR_FILE_CORRUPT", "LOCERR_FILE_NOT_FOUND", "LOCERR_FILE_FORMAT_UNSUPPORTED", "LOCERR_FILE_OPENED_IN_UNSUPPORTED_MODE", "LOCERR_FILE_TABLE_NOT_FOUND", "LOCERR_USER_ACCESS_DENIED", "LOCERR_USER_IMPERSONATION_FAILED", "LOCERR_SERVER_OUT_OF_SESSION_AND_USER_CALS", "LOCERR_SERVER_OUT_OF_SESSION_CALS", "LOCERR_SERVER_OUT_OF_USAGE_CALS", "LOCERR_SERVER_OUT_OF_CALS", "LOCERR_SERVER_OUT_OF_NAMED_CALS", "LOCERR_SERVER_OFF_DUTY", "LOCERR_SERVER_BUSY", "LOCERR_SERVER_LICENSE_EXPIRED", "LOCERR_SERVER_AJAX_DISABLED", "LOCERR_SERVER_NO_TOKEN", "LOCERR_HC_INVALID_OBJECT", "LOCERR_HC_RESULT_TOO_LARGE", "LOCERR_HC_INVALID_OBJECT_STATE", "LOCERR_HC_MODAL_OBJECT_ERROR", "LOCERR_CALC_INVALID_DEF", "LOCERR_CALC_NOT_IN_LIB", "LOCERR_CALC_HEAP_ERROR", "LOCERR_CALC_TOO_LARGE", "LOCERR_CALC_TIMEOUT", "LOCERR_CALC_EVAL_CONDITION_FAILED", "LOCERR_CALC_MIXED_LINKED_AGGREGATION", "LOCERR_CALC_MISSING_LINKED", "LOCERR_CALC_INVALID_COL_SORT", "LOCERR_CALC_PAGES_TOO_LARGE", "LOCERR_CALC_SEMANTIC_FIELD_NOT_ALLOWED", "LOCERR_CALC_VALIDATION_STATE_INVALID", "LOCERR_CALC_PIVOT_DIMENSIONS_ALREADY_EXISTS", "LOCERR_CALC_MISSING_LINKED_FIELD", "LOCERR_CALC_NOT_CALCULATED", "LOCERR_LAYOUT_EXTENDS_INVALID_ID", "LOCERR_LAYOUT_LINKED_OBJECT_NOT_FOUND", "LOCERR_LAYOUT_LINKED_OBJECT_INVALID", "LOCERR_PERSISTENCE_WRITE_FAILED", "LOCERR_PERSISTENCE_READ_FAILED", "LOCERR_PERSISTENCE_DELETE_FAILED", "LOCERR_PERSISTENCE_NOT_FOUND", "LOCERR_PERSISTENCE_UNSUPPORTED_VERSION", "LOCERR_PERSISTENCE_MIGRATION_FAILED_READ_ONLY", "LOCERR_PERSISTENCE_MIGRATION_CANCELLED", "LOCERR_PERSISTENCE_MIGRATION_BACKUP_FAILED", "LOCERR_PERSISTENCE_DISK_FULL", "LOCERR_PERSISTENCE_NOT_SUPPORTED_FOR_SESSION_APP", "LOCERR_PERSISTENCE_MOVE_FAILED", "LOCERR_PERSISTENCE_SYNC_SET_CHUNK_INVALID_PARAMETERS", "LOCERR_PERSISTENCE_SYNC_GET_CHUNK_INVALID_PARAMETERS", "LOCERR_SCRIPT_DATASOURCE_ACCESS_DENIED", "LOCERR_RELOAD_IN_PROGRESS", "LOCERR_RELOAD_TABLE_X_NOT_FOUND", "LOCERR_RELOAD_UNKNOWN_STATEMENT", "LOCERR_RELOAD_EXPECTED_SOMETHING_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_NOTHING_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_1_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_2_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_3_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_4_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_5_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_6_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_7_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_EXPECTED_ONE_OF_8_OR_MORE_TOKENS_FOUND_UNKNOWN", "LOCERR_RELOAD_FIELD_X_NOT_FOUND", "LOCERR_RELOAD_MAPPING_TABLE_X_NOT_FOUND", "LOCERR_RELOAD_LIB_CONNECTION_X_NOT_FOUND", "LOCERR_RELOAD_NAME_ALREADY_TAKEN", "LOCERR_RELOAD_WRONG_FILE_FORMAT_DIF", "LOCERR_RELOAD_WRONG_FILE_FORMAT_BIFF", "LOCERR_RELOAD_WRONG_FILE_FORMAT_ENCRYPTED", "LOCERR_RELOAD_OPEN_FILE_ERROR", "LOCERR_RELOAD_AUTO_GENERATE_COUNT", "LOCERR_RELOAD_PE_ILLEGAL_PREFIX_COMB", "LOCERR_RELOAD_MATCHING_CONTROL_STATEMENT_ERROR", "LOCERR_RELOAD_MATCHING_LIBPATH_X_NOT_FOUND", "LOCERR_RELOAD_MATCHING_LIBPATH_X_INVALID", "LOCERR_RELOAD_MATCHING_LIBPATH_X_OUTSIDE", "LOCERR_RELOAD_NO_QUALIFIED_PATH_FOR_FILE", "LOCERR_RELOAD_MODE_STATEMENT_ONLY_FOR_LIB_PATHS", "LOCERR_RELOAD_INCONSISTENT_USE_OF_SEMANTIC_FIELDS", "LOCERR_RELOAD_NO_OPEN_DATABASE", "LOCERR_RELOAD_AGGREGATION_REQUIRED_BY_GROUP_BY", "LOCERR_RELOAD_CONNECT_MUST_USE_LIB_PREFIX_IN_THIS_MODE", "LOCERR_RELOAD_ODBC_CONNECT_FAILED", "LOCERR_RELOAD_OLEDB_CONNECT_FAILED", "LOCERR_RELOAD_CUSTOM_CONNECT_FAILED", "LOCERR_RELOAD_ODBC_READ_FAILED", "LOCERR_RELOAD_OLEDB_READ_FAILED", "LOCERR_RELOAD_CUSTOM_READ_FAILED", "LOCERR_RELOAD_BINARY_LOAD_PROHIBITED", "LOCERR_RELOAD_CONNECTOR_START_FAILED", "LOCERR_RELOAD_CONNECTOR_NOT_RESPONDING", "LOCERR_RELOAD_CONNECTOR_REPLY_ERROR", "LOCERR_RELOAD_CONNECTOR_CONNECT_ERROR", "LOCERR_RELOAD_CONNECTOR_NOT_FOUND_ERROR", "LOCERR_RELOAD_INPUT_FIELD_WITH_DUPLICATE_KEYS", "LOCERR_RELOAD_CONCATENATE_LOAD_NO_PREVIOUS_TABLE", "LOCERR_RELOAD_WRONG_FILE_FORMAT_QVD", "LOCERR_PERSONAL_NEW_VERSION_AVAILABLE", "LOCERR_PERSONAL_VERSION_EXPIRED", "LOCERR_PERSONAL_SECTION_ACCESS_DETECTED", "LOCERR_PERSONAL_APP_DELETION_FAILED", "LOCERR_USER_AUTHENTICATION_FAILURE", "LOCERR_EXPORT_OUT_OF_MEMORY", "LOCERR_EXPORT_NO_DATA", "LOCERR_SYNC_INVALID_OFFSET", "LOCERR_SEARCH_TIMEOUT", "LOCERR_DIRECT_DISCOVERY_LINKED_EXPRESSION_FAIL", "LOCERR_DIRECT_DISCOVERY_ROWCOUNT_OVERFLOW", "LOCERR_DIRECT_DISCOVERY_EMPTY_RESULT", "LOCERR_DIRECT_DISCOVERY_DB_CONNECTION_FAILED", "LOCERR_DIRECT_DISCOVERY_MEASURE_NOT_ALLOWED", "LOCERR_DIRECT_DISCOVERY_DETAIL_NOT_ALLOWED", "LOCERR_DIRECT_DISCOVERY_NOT_SYNTH_CIRCULAR_ALLOWED", "LOCERR_DIRECT_DISCOVERY_ONLY_ONE_DD_TABLE_ALLOWED", "LOCERR_DIRECT_DISCOVERY_DB_AUTHORIZATION_FAILED", "LOCERR_SMART_LOAD_TABLE_NOT_FOUND", "LOCERR_SMART_LOAD_TABLE_DUPLICATED", "LOCERR_VARIABLE_NO_NAME", "LOCERR_VARIABLE_DUPLICATE_NAME", "LOCERR_VARIABLE_INCONSISTENCY", "LOCERR_MEDIA_LIBRARY_LIST_FAILED", "LOCERR_MEDIA_LIBRARY_CONTENT_FAILED", "LOCERR_MEDIA_BUNDLING_FAILED", "LOCERR_MEDIA_UNBUNDLING_FAILED", "LOCERR_MEDIA_LIBRARY_NOT_FOUND", "LOCERR_FEATURE_DISABLED", "LOCERR_JSON_RPC_INVALID_REQUEST", "LOCERR_JSON_RPC_METHOD_NOT_FOUND", "LOCERR_JSON_RPC_INVALID_PARAMETERS", "LOCERR_JSON_RPC_INTERNAL_ERROR", "LOCERR_JSON_RPC_PARSE_ERROR", "LOCERR_MQ_SOCKET_CONNECT_FAILURE", "LOCERR_MQ_SOCKET_OPEN_FAILURE", "LOCERR_MQ_PROTOCOL_NO_RESPONE", "LOCERR_MQ_PROTOCOL_LIBRARY_EXCEPTION", "LOCERR_MQ_PROTOCOL_CONNECTION_CLOSED", "LOCERR_MQ_PROTOCOL_CHANNEL_CLOSED", "LOCERR_MQ_PROTOCOL_UNKNOWN_ERROR", "LOCERR_MQ_PROTOCOL_INVALID_STATUS", "LOCERR_EXTENGINE_GRPC_STATUS_OK", "LOCERR_EXTENGINE_GRPC_STATUS_CANCELLED", "LOCERR_EXTENGINE_GRPC_STATUS_UNKNOWN", "LOCERR_EXTENGINE_GRPC_STATUS_INVALID_ARGUMENT", "LOCERR_EXTENGINE_GRPC_STATUS_DEADLINE_EXCEEDED", "LOCERR_EXTENGINE_GRPC_STATUS_NOT_FOUND", "LOCERR_EXTENGINE_GRPC_STATUS_ALREADY_EXISTS", "LOCERR_EXTENGINE_GRPC_STATUS_PERMISSION_DENIED", "LOCERR_EXTENGINE_GRPC_STATUS_RESOURCE_EXHAUSTED", "LOCERR_EXTENGINE_GRPC_STATUS_FAILED_PRECONDITION", "LOCERR_EXTENGINE_GRPC_STATUS_ABORTED", "LOCERR_EXTENGINE_GRPC_STATUS_OUT_OF_RANGE", "LOCERR_EXTENGINE_GRPC_STATUS_UNIMPLEMENTED", "LOCERR_EXTENGINE_GRPC_STATUS_INTERNAL", "LOCERR_EXTENGINE_GRPC_STATUS_UNAVAILABLE", "LOCERR_EXTENGINE_GRPC_STATUS_DATA_LOSS", "LOCERR_EXTENGINE_GRPC_STATUS_UNAUTHENTICATED", "LOCERR_LXW_INVALID_OBJ", "LOCERR_LXW_INVALID_FILE", "LOCERR_LXW_INVALID_SHEET", "LOCERR_LXW_INVALID_EXPORT_RANGE", "LOCERR_LXW_ERROR", "LOCERR_LXW_ERROR_MEMORY_MALLOC_FAILED", "LOCERR_LXW_ERROR_CREATING_XLSX_FILE", "LOCERR_LXW_ERROR_CREATING_TMPFILE", "LOCERR_LXW_ERROR_ZIP_FILE_OPERATION", "LOCERR_LXW_ERROR_ZIP_FILE_ADD", "LOCERR_LXW_ERROR_ZIP_CLOSE", "LOCERR_LXW_ERROR_NULL_PARAMETER_IGNORED", "LOCERR_LXW_ERROR_MAX_STRING_LENGTH_EXCEEDED", "LOCERR_LXW_ERROR_255_STRING_LENGTH_EXCEEDED", "LOCERR_LXW_ERROR_SHARED_STRING_INDEX_NOT_FOUND", "LOCERR_LXW_ERROR_WORKSHEET_INDEX_OUT_OF_RANGE", "LOCERR_LXW_ERROR_WORKSHEET_MAX_NUMBER_URLS_EXCEEDED", "LOCERR_BDI_STATUS_OK", "LOCERR_BDI_GENERIC_ERROR_NOT_TRANSLATED", "LOCERR_CURL_UNSUPPORTED_PROTOCOL", "LOCERR_CURL_COULDNT_RESOLVE_PROXY", "LOCERR_CURL_COULDNT_CONNECT", "LOCERR_CURL_REMOTE_ACCESS_DENIED", "LOCERR_CURL_FTP_ACCEPT_FAILED", "LOCERR_CURL_FTP_ACCEPT_TIMEOUT", "LOCERR_CURL_FTP_CANT_GET_HOST", "LOCERR_CURL_PARTIAL_FILE", "LOCERR_CURL_QUOTE_ERROR", "LOCERR_CURL_WRITE_ERROR", "LOCERR_CURL_UPLOAD_FAILED", "LOCERR_CURL_OUT_OF_MEMORY", "LOCERR_CURL_OPERATION_TIMEDOUT", "LOCERR_CURL_FTP_COULDNT_USE_REST", "LOCERR_CURL_HTTP_POST_ERROR", "LOCERR_CURL_SSL_CONNECT_ERROR", "LOCERR_CURL_FILE_COULDNT_READ_FILE", "LOCERR_CURL_LDAP_CANNOT_BIND", "LOCERR_CURL_LDAP_SEARCH_FAILED", "LOCERR_CURL_TOO_MANY_REDIRECTS", "LOCERR_CURL_PEER_FAILED_VERIFICATION", "LOCERR_CURL_GOT_NOTHING", "LOCERR_CURL_SSL_ENGINE_NOTFOUND", "LOCERR_CURL_SSL_ENGINE_SETFAILED", "LOCERR_CURL_SSL_CERTPROBLEM", "LOCERR_CURL_SSL_CIPHER", "LOCERR_CURL_SSL_CACERT", "LOCERR_CURL_BAD_CONTENT_ENCODING", "LOCERR_CURL_LDAP_INVALID_URL", "LOCERR_CURL_USE_SSL_FAILED", "LOCERR_CURL_SSL_ENGINE_INITFAILED", "LOCERR_CURL_LOGIN_DENIED", "LOCERR_CURL_TFTP_NOTFOUND", "LOCERR_CURL_TFTP_ILLEGAL", "LOCERR_CURL_SSH", "LOCERR_SETEXPRESSION_TOO_LARGE"})
	AddArgumentsForType(NxLocalizedWarningCode(""), []string{"LOCWARN_PERSONAL_RELOAD_REQUIRED", "LOCWARN_PERSONAL_VERSION_EXPIRES_SOON", "LOCWARN_EXPORT_DATA_TRUNCATED", "LOCWARN_COULD_NOT_OPEN_ALL_OBJECTS"})
	AddArgumentsForType(NxMatchingFieldMode(""), []string{"MATCHINGFIELDMODE_MATCH_ALL", "MATCHINGFIELDMODE_MATCH_ONE"})
	AddArgumentsForType(NxPatchOperationType(""), []string{"Add", "add", "Remove", "remove", "Replace", "replace"})
	AddArgumentsForType(NxSelectionCellType(""), []string{"NX_CELL_DATA", "D", "NX_CELL_TOP", "T", "NX_CELL_LEFT", "L"})
	AddArgumentsForType(NxSortIndicatorType(""), []string{"NX_SORT_INDICATE_NONE", "N", "NX_SORT_INDICATE_ASC", "A", "NX_SORT_INDICATE_DESC", "D"})
	AddArgumentsForType(OtherLimitMode(""), []string{"OTHER_GE_LIMIT", "OTHER_LE_LIMIT", "OTHER_GT_LIMIT", "OTHER_LT_LIMIT"})
	AddArgumentsForType(OtherMode(""), []string{"OTHER_OFF", "OTHER_COUNTED", "OTHER_ABS_LIMITED", "OTHER_ABS_ACC_TARGET", "OTHER_REL_LIMITED", "OTHER_REL_ACC_TARGET"})
	AddArgumentsForType(OtherSortMode(""), []string{"OTHER_SORT_DEFAULT", "OTHER_SORT_DESCENDING", "OTHER_SORT_ASCENDING"})
	AddArgumentsForType(SearchContextType(""), []string{"CONTEXT_CLEARED", "Cleared", "CONTEXT_LOCKED_FIELDS_ONLY", "LockedFieldsOnly", "CONTEXT_CURRENT_SELECTIONS", "CurrentSelections"})
	AddArgumentsForType(SearchFieldSelectionMode(""), []string{"ONE_AND_ONLY_ONE", "OneAndOnlyOne"})
	AddArgumentsForType(SearchGroupItemType(""), []string{"FIELD", "Field", "GENERIC_OBJECT", "GenericObject"})
	AddArgumentsForType(SearchGroupType(""), []string{"DATASET_GROUP", "DatasetType", "GENERIC_OBJECTS_GROUP", "GenericObjectsType"})
	AddArgumentsForType(StateEnumType(""), []string{"LOCKED", "L", "SELECTED", "S", "OPTION", "O", "DESELECTED", "D", "ALTERNATIVE", "A", "EXCLUDED", "X", "EXCL_SELECTED", "XS", "EXCL_LOCKED", "XL", "NSTATES"})
	AddArgumentsForType(TotalMode(""), []string{"TOTAL_OFF", "TOTAL_EXPR"})
}
